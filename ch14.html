<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>十四章 Bless 那些东西！（面向对象的 Perl）</title>
<link rel="stylesheet" type="text/css" href="9780133593044.css"/>
</head>
<body>
<h2 id="ch14"><a id="page_447"/><span class="pd_ash">Chapter 14.</span> Bless Those
Things! (Object-Oriented Perl)</h2>
<div class="heading">
<h3 id="ch14lev1sec1">14.1 面向对象建模</h3>
<p class="noindent">学完本章之后，你应该可以读写下面的代码：</p>
</div>
<p class="pre">use Cirle::Area;<br/>use base qw(Shape);<br/>$c1 = Circle::Area-&gt;new();<br/>$c2 = Circle::Area-&gt;new();<br/><br/>$c1-&gt;setRadius(5);<br/>$c1-&gt;setArea();<br/>$c2-&gt;setRadius(12);<br/>$c2-&gt;setArea();<br/><br/>print $c1-&gt;getArea();</p>
<div class="heading">
<h4 id="ch14lev2sec1">14.1.1 什么是对象？</h4>
<p class="noindent">对象就是那些我们每天打交道的东西。大多数编程语言，比如
<em>Java</em> 和
<em>C++</em>，都有对象的设计，于是也就被称为是面向对象的编程语言。面向对象是一种按照真实世界的对象概念来设计程序的方法。早期的
Perl 并不支持面向对象，但是到了 Perl 4 到 5
的更新时候，面向对象的设计就被添加到了这个语言的功能中。</p>
</div>
<p class="indent">现在，许多程序员开始使用一个叫做 Moose 的模块来简化
Perl 的面向对象。我们稍后会介绍
Moose，不过目前我们先从传统的 Perl 风格开始讨论。</p>
<p class="indent">面向对象其实不是适合每个人的，也不一定是解决问题的最佳方案。并非每种问题都会推动你使用面向对象的风格。但是当程序越来越大、越来越复杂、越来需要代码重用、操作数据越来越复杂，也越来越需要在多个程序员之间分享代码的时候，面向对象就开始越来越有效率。请参考
<em><a
href="http://perldoc.perl.org/perlootut.html">http://perldoc.perl.org/perlootut.html</a></em>
这个文档。</p>
<p class="indent">面向对象是一种组织数据成为的单一元素的机制。比如
<em>C++</em> 和 <em>Java</em>
都是用<strong>对象</strong>变量来给数据打包的语言。要问什么是对象，那么就要比对真实世界的事物，比如一只猫、一台电脑或者一个员工。在语言学中，猫、电脑和员工都被称为名词。</p>
<p class="indent">然后，用来描述名词的词是形容词。比如：“猫是贼黑的”；“电脑是又轻薄而飞速的”；“员工的名字叫约翰”。在面向对象语言中，形容词被称为<strong>属性</strong>。</p>
<p class="indent">语言中用来描述动作的被称为动词。在这里我们叫它们<strong>方法</strong>。比如“猫吃了又睡”；“电脑启动，也会死机”；“员工在上班”。Perl
的方法其实就是特殊的子程序。</p>
<p class="indent">对象的数据一般来说是<strong>私有</strong>的。消息是通过方法来发给对象的，而方法通常是<strong>公共</strong>的。这个保护数据私有而公布访问方法的机制叫做<strong>数据封装</strong>。这是所有面向对象编程的基本理念。如果你手头有个对象叫做
<em>account</em>，那么处理它的方法就应该叫
<em>view()</em>、<em>withdraw()</em> 和 <em>deposit()</em>
等等。私有的是 account
的那些细节，而存取细节的方法是公开的，就好象大家都知道要用银行卡塞到
ATM 机才能操作一样。你能做的事情就是通过 ATM
菜单来管理你的钱，而不是直接钻到机器里面去拿钱。</p>
<div class="heading">
<h4 id="ch14lev2sec2">14.1.2 什么是类？</h4>
<p class="noindent">在面向对象语言中，打包数据和方法的机制就叫做<strong>类</strong>。类用来包装描述对象的各种属性，以及各种用来调用的<strong>方法</strong>。不过说到底，类的存在只是为了做模板或者蓝图的用处，描述了对象可能的细节和作为。类代表了一些相似的对象，比如一类员工、一种车辆或者某型的电脑。</p>
</div>
<p class="indent">数据包装和信息隐藏其实是相关的词汇，在面向对象的领域是非常普遍的理念。当我们用类来包装对象的属性和方法的时候，实际的数据就和用户分隔开了，也可以被称为<strong>封装</strong>在类里面了。类的用户只能通过类的设计者提供的方法来访问数据。对于
Perl 来说，没有类似 <em>C++</em> 和 <em>Java</em> 当中的
<em>private</em> 和 <em>public</em> 关键词。</p>
<p class="indent">对于类来说，对象就代表着实实在在的人、地点或者别的东西。类的作用是像蓝图一样规定对象的模型。而那些对象就是从这个类的模子里面产生出来的。比如
<em>Employee</em> 类的作用就是为了产生有具体
<em>name</em>，具体 <em>address</em> 和 <em>phone number</em>
的对象。那些从类里面产生的 <em>employee</em>
对象可能有所不同，但是肯定都有 <em>Employee</em> 类规定的
<em>name</em>、<em>address</em> 和 <em>phone number</em>
属性。尽管对象可能修改值的内容，但是总是属于
<em>Employee</em>
这个类的。类可以被进一步衍生为更高级的类。比如从
<em>Computer</em> 类来衍生出 <em>Laptop</em> 类，或者
<em>SmartPhone</em> 类。这样就可以重用 <em>Computer</em>
类里面定义的那些功能。这个衍生类的方法就叫做
<strong>inheritance</strong>。</p>
<p class="indent">在 Perl
原始的设计中，包就能担任面向对象体系中的类的功能。这对
Perl
来说并不是一个崭新的概念，因为数据的封装其实通过包就可以完成。还记得我们之前在谈到包的时候提到的朦朦胧胧的数据隐藏吗？因为每个包都有自己的符号表，其实也就是一个哈希，用来维护当前包中的全局名字（也就是非
<em>my</em>
名字）。这就使得为包创建的变量和子程序可以在包中拥有自己的独立名空间。所以，因为早期引入包这个概念，Perl
其实比大家的期望更早就加入了面向对象大家庭。</p>
<p class="indent">上一章我们创建了一个含有子程序的包，也就是 Perl
模块。当时我们组织代码的风格是过程性的，或者称为自顶向下的。当时我们关注的就是怎样在数据上执行子程序而已。而这一章，我们关注的更多是数据或对象，虽然做的还是同样的事情。Perl
5
引入的新语法能帮助我们更妥善的表达面向对象的思维模型。其实，面向过程或者面向对象的区别在于是专注于动作还是专注于对象。</p>
<p class="indent">在 Tom Christianson 写的讨论 Perl 和对象的网页（主题是
“Easy Perl5 Object
Intro”）中，他谈到人们常常会不好意思用那些为 Perl 5
的新面向对象语法而开发的模块。但是，有些问题确实适合用对象的思路来解决。Christianson
认为人们不应该避开这类模块，因为其实使用这类模块仍然是便利的，而且也不意味着要完全适应相关的复杂理念。哪怕你以后也不会对面向对象开发有兴趣，但是相信你仍然时不时要用到一些对象思路的模块。阅读这一章应该有助于你理解这类模块的设计理念。</p>
<p class="footnote"><a id="ch14fn1" href="ch14.html#ch14fn1a">1</a>. 请访问 <em><a
href="http://perl.com/doc/FMTEYEWTK/easy_objects.html">http://perl.com/doc/FMTEYEWTK/easy_objects.html</a></em>
来阅读 Tom Christianson 的 Web 页面.</p>
<div class="heading">
<h4 id="ch14lev2sec3">14.1.3 面向对象的基本术语</h4>
<p class="noindent">面向对象编程是一个非常宏大的主题。在这个领域中的书籍数量难以估计。为了构造更加复杂的软件，九零年代的许多开发人员已经从传统的、自顶向下的开发转变到面向对象的编程语言。这本书并不打算专门讨论面向对象的设计和编程。但是，还是有一些面向对象的词汇需要探讨清楚，才能开始介绍
Perl 的面向对象特性。请参考表 14.1 列出的这些词汇。</p>
</div>
<div class="tab-heading">
<div class="image"><a id="page_450"/><a id="ch14tab01"/><img src="graphics/14tab01.jpg" alt="Image"/></div>
<p class="tab-caption"><strong>表 14.1</strong> 面向对象关键词</p>
</div>
<div class="heading">
<h3 id="ch14lev1sec2">Perl 的类、对象和方法，与真实世界的对照</h3>
<p class="noindent">如同之前提到，面向对象是一种组织程序的方法，用来解决类似真实世界中的对象相关的问题。首先，你要买下一块地产来建造房屋。然后，你会雇佣一个建筑师来规划新房子的蓝图。当然，你要决定什么建筑风格、多少房间、门窗的数量等等。接着，你要找一些工人来建造房屋。竣工之后，你要拿到开门的钥匙，然后进去涂抹装饰整理房屋、丢掉建筑垃圾。</p>
</div>
<p class="indent">不过，既然你手头已经有了建筑蓝图，以后就可以再买一块类似的新地产，建造一个类似的新房子。只不过这次可以涂上新的颜色、改变庭院的设计等等。也就是说，你可以有一个设计相同、但完全崭新的房子，当然地址也完全不同。</p>
<p class="indent">在面向对象语言来说，房子就是一个对象，也就是一个名词。设计风格和房间的数量都是描述对象的属性，有点像是形容词。而涂抹、打扫、展示房间等等都是有关对象的动作。类就是建筑师设计的蓝图。</p>
<p class="indent">所有这些必有都有助于我们之后（通过更多例子）渐渐明白
Perl 是如何穿件、操作并销毁对象的。</p>
<div class="heading">
<h4 id="ch14lev2sec4">14.2.1 步骤</h4>
<p class="noindent">这一章会详细讨论许多的主题。作为梗概，下面的步骤有助于我们创建（并定义）一种叫做对象的新数据类型：</p>
</div>
<p class="indenthangingN"><strong>1.</strong>
定义什么是你需要的对象（名词），以及对象要达成的功能（设计），并封装成类。比如，房屋、员工、圆型、数据库、文件句柄或者别的东西。</p>
<p class="indenthangingN"><strong>2.</strong>
在一个类的包里面创建新的对象（也就是一个标量、数组、哈希或子程序之类的引用）。通过构造器，给它一个唯一的标识。</p>
<p class="indenthangingN"><strong>3.</strong>
通过属性的赋值来描述这个对象。这个描述过程也可以事后在程序中慢慢完成。</p>
<p class="indenthangingN"><strong>4.</strong>
把这个对象祝福成为某个类的实例，从而使对象和类产生关联。</p>
<p class="indenthangingN"><strong>5.</strong>
定义实例方法来访问这个对象，从而说明对象的使用方法。</p>
<p class="indent">在定义了类、对象和方法之后，我们可以这样来定义用户接口：</p>
<p class="indenthangingN"><strong>1.</strong>
使用这个类，也就是把它载入程序的内存空间。</p>
<p class="indenthangingN"><strong>2.</strong> 通过构造器来创建一个对象实例。</p>
<p class="indenthangingN"><strong>3.</strong> 通过访问方法来操作此对象。</p>
<p class="indent">最后我们可以：</p>
<p class="indenthangingN"><strong>1.</strong> 通过继承来重用类。</p>
<p class="indenthangingN"><strong>2.</strong> 销毁对象，也就是从内存中释放对象。</p>
<div class="heading">
<h4 id="ch14lev2sec5">14.2.2 一个完成的面向对象 Perl 程序</h4>
<p class="noindent">在讨论细节之前，我们先看一个完整的面向对象 Perl
脚本，然后在这一章中一步步的分析解说。在这一章的末尾，你应该可以毫无困难的解读其中所有的代码了。实际上，这个例子可以说是非常基础的，所以你会有很多改进的意见。目前，这个例子还可以用来做一个起步的模板。注意这里的类定义和调用代码是在同一个文件当中的。稍后我们会把他们分成两个部分。一个是类的实现叫做模块文件，另外一个文件是模块的调用代码。明确的说，我们会创建一个模块
House.pm，还有一个用户调用程序。</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_452"/><a id="ch14exa01"/>例 14.1</p>
<p class="codelink1"><a id="p14exa01" href="ch14_images.html#p14exa01a">Click here to view code
image</a></p>
<p class="pre1">package House;&#160;&#160;# <span class="EmpItalic">House class</span><br/>use warnings;<br/>use strict;<br/>sub new{&#160;&#160;# <span class="EmpItalic">The constructor method</span><br/>&#160;&#160;&#160;my $class=shift;<br/>&#160;&#160;&#160;my $house_obj={ "Owner"=&gt;"Planet Bank",&#160;&#160;#
<span class="EmpItalic">Properties</span>/<span
class="EmpItalic">attributes</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Color"=&gt;"Beige",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Payment"=&gt;undef,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;return bless($house_obj, $class); # <span
class="EmpItalic">The blessing creates the object</span><br/>}<br/><br/>sub set_owner{&#160;&#160;# <span class="EmpItalic">Instance/Access
methods</span><br/>&#160;&#160;&#160;my $self=shift;<br/>}<br/>sub set_color{<br/>&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;$self-&gt;{"Color"}=shift;<br/>}<br/>sub set_payment{<br/>&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;my $payment=shift;<br/>&#160;&#160;&#160;$self-&gt;{"Payment"}=$payment unless $payment &lt; 0;;<br/>}<br/>sub get_owner{&#160;&#160;# <span class="EmpItalic">Retrieve data from the
object</span><br/>&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;return $self-&gt;{Owner};<br/>}<br/><br/>#----------<span class="EmpItalic">End of Class
definition</span>----------------------------------<br/><br/># <span class="EmpItalic">User of the Class</span><br/>use Data::Dumper;&#160;&#160;# <span class="EmpItalic">We'll look at the
structure of the object</span><br/><br/>my $house1=House-&gt;new();&#160;&#160;&#160;# <span class="EmpItalic">Make
a new house object and get back</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">its address</span><br/>my $house2=House-&gt;new();&#160;&#160;&#160;# <span class="EmpItalic">Make
another house object</span><br/>$house2-&gt;set_owner("Mr. T"); # <span class="EmpItalic">Change the default
owner of the</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">second house</span><br/>$house2-&gt;set_payment("2000");# <span class="EmpItalic">Set the payment of
the second house</span><br/>print "The owner of my first house is ", $house1-&gt;get_owner(),"\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Retrieve data from the first house.</span><br/><br/>print Dumper($house1,$house2);&#160;&#160;# <span class="EmpItalic">Look at
the content of the</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">house objects</span><br/><a id="page_453"/>(Output)<br/><span class="EmpItalic"></span><br/><span class="EmpItalic">$VAR1 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Owner' =&gt; 'Planet Bank',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Payment' =&gt; undef,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Color' =&gt; 'Beige'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'House' );</span><br/><span class="EmpItalic">$VAR2 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Owner' =&gt; 'Mr. T',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Payment' =&gt; 2000,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Color' =&gt; 'Beige'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'House' );</span><br/>&#160;&#160;<span class="EmpItalic">}</span></p>
<hr/></div>
<div class="heading">
<h5 id="ch14lev3sec1">Perl 包就是类</h5>
<p class="noindent">包用来实现类。面向对象的 Perl 并没有 Class
这个关键字，而是把包称作类。类代码通常是存放在一个附属名为
.<em>pm</em>
的文件中的，主文件名通常就是类名。如果你想要区分这两个关键词的话，那么类就是一个带有特殊子程序（称为方法，用来创建和操作对象）的包。Perl
的包通常含有以下几个部分：</p>
</div>
<p class="indenthangingN"><strong>1.</strong> 用来定义对象的数据。</p>
<p class="indenthangingN"><strong>2.</strong>
用来创建对象，并祝福此对象的构造函数。</p>
<p class="indenthangingN"><strong>3.</strong>
其他的特殊子程序，称为方法，用来创建、访问、操作并销毁对象。</p>
<p class="indent">不像其他编程语言，在 Perl 当中并没有
<em>private</em>、<em>public,</em> 或者 <em>protected</em>
这样的关键字。Perl
使用包的名字空间机制来存储类数据和方法，而 <em>my</em>
函数用来将变量限定在词法范围，并通过 <em>bless</em>
函数来确保创建的对象都能找到对应的类。总之，对象就是匿名哈希、数组或者子程序的引用，对于它们的存取是通过特殊的方法函数来实现的，而引用就是访问对象的方法。</p>
<div class="heading">
<h5 id="ch14lev3sec2">Perl 类</h5>
<p class="noindent">因为类其实就是一个包，所以它可以拥有自己的符号表，其中的全局数据或函数可以在类的外部直接访问。</p>
</div>
<p class="indent">与其他语言不同的是，Perl
并没有严格的区别模块的公有或私有边界。.<sup><a
id="ch14fn2a"
href="ch14.html#ch14fn2">2</a></sup>为了要实现私有数据，需要使用特殊的技巧（请参考本章后面
<a href="ch14.html#ch14lev1sec3">14.3
节</a>的匿名子程序、闭包和私有数据）。</p>
<p class="footnote"><a id="ch14fn2" href="ch14.html#ch14fn2a">2</a>. Perl
编程，第二版，第 287 页；O&#8217;Reilly 出版社，Sebastopol
加州，1998 年由 Larry Wall 和 Randal Schwartz 合著。</p>
<div class="fig-heading">
<div class="image"><a id="page_454"/><a id="ch14fig01"/><img src="graphics/14fig01.jpg" alt="Image"/></div>
<p class="fig-caption"><strong>图 14.1</strong> 类的构成</p>
</div>
<div class="heading">
<h4 id="ch14lev2sec6">14.2.3 Perl 对象</h4>
<div class="heading">
<h5 id="ch14lev3sec3">引用</h5>
<p class="noindent">在开始之前，需要通过一个引用来创建 Perl
对象。如果你仍然不熟悉如何使用引用的话，可能需要参考<a
href="ch12.html#ch12">第十二章</a>。基本上，引用就是一个标量，其中存放的是其他变量的地址。引用可以指向一个无名的数据，于是被称为<strong>匿名变量</strong>。比如，下面就是一个名为
<em>$ref</em>
的引用，指向了一个匿名哈希，其中有两个键值对：</p>
</div>
</div>
<p class="codelink"><a id="p454pro01" href="ch14_images.html#p454pro01a">Click here to view code
image</a></p>
<p class="pre">my $ref={"Owner"=&gt;"Tom", "Price"=&gt;"25000"};</p>
<p class="indent">为了存取匿名哈希，就需要使用箭头操作符来对
<em>$ref</em> 引用（也就是指针）进行如下的反引用：</p>
<p class="pre">$ref-&gt;{"Owner"}</p>
<p class="indent">为了要构造一个 Perl
对象，首先得创造一个引用。尽管引用可以指向任何的数组、标量或子程序，不过通常是指向一个匿名哈希的。哈希中存放的是数据的名称和对应的对象属性。</p>
<div class="heading">
<h5 id="ch14lev3sec4">什么是祝福？</h5>
<p class="noindent">引用必须被“祝福”过，才能成为一个 Perl
对象；换句话说，这个被引用指向的东西必须知道自己属于哪个包。实现的方法就是把引用祝福为一个包。你可以把这个祝福过程理解为构造了一个新的数据类型，也就是真正的对象。</p>
</div>
<p class="codelink"><a id="p455pro01" href="ch14_images.html#p455pro01a">Click here to view code
image</a></p>
<p class="pre"><a id="page_455"/>my $ref={Owner=&gt;"Tom", Price=&gt;250000};&#160;&#160;#
<span class="EmpItalic">Properties Owner, Price</span><br/><span class="EmpStrong">bless($ref, "House");</span>&#160;&#160;# <span
class="EmpItalic">Tag the reference as belonging to a House</span><br/><span class="EmpStrong">return $ref</span>;&#160;&#160;# <span
class="EmpItalic">A reference to the object is returned to the caller</span></p>
<p class="indent">这个 <em>bless</em>
函数就是用来实现这样的功能：它期待两个参数，第一个参数是引用，而第二个可选参数是类（也就是包）的名字。然后这个
<em>bless</em>
函数就给被引用的东西打上相应的标签。其实就是创建一个内部指针来跟踪对象属于的包。对象（其实通常是哈希）于是就被祝福成了相应的类的成员实例。如果调用的时候没有可选的第二个参数的话，那么
<em>bless</em> 函数就会用当前的包名字来祝福对象。</p>
<p class="indent">然后 <em>bless</em> 函数返回祝福过的对象。在<a
href="ch14.html#ch14fig02">图
14.2</a>中，对象地址在祝福前后都会显明。注意在祝福以后，为这个对象打上的类标签是
<em>House</em>。</p>
<div class="fig-heading">
<div class="image"><a id="ch14fig02"/><img src="graphics/14fig02.jpg" alt="Image"/></div>
<p class="fig-caption"><strong>图 14.2</strong> 祝福前后的地址。</p>
</div>
<p class="indent">因为祝福过程使得对象和包的名字（也就是类名）产生关联，Perl
就能够跟踪对象所属的包。于是我们不需要调用时候使用
::
这样的语法。一个对象可以被祝福成为某个类的实例，然后再次被祝福成为另一个类的实例。但是，一个对象某个时刻只可能属于一个类。一旦对象得到祝福，就不必再考虑使用
<em>@EXPORT_OK</em> 或者 <em>@EXPORT</em>
数组这样的方法来输出符号表。实际上，作为一个默认的规矩，只要是面向对象的模块，就不必输出任何符号。</p>
<div class="heading">
<h4 id="ch14lev2sec7"><a id="page_456"/>14.2.4 Methods Are Perl Subroutines</h4>
<div class="heading">
<h5 id="ch14lev3sec5">Definition</h5>
<p class="noindent">所谓<strong>方法</strong>是个一个与对象互动的子程序。比如，它可以用来创建对象，存取或者修改对象的数据。方法作为一个特殊的属于类的子程序，他的第一个参数总是以下的东西之一：</p>
</div>
</div>
<p class="indenthangingN"><strong>1.</strong> 类名（也就是包名）</p>
<p class="indenthangingN"><strong>2.</strong> 对象的引用</p>
<p class="indent">第一个参数是 Perl
默默发送的。哪怕你调用过程的时候没有带上任何参数，Perl
还是会自动带上一个参数，要么是包名字，要么就是对象引用。否则，它就和其他子程序没有任何区别了。在<a
href="ch14.html#ch14exa01">例 14.1
</a>中，我们创建了两个房子对象。创建的不走是通过一个叫做
<em>new</em>
的方法实现的（当然这个方法也可以用其他任何的名字）。在例子中，调用的时候我们首先是书写类名
<em>House</em>，然后是一个箭头，<em>House</em>-<em>&gt;new()</em>。Perl
会把箭头左边的东西作为第一个参数传递给方法。所以，当你调用的
<em>new()</em> 方法检查第一个参数的时候，其实是有个叫做
<em>House</em> 的类名在其中的。</p>
<p class="indenthangingN"><strong>1.</strong> Perl 暗暗的把类名发送给 <em>new()</em>
方法。</p>
<div class="image"><img src="graphics/456pro01.jpg" alt="Image"/></div>
<p class="indenthangingNP">尽管调用 <em>new()</em> 方法的参数列表是空的，Perl
还是会把箭头左边的部分发送给方法。作为这个例子，发给
<em>new()</em> 方法的是 <em>House</em> 这个名字。</p>
<p class="indenthangingN"><strong>2.</strong> Perl 发送给 <em>$house2</em> 对象的
<em>set_owner()</em> 方法的是一个引用。</p>
<p class="codelink"><a id="p456pro02" href="ch14_images.html#p456pro02a">Click here to view code
image</a></p>
<p class="pre"><span class="EmpStrong">$house2-&gt;set_owner</span>("Mr. T"); # <span
class="EmpItalic">Perl sends the address of the second</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">house as the first argument to set_owner()</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">and "Mr. T" as the second argument</span></p>
<p class="indent">这里 <em>set_owner()</em>  方法的第一个参数看似
<em>Mr. T</em>，实际却不是。对第二个房子对象的引用
<em>$house2</em>
才是。只是这次我们是通过箭头左边的引用，而不是类名来传递这个参数的。Perl
会自动把引用作为第一个参数，而 <em>Mr. T</em>
只能排在第二。这样，你就可以确认 Perl
能知道是哪个房子属于 Mr T。</p>
<div class="heading">
<h5 id="ch14lev3sec6"><a id="page_457"/>方法的类型</h5>
<p class="noindent">现在我们已经做了简单的介绍，下面就是关于方法的深入介绍。方法有两种类型：类方法（或者称为静态方法），或者实例方法。<sup><a
id="ch14fn3a"
href="ch14.html#ch14fn3">3</a></sup>类方法的第一个参数应该是类名，而实例方法的第一个参数应该是实例引用。</p>
</div>
<p class="footnote"><a id="ch14fn3"
href="ch14.html#ch14fn3a">3</a>.
每本书（的作者）对方法有不同的分类方法。比如，Larry
Wall 就把方法分类为：类方法、实例方法和两栖方法。</p>
<p class="indent"><strong>类方法</strong>顾名思义就是对整个类起作用的方法。比如，这种方法可以创建对象，或者在一组对象上操作。这样的方法也是独立的，也就是说它并不依赖于对象（作为第一个参数）。比如，统计对象总数，这样的方法需要跟踪并管理为类创建的所有对象，所以很适合作为类方法。又比如，对于对象的创建来说，这样的<strong>构造器</strong>方法也是典型的类方法，所以第一个参数必然是类名。对于
Perl 来说，构造器方法通常被命名为
<em>new</em>，当然我们也可以随心所欲的使用其他的名称。另外，创建对象的操作通常被称为<strong>实例化</strong>，或者叫做创建类实例。</p>
<p class="indent">而<strong>实例方法</strong>也可以被称为存取方法或者赋值方法（英文名称为
Mutator
method），它们用来定义对象数据的赋值、修改和读取。在创建实例之前，对象方法毫无用处。然而，一旦对象引用创建好了，实例方法就可以通过引用（通常是
<em>$this</em> 或
<em>$self</em>）来操作对象数据。这类的方法期待第一个参数是对象引用。这样，方法才知道要作用在哪个对象上面。所以，<em>$dogref</em>-&gt;<em>speak()</em>
这样的调用就会通过狗对象的引用来获取“旺旺”这样的结果，而
<em>$catref</em>-<em>&gt;speak()</em>
这个调用会返回的则是猫猫对象的“喵喵”声。Perl
知道怎么正确的处理对象引用。</p>
<div class="heading">
<h5 id="ch14lev3sec7">调用方法</h5>
<p class="noindent">Perl
提供了一种特殊的语法来调用方法。与之前的包方法调用语法
<em>package::function</em>
不同，现在我们用两种方法来调用：类方法调用，或者实例方法调用。对于每种调用来说又有两种语法：面向对象语法或者间接语法。如果你使用对象的话，任何一种调用都是可以的，只是面向对象的语法来得更加清晰一点。以前那种两个冒号的语法有点歧义，不建议使用。</p>
</div>
<p class="indent"><strong>注意</strong>：方法与一般的子程序差别在于第一个隐含的参数，要么是类的名字，要么就是对象引用。如果你调用的方法接受三个参数，那么实际上就会传给它四个参数。第一个参数就是面向对象语法的箭头左边的对象。</p>
<div class="heading">
<h6 id="ch14lev4sec1">类方法语法</h6>
<p class="noindent">假定方法名叫 <em>new</em>，而返回的值存储在 <em>$ref</em>
这个对象的引用中。</p>
</div>
<p class="codelink"><a id="p457pro01" href="ch14_images.html#p457pro01a">Click here to view code
image</a></p>
<p class="pre">1) $ref = class-&gt;new( list of arguments );&#160;&#160;&#160;# <span
class="EmpItalic">object-oriented syntax</span><br/>2) $ref = new class ( list of arguments );&#160;&#160;&#160;# <span
class="EmpItalic">indirect syntax</span></p>
<p class="indent"><a id="page_458"/>如果类名叫 <em>House</em>，Perl 会把调用</p>
<p class="pre">$ref = House-&gt;new();</p>
<p class="noindent">翻译成</p>
<p class="pre1">$ref = House::new(House);</p>
<div class="heading">
<h6 id="ch14lev4sec2">实例方法调用</h6>
<p class="noindent">假定方法名叫 <em>display</em>，而引用对象名叫 <em>$obj</em>。</p>
</div>
<p class="codelink"><a id="p458pro01" href="ch14_images.html#p458pro01a">Click here to view code
image</a></p>
<p class="pre">1) $obj-&gt;display( list of arguments );&#160;&#160;&#160;&#160;# <span
class="EmpItalic">object-oriented syntax</span><br/>2) display $obj ( list of arguments );&#160;&#160;&#160;&#160;# <span
class="EmpItalic">indirect syntax</span></p>
<p class="indent">这个例子中使用了箭头符号来调用方法，这种语法就是最常用的面向对象语法。我们会在这本书中使用这种语法。而那种没有箭头符号的调用方法是间接调用语法。</p>
<p class="indent">当 Perl
发现前两种调用方法发生的时候，它都能明白这个对象对应的类是什么，因为这个对象已经得到了所谓的“祝福”，也就是说有一个指针在跟踪它。<sup><a
id="ch14fn4a" href="ch14.html#ch14fn4">4</a></sup></p>
<p class="footnote"><a id="ch14fn4"
href="ch14.html#ch14fn4a">4</a>.
这种跟踪的机制被称为是运行时绑定，请参考《高级 Perl
编程》；O’Reilly 出版社，Sebastopol 加州，1997 年由
Srinivasan, S. 著。</p>
<p class="indent">不论你这样调用</p>
<p class="pre">display $ref (<span class="EmpStrong">arguments...</span>);</p>
<p class="noindent">或者</p>
<p class="pre">$ref-&gt;display(<span class="EmpStrong">arguments...</span>);</p>
<p class="noindent">只要 <em>$ref</em> 是一个名叫 <em>House</em>
类的对象指针，那么 Perl 就会把调用翻译成</p>
<p class="codelink"><a id="p458pro02" href="ch14_images.html#p458pro02a">Click here to view code
image</a></p>
<p class="pre">House::display($ref, arguments...);</p>
<div class="heading">
<h5 id="ch14lev3sec8">使用构造器来创建对象</h5>
<p class="noindent">为要创建 <em>House</em>
类，我们先得创建一个包。这个包被命名为
<em>House</em>。而且，这个包现在就是面向对象术语中的<strong>类</strong>了。一个对象的创建是通过名为构造器的方法来实现的，这样你的程序就知道怎样访问对象的内存空间了。</p>
</div>
<p class="indent">属性用来描述对象的特性，比如拥有者、风格、大小、颜色等等。在我们的例子里面，房子的属性包括
<em>Owner</em>，<em>Color</em> 和
<em>Payment</em>。设置属性的方法非常繁多。通常，属性是通过一个匿名哈希（包含的键值对）来存储的。</p>
<p class="indent">在之后的例子里面，类名是
<em>House</em>，而构造器的名字叫做 <em>new()</em>。<em>new()</em>
这个名字不是必然的，你可以根据实际情况选择最适合的名字。因为我们正在建造一座新房子，所以
<em>new()</em>
这个名字看上去还是很适合的。当然，我们也可以使用
<em>create()</em>、<em>build()</em>、<em>startup()</em> 或者
<em>init()</em>。构造器的作用就是为新的 <em>House</em>
对象分配内存，也就是说获得对象引用。我们可以事后再设置属性的值，而分配地址的任务不能拖延。这就好像你造房子的时候必须先选址一样的。</p>
<p class="indent">类似其他的函数，构造器可以从主调代码中获得其他的参数，从而给实例变量赋值。下一步就是确保
Perl 能追踪实例地址对应的类。这里 <em>house</em>
对象之所以知道它属于 <em>House</em> 类，是因为 <em>bless</em>
函数起到的作用。简单来说，它能把输入的指针变成对象。也就是给那个内存打上
House 标签，而不是别的什么 Car、Horse 或者 Cat 之类。</p>
<p class="indent"><a href="ch14.html#ch14exa02">例 14.2</a>
显示了构造器的定义方法：创建引用，通过 <em>bless</em>
来构造对象。在这段代码中，我们只是定义方法。后面，我们会调用它。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa02"/>例 14.2</p>
<p class="codelink1"><a id="p14exa02" href="ch14_images.html#p14exa02a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;<span class="EmpStrong">package
House;</span>&#160;&#160;&#160;# <span class="EmpItalic">Name of the
class</span><br/><br/>2&#160;&#160;<span class="EmpStrong">sub new</span>{&#160;&#160;# <span
class="EmpItalic">The constructor method</span><br/><br/>3&#160;&#160;&#160;&#160;&#160;&#160;my $class=shift @_;&#160;&#160;# <span
class="EmpItalic">First argument is the name of the class</span><br/>4&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
$house_obj</span>={ "Owner"=&gt;"Planet Bank", # <span
class="EmpItalic">Default attributes</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Color"=&gt;"Beige",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Payment"=&gt;undef,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/><br/>5&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">bless($house_obj, $class);</span>&#160;&#160;# <span
class="EmpItalic">Create the object by blessing it</span><br/>6&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return
$house_obj</span>;<br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">The blessing transforms the
ordinary pointer into a pointer to an</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">object. The object now belongs
to the House</span> class.<br/>&#160;&#160;&#160;}</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 声明 <em>House</em>
包。这个包可以被称为类，因为它包含一个方法，而且这个方法会“祝福”一个引用。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 在面向对象术语中，<em>new</em>
子程序被称为是<strong>构造器</strong>。构造器的主要任务就是创建并初始化一个对象。在
Perl
来说，并没有什么特殊的语法来识别它。这个方法被称为是类方法，因为它的第一个参数（可以从
@_ 中 shift 出来）是类名。（参考 <a
href="ch14.html#ch14exa04">例 14.4</a>
了解怎样调用）这个子程序的任务就是把引用“祝福”成某个类的成员，然后返回这个引用。这个子程序可以被称为<strong>方法</strong>，而返回的东西被称为是<strong>对象</strong>。整个包被称为是一个<strong>类</strong>。</p>
<p class="sb-indenthangingN"><a id="page_460"/><strong>3.</strong>
这类子程序收到的第一个参数是包名（也就是类名），这里是
<em>House</em>。这也是方法和普通子程序的另一个区别所在。方法的第一个参数是类名，或者可以说成是对象名。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这个 <em>$house_obj</em>
对象引用被指向一个匿名哈希。其中 <em>Payment</em>
得到的值是
<em>undef</em>，也就是说目前这个字段的值无法确定。这些键值对的存在是为了给
<em>house</em>
对象提供默认值。你也可以使用一个空哈希来产生对象，比如
<em>$house_obj = {}</em>。这些值可以通过<a
href="ch14.html#ch14exa03">例 14.3</a>定义的方法来存取。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 引用 <em>$house_obj</em> 作为 <em>bless()</em>
函数的第一个参数，而此函数的第二个参数是类名。得到“祝福”的其实不是引用，而是引用指向的东西，或者称为
<strong>referent</strong>。于是我们会给这个地址存储的东西打上一个类名标签，使得一个普通引用变成一个对象引用。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 现在可以把对象引用返回给调用者。</p>
<hr/></div>
<div class="heading">
<h5 id="ch14lev3sec9">创建实例方法</h5>
<p class="noindent">在构造器方法以外，还可以定义其他方法。在面向对象的世界里，这些方法被称为公共方法，也就是用来访问对象的方法（只是必须等到对象创建以后）。它们定义了对象的动作，也就是可以对它做点什么，或者它可以做点什么。实际上，方法应该是访问对象的唯一途径才对。</p>
</div>
<p class="indent">对我们的 <em>house</em>
对象来说，应该有个一方法叫做迁入，另一个方法可能叫做打扫，还有展示等等。对于
Perl
来说，方法其实就是升级版的子程序。下面我们就定义
<em>House</em>
类的三个实例方法（或者叫做赋值方法、存取方法等等）。这三个方法包括
<em>set_owner()</em>、<em>set_color()</em> 和
<em>set_price()</em>，其实都需要等到对象实例创建之后才能用。换句话说，你不可能对一个尚不存在的房子做许多奇怪的动作，比如刷墙或出售。<strong>实例方法的第一个参数永远是对象引用。</strong>一旦方法获取了对象的地址，就能知道它属于哪个类（或者说它被祝福成了那个类），也就可以按照相应的类定义的代码来执行（比如设定值、返回值、修改默认值；或者是例子中的计算按揭额度、修建车库、打扫厨房、拆毁房子等等）。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa03"/>例 14.3</p>
<p class="codelink1"><a id="p14exa03" href="ch14_images.html#p14exa03a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;package House;&#160;&#160;&#160;# <span class="EmpItalic">Name
of the class</span><br/><br/>2&#160;&#160;sub new{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $house_obj={ "Owner"=&gt;"Planet
Bank",&#160;&#160;&#160;# <span class="EmpItalic">Default attributes</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Color"=&gt;"Beige",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Payment"=&gt;undef,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;&#160;&#160;return bless($house_obj, $class);<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;#--------------------------------------------------------------------<br/><a id="page_461"/>&#160;&#160;&#160;# <span class="EmpItalic">Create the
instance methods that will manipulate the object</span><br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">The setter methods</span><br/>3&#160;&#160;<span class="EmpStrong">sub
set_owner{</span>&#160;&#160;&#160;# <span class="EmpItalic">Access or
instance methods</span><br/>4&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my ($self,
$owner)= @_;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">First argument is a pointer to the house
object</span><br/>5&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">$self-&gt;{"Owner"}=$owner;</span>&#160;&#160;&#160;#
<span class="EmpItalic">Set a new owner</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;<span class="EmpStrong">sub set_color{</span>&#160;&#160;#
<span class="EmpItalic">Setter method</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
($self,$color) = @_;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">First argument
is a pointer to the house object.</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">$self-&gt;{"Color"}=$color;</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><br/>&#160;&#160;&#160;<span class="EmpStrong">sub set_payment{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my ($self,
$payment) = @_;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">$self-&gt;{"Payment"}=$payment;</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">The getter methods</span><br/><span class="EmpStrong">6&#160;&#160;sub get_owner{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
$self=shift;</span><br/><span class="EmpStrong">7&#160;&#160;&#160;&#160;&#160;return
$self-&gt;{"Owner"};</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;<span class="EmpStrong">sub get_color{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
$self=shift;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return
$self-&gt;{"Color"};</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;<span class="EmpStrong">sub get_payment{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $self=shift;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return
$self-&gt;{"Payment"};</span><br/>&#160;&#160;&#160;}</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这个类名叫 <em>House</em>。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 构造器定义了默认属性。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 以下开始定义实例方法。现在定义的是
<em>set_owner</em>
方法，算是一个赋值方法（或者称为存取方法）。它的作用就是为对象存入数据。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里 <em>set_owner</em>
收到的第一个参数是对象引用，被赋值到 <em>$self</em>
变量中，这是一个常用变量名，当然也可以使用你喜欢的任何其他名字。第二个参数才是这个对象将要获取的
<em>Owner</em> 属性值。当用户调用这个方法的时候，Perl
会默默的把对象引用作为第一个参数传递过去，然后才是用户代码中的其他参数。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 通过 <em>$self</em> 这个对象引用来设置
<em>Owner</em> 属性的值。</p>
<p class="sb-indenthangingN"><strong>6.</strong>
这个方法叫做读取方法，作用就是从对象中取出数据。第一个参数仍然是对象地址，进入变量
<em>$self</em> 中。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里返回的是 <em>Owner</em> 属性的值。</p>
<hr/></div>
<div class="heading">
<h5 id="ch14lev3sec10"><a id="page_462"/>调用方法（用户端）</h5>
<p class="noindent">目前我们已经创建了类和方法，现在是时间来调用方法了。在这里，我们把方法的定义和使用放在一个文件里。不过，到了下一节我们就会把它们分成两个文件：一个是类模块文件（<em>.pm</em>
结尾），另一个是用户端的逻辑。不论是使用一个文件还是多个，类的定义总是要和主程序分开的。在下面的例子中，实例方法定义被裁剪了，以便缩短样例代码的长度。</p>
</div>
<div class="fig-heading">
<div class="image"><a id="ch14fig03"/><img src="graphics/14fig03.jpg" alt="Image"/></div>
<p class="fig-caption"><strong>图 14.3</strong> 不同地址的两所房子</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa04"/>例 14.4</p>
<p class="codelink1"><a id="p14exa04" href="ch14_images.html#p14exa04a">Click here to view code
image</a></p>
<p class="pre1"># <span class="EmpItalic">The Class Definition Outside the Main Part of the
Program</span><br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>1&#160;&#160;package House;&#160;&#160;&#160;# <span class="EmpItalic">Name
of the class</span><br/>2&#160;&#160;sub new{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $house_obj={ "Owner"=&gt;"Planet
Bank", # <span class="EmpItalic">Default attributes</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Color"=&gt;"Beige",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Payment"=&gt;undef,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;&#160;&#160;return bless($house_obj, $class);<br/>&#160;&#160;&#160;}<br/>#------------------------------------------------------------------------<br/>&#160;&#160;&#160;# <span class="EmpItalic">Create the functions/methods
that will manipulate the object</span><br/>3&#160;&#160;sub set_owner{&#160;&#160;&#160;# <span
class="EmpItalic">Access or instance methods</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">First
argument is a pointer to the house object</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;{"Owner"}=shift;&#160;&#160;&#160;#
<span class="EmpItalic">Now set a new owner.</span><br/>&#160;&#160;&#160;}<br/><a id="page_463"/>&#160;&#160;&#160;sub set_color{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">First argument
is a pointer to the house object.</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;{"Color"}=shift;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;sub set_payment{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;{"Payment"}=shift;<br/>&#160;&#160;&#160;}<br/><br/>4&#160;&#160;<span class="EmpStrong">sub get_owner{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
$self=shift;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return
$self-&gt;{Owner};</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><br/><span
class="EmpStrong">#------------------------------------------------------</span><br/><span class="EmpStrong">#</span>&#160;&#160;<span class="EmpItalic">Now we
enter the main part or user part of the program</span><br/>&#160;&#160;&#160;use Data::Dumper;&#160;&#160;# <span
class="EmpItalic">Dump out both objects to display contents</span><br/><br/>5&#160;&#160;<span class="EmpStrong">my $house1 = House-&gt;new();</span> #
<span class="EmpItalic">Call constructor to create</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">a new house object</span><br/><br/>6&#160;&#160;<span class="EmpStrong">my $house2=House-&gt;new();</span> #
<span class="EmpItalic">Create another house object</span><br/><br/>7&#160;&#160;<span class="EmpStrong">$house2-&gt;set_owner("Mr. T");</span>
# <span class="EmpItalic">Call access method for the second house</span><br/><br/>&#160;&#160;&#160;<span
class="EmpStrong">$house2-&gt;set_payment("2000");</span><br/><br/>8&#160;&#160;<span class="EmpStrong">print "The owner of my first house is
",$house1-&gt;get_owner(),"\n";</span><br/><br/>9&#160;&#160;print Dumper($house1,$house2);&#160;&#160;# <span
class="EmpItalic">Take a look at the two instances</span><br/><br/>(Output)<br/><span class="EmpItalic"></span><br/><span class="EmpItalic">$VAR1 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Owner' =&gt; 'Planet Bank',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Payment' =&gt; undef,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Color' =&gt; 'Beige'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'House' );</span><br/><span class="EmpItalic">$VAR2 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Owner' =&gt; 'Mr. T',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Payment' =&gt; '2000',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Color' =&gt; 'Beige'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'House' );</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_464"/>注解</p>
<p class="sb-indenthangingN"><strong>1.</strong> 声明 <em>House</em> 类。</p>
<p class="sb-indenthangingN"><strong>2.</strong>
这里的构造器方法创建了新房屋的引用，然后祝福称为类。换句话说，它创建了
<em>House</em> 类的一个实例。</p>
<p class="sb-indenthangingN"><strong>3.</strong>
现在开始创建实例方法，从而为房屋对象设置属性或者读取属性。</p>
<p class="sb-indenthangingN"><strong>4.</strong>
这里定义的是一个读取方法，用于从房屋对象获取数据。</p>
<p class="sb-indenthangingN"><strong>5.</strong>
现在用户可以开始创建访问对象的实例了。方法是通过
<em>new()</em>
这个构造器方法。第一个参数其实是箭头左边的类名。返回的是一个“祝福”过的房屋对象，被存放到
<em>$house1</em> 变量中。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里又创建了另一个房屋对象
<em>$house2</em>，返回的同样是它的引用。</p>
<p class="sb-indenthangingN"><strong>7.</strong>
一旦我们得到了对象的实例，就可以通过引用定位并为它赋值了。这里的实例方法
<em>set_owner()</em> 默认会收到 <em>$house2</em>
作为第一个参数，也就是箭头左边的变量。这里 Perl
会正确的定位到第二所房子，并且设置它的主人，也就是第二个参数中的
<em>Mr. T</em>。从而覆盖构造器默认填充的属性值 <em>Planet
Bank</em>。</p>
<p class="sb-indenthangingN"><strong>8.</strong>
现在我们会从第一所房子里读取它的主人信息，通过的是
<em>get_owner()</em> 方法。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 这里用 <em>Data::Dumper</em>
函数来显示两所房子的数据。（其实你可以把打印出来的东西存到一个文件里面去，用来重新构造两个对象。）如果你在打印之前设置
<em>$Data::Dumper::Terse=1</em> 的话，输出的 <em>$VAR1</em> 和
<em>$VAR2</em>
变量名就会省去。想要了解更多对象序列化的专题知识的话，请参考
<em><a
href="http://perl.find-info.ru/perl/025/advperl2-chp-4-sect-2.html">http://perl.find-info.ru/perl/025/advperl2-chp-4-sect-2.html</a></em>。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec8">14.2.5 创建一个面向对象模块</h4>
<p class="noindent">在上一个例子中，所有的代码都是都堆放在了一个单独的包文件中。现在是时候来创建一个模块了。</p>
</div>
<p class="indent"><a href="ch14.html#ch14fig04">图
14.4</a>展示了一个简单的面向对象模块的结构，以及用户接口。这里，包装在
<em>.pm</em>
文件里面的是一个模块的定义。文件中的包将被称为是<em>类</em>，也就是
<em>House</em>
类。一般来说，类名要和模块文件名相对应，也就是去掉
<em>.pm</em>
这个附属名的结果。类定义中的子程序，现在叫做
<em>methods</em>
方法，之前的例子中就是这样的。这里定义的第一个方法名叫
<em>new</em>，是一个构造器方法。它的作用是定义并创建对象。用户调用这个模块的这个方法，就可以获得一个新的
<em>House</em>
对象实例。而其他的实例方法则负责存取对象数据。并且只能在拥有对象实例引用的时候，才能调用实例方法。</p>
<div class="fig-heading">
<div class="box">
<hr/>
<p class="noindent"><a id="ch14fig04"/>模块文件，名为 <em>House.pm</em></p>
<hr/>
<p class="codelink"><a id="p465pro01" href="ch14_images.html#p465pro01a">Click here to view code
image</a></p>
<p class="pre1"><span class="EmpStrong">package House</span>;&#160;&#160;# <span
class="EmpItalic">House is the class</span><br/># <span class="EmpItalic">The package name normally matches the filename
minus the .pm extension</span><br/>sub
new{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Constructor method</span><br/>&#160;&#160;&#160;my $class =
shift;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">First argument is the name of the class</span><br/>&#160;&#160;&#160;my $house_obj = {
};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Create the reference/pointer.</span><br/>&#160;&#160;&#160;bless($house_obj, $class);&#160;&#160;&#160;# <span
class="EmpItalic">Bless the referent; Create an object</span><br/>&#160;&#160;&#160;return
$house_obj;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Return a reference to the object</span><br/>}<br/><br/>sub
set_owner{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Access/instance method</span><br/>&#160;&#160;&#160;my $self =
shift;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">First argument is a reference to the object</span><br/>&#160;&#160;&#160;$self-&gt;{"Owner"}=shift;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Sometimes called a "setter" method</span><br/>}<br/>sub
get_owner{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Access/instance method</span><br/>&#160;&#160;&#160;my $self =
shift;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">First argument is a reference to the object</span><br/>&#160;&#160;&#160;return $self-&gt;{"Owner"};&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Sometimes called a "getter" method</span><br/>}<br/><span class="EmpStrong">1</span>;&#160;&#160;# <span class="EmpItalic">Must
return a true value, or module won't load</span></p>
<hr/>
<p class="noindent">The user of the Class; the Perl script, <em>myHouse.plx</em></p>
<hr/>
<p class="codelink"><a id="p465pro02" href="ch14_images.html#p465pro02a">Click here to view code
image</a></p>
<p class="pre1"><span class="EmpStrong">use House;</span>&#160;&#160;# <span
class="EmpItalic">Tell Perl to load House.pm</span><br/><br/>my $house1 = House-&gt;new();&#160;&#160;&#160;# <span
class="EmpItalic">Call class constructor.</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Get back a reference to a new house. Perl
sends</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">the name of the class as its first argument</span><br/>my $house2 = House-&gt;new();&#160;&#160;&#160;# <span
class="EmpItalic">Create another house object</span><br/><br/>$house1-&gt;set_owner("B of A"); # <span class="EmpItalic">Call access
method;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Perl sends the address of the first house</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">object, to method set_owner()</span><br/><br/>print "The owner of the first house is ", $house1-&gt;get_owner, "\n";<br/>&#160;&#160;&#160;&#160;# <span class="EmpItalic">Perl gets the object's
data with the get_owner access method</span></p>
<hr/></div>
</div>
<p class="fig-caption"><strong>图 14.4</strong> 一个简单的面向对象模块。</p>
<p class="indent">请注意：还记得我们在<a href="ch13.html#ch13">第 13 章
模块、封包和发布！</a>部分提醒大家的么？这里的类定义也许多在结尾部分返回真值，也就是用
<em>1;</em> 作为结尾。</p>
<p class="indent"><a id="page_465"/>模块的用户代码需要使用 <em>use Module</em>
语句来载入模块，这个在<a href="ch13.html#ch13">第 13
章</a>中也有提到。</p>
<p class="indent">这个模块可以有很多的实现方法，这里只是其中一种比较简单的。</p>
<div class="heading">
<h5 id="ch14lev3sec11"><a id="page_466"/>给方法传递参数</h5>
<p class="noindent">实例变量是用来初始化新创建的对象的。这样，每当创建对象的时候，就可以对它进行定制。另外，也可以通过构造函数的参数来对实例变量进行设置。这个变量叫做<strong>实例变量</strong>，这是因为它们的创建是在对象实例得到创建时。有时候我们使用匿名哈希，或者匿名数组来存放实例变量。下面的例子中的对象有的是房主和价格属性变量。</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa05"/>例 14.5</p>
<p class="codelink1"><a id="p14exa05" href="ch14_images.html#p14exa05a">Click here to view code
image</a></p>
<p class="pre1">(The Module: <span class="EmpItalic">House.pm</span>)<br/>1&#160;&#160;<span class="EmpStrong">package House;</span><br/>2&#160;&#160;<span class="EmpStrong">sub
new</span>{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Constructor&#160;&#160;method</span><br/>3&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $class =
shift;</span><br/>4&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my ($owner,
$price)</span> = @_;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Instance variables</span><br/>5&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
$ref={"Owner"=&gt;$owner,</span>&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Instance variables to</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"Price"=&gt;$price,</span>&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">initialize the object</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;};<br/>6&#160;&#160;&#160;&#160;&#160;bless($ref, $class);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return $ref;<br/>&#160;&#160;&#160;}<br/>7&#160;&#160;<span class="EmpStrong">sub display_object</span>
{&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">An instance
method</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $self =
shift;</span>&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">A
reference to the object is received</span><br/>8&#160;&#160;&#160;&#160;&#160;foreach $key (keys <span
class="EmpStrong">%$self</span>){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "$key:
$self-&gt;{$key}
\n";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;<br/><br/>-------------------------------------------------------------------<br/><br/>(The Script)<br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">User of the class; another
program</span><br/>9&#160;&#160;<span class="EmpStrong">use House</span>;<br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">my $house1 = new House("Tom
Savage", 250000);</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">Invoking constructor--two
ways.</span><br/>10 <span class="EmpStrong">my $house1 = House-&gt;new("Tom Savage",
250000);</span><br/>11 <span class="EmpStrong">my $house2 = House-&gt;new("Devin Quigley",
55000);</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">Two objects have been
created</span><br/>12 <span class="EmpStrong">$house1-&gt;display_object();</span><br/>13 <span class="EmpStrong">$house2-&gt;display_object();</span><br/>14 print "$house1, $house2\n";<br/><br/>(Output)<br/>12 <span class="EmpItalic">Owner: Tom Savage</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Price: 250000</span><br/>13 <span class="EmpItalic">Owner: Devin Quigley</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Price: 55000</span><br/>14 <span class="EmpItalic">House=HASH(0x9d450), House=HASH(0xa454c)</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里声明的是 <em>House</em>
这个包。（目前，代码中尚未包含任何关于如何使用这个类的信息。关于类的调用方法的文档叫做公共接口。参考<a
href="ch14.html#ch14lev1sec5">14.5
节“古老文档，给模块建档”</a>来了解如何用  Perl
的风格来给模块书写档案。）</p>
<p class="sb-indenthangingN"><strong>2.</strong> 类方法 <em>new</em> 被定义成构造器。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 类方法的第一个参数是类名（或包名）。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 使用 @_
数组的其余参数来构造所谓“实例变量”。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 给引用 <em>$ref</em>
赋值一个匿名哈希的地址。其中的键名是固定的，而键值则来自实例变量。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 引用 <em>$ref</em>
指向的内存被“祝福”成了一个类的对象。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 引用 <em>$ref</em>
会被返回，作为方法调用的结果。下面的
<em>display_object</em>
子程序是一个实例方法。也在类中定义。</p>
<p class="sb-indenthangingNP">实例方法的第一个参数是对象引用。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 这里的 <em>foreach</em> 循环是要对 <em>keys</em>
函数返回的所有哈希（通过 <em>$self</em>
找到的）键进行处理，而实际完成的工作就是打印键值对。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 这里 <em>House.pm</em>
被类的用户代码载入名空间。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 这里调用 <em>new</em>
方法的时候带上了三个参数：<em>House</em>、<em>Tom Savage</em>
和
<em>250000</em>。第一个参数是类名（没有显式发送，而是由
Perl
自动发送的）。剩下的两个参数才是用户显式发送的。这里对参数次序的要求就是：第一个发送的必须是
<em>Owner</em> 值，第二个是 <em>Price</em>
的值。这里没有输入错误的检查代码，因为这个例子只是要展示如何向构造器发送参数。最后，构造器返回的对象引用被赋值到
<em>$house1</em> 变量中。</p>
<p class="sb-indenthangingN1"><strong>11.</strong> 这里再次调用 <em>new</em>
方法来创建对象，参数是不同的：<em>Devin Quigley</em> 和
<em>55000</em>。这个对象被赋值到 <em>$house2</em>
中。你可以如此这样，反复调用 <em>new</em>
方法来创建多个对象。如同第十四行所示，每个对象会拥有不同的地址。而且，因为构造器中的“祝福”，Perl
知道这些对象都是属于 <em>House</em> 类的。</p>
<p class="sb-indenthangingN1"><strong>12.</strong> 这里调用实例方法来打印 <em>$house1</em>
对象的数据。</p>
<p class="sb-indenthangingN1"><strong>13.</strong> 这里再次调用同一个方法，不过打印的是
<em>$house2</em> 对象的数据。</p>
<p class="sb-indenthangingN1"><strong>14.</strong>
这里打印了两个对象的地址。这里能看到，两个地址都打上了
<em>House</em> 类的标签。</p>
<hr/></div>
<div class="heading">
<h5 id="ch14lev3sec12">向实例方法发送参数</h5>
<p class="noindent">实例方法的第一个参数总是对象引用。在被调用的代码中，这个值通常是从
<em>@_</em> 数组中 shift 出来，然后存在一个名叫 <em>$self</em>
或者 <em>$this</em>
的变量中（变量名可以随意选择）。这样，剩下的参数处理起来就和正常的子程序没什么区别了。</p>
</div>
<p class="indent"><a
id="page_468"/>下面的例子展示了带有多个参数的实例方法的调用方法。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa06"/>例 14.6</p>
<p class="codelink1"><a id="p14exa06" href="ch14_images.html#p14exa06a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;#!/bin/perl<br/>&#160;&#160;&#160;# <span class="EmpItalic">Program to demonstrate passing
arguments to an instance method.</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">In this example, a pointer to an
array is passed.</span><br/>1&#160;&#160;package House;&#160;&#160;# <span
class="EmpItalic">Class</span><br/>&#160;&#160;&#160;use warnings;<br/>2&#160;&#160;sub new{&#160;&#160;&#160;# <span
class="EmpItalic">Constructor</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $ref={};&#160;&#160;<span
class="EmpItalic"># Define properties later</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;return bless ($ref, $class);<br/>&#160;&#160;&#160;}<br/><br/>3&#160;&#160;<span class="EmpStrong">sub set_props</span>{&#160;&#160;#
<span class="EmpItalic">Instance methods</span><br/>4&#160;&#160;&#160;&#160;&#160;my $object = shift;&#160;&#160;# <span
class="EmpItalic">Pointer to object</span><br/>5&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
$val_ptr=shift;</span>&#160;&#160;&#160;# <span class="EmpItalic">Receive
another pointer</span><br/>6&#160;&#160;&#160;&#160;&#160;my <span
class="EmpStrong">($owner,$price,$style)=@{$val_ptr};</span>&#160;&#160;#
<span class="EmpItalic">Create a slice</span><br/>7&#160;&#160;&#160;&#160;&#160;$object-&gt;{"Owner"}=$owner;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$object-&gt;{"Price"}=$price;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$object-&gt;{"Style"}=$style<br/>&#160;&#160;&#160;}<br/>8&#160;&#160;sub get_owner{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $self-&gt;{"Owner"};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;sub get_price{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $self-&gt;{"Price"};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;sub get_address{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $self-&gt;{"Address"};<br/>&#160;&#160;&#160;}<br/><br/>9&#160;&#160;sub display_props{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>10&#160;&#160;&#160;&#160;print "Properties for the ",<span
class="EmpStrong">ref($self)</span>, " are:\n";<br/>11&#160;&#160;&#160;&#160;foreach $key (<span class="EmpStrong">keys
%{$self}</span>){&#160;&#160;# <span class="EmpItalic">Dereference hash
ref</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf
"%-10s%-10s\n",$key,$value;2<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;&#160;&#160;# <span class="EmpItalic">Don't forget
this!</span><br/>--------------------------------------------------------------------<br/><br/>(The Script)<br/>12 use House;<br/>&#160;&#160;&#160;use warnings;<br/>&#160;&#160;&#160;use strict;<br/><a id="page_469"/>13 my $h1=House-&gt;new();<br/>14 $h1-&gt;set_props([ "Unity Bank", "150000", "12 Main St."]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Pass reference</span><br/>&#160;&#160;&#160;$h1-&gt;display_props();<br/><br/>&#160;&#160;&#160;my $h2=House-&gt;new();<br/>15 $h2-&gt;set_props([ "Pierre Dupont", "150000","Pacific Ridge" ]);<br/>&#160;&#160;&#160;$h2-&gt;display_props();<br/><br/>(Output)<br/><span class="EmpItalic">Owner&#160;&#160;&#160;&#160;&#160;Unity Bank</span><br/><span class="EmpItalic">Address&#160;&#160;&#160;12 Main St.</span><br/><span class="EmpItalic">Price&#160;&#160;&#160;&#160;&#160;150000</span><br/><span class="EmpItalic">Owner&#160;&#160;&#160;&#160;&#160;Pierre
Dupont</span><br/><span class="EmpItalic">Address&#160;&#160;&#160;10 Pacific Ridge</span><br/><span class="EmpItalic">Price&#160;&#160;&#160;&#160;&#160;1500000</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 声明 <em>House</em> 类。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这个 <em>new</em>
方法是构造器。对象来自于一个空的匿名哈希。哈希的键值对，也就是对象的<strong>属性</strong>会稍后赋值。这个
<em>$ref</em> 引用指向的对象，被祝福成属于 <em>House</em>
类。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里定义的是实例方法 <em>set_props</em>。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 第一个参数是对 <em>House</em>
对象的引用。这个参数从 @_ 数组 shift 出来之后赋值给
<em>$object</em>。其实这个变量名可以是 <em>$this</em> 或者
<em>$self</em>，都可以。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 第二个参数也从 <em>@_</em> 中 shift
出来，这次是一个数组引用。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里把 <em>$val_ptr</em>
解引用成一个列表，从而获取传入的数据。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 现在把传入的数据赋值到对象里面。</p>
<p class="sb-indenthangingN"><strong>8.</strong>
这里定义的都是从对象中读取数据的实例方法。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 这里打印哈希中的所有属性的值。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 这里调用内建函数
<em>ref</em>，对于输入的对象引用来说，会返回对应的类名。</p>
<p class="sb-indenthangingN1"><strong>11.</strong>
因为对象实际上是一个哈希引用，所以我们可以用
<em>%$self</em>
来解引用，获得键值对。下面，模块的用户代码就把这个模块载入代码中。</p>
<p class="sb-indenthangingN1"><strong>13.</strong> 对于构造器 <em>new()</em>
的调用返回一个新的、祝福过的房子。</p>
<p class="sb-indenthangingN1"><strong>14.</strong> 这里通过 <em>set_props()</em>
实例方法来设置属性的值。第一个隐含的参数是对象引用（箭头操作符左边的东西）。第二个参数是一个匿名数组的引用（在方括号里面的东西），其中的元素会用来设置对象的属性。</p>
<p class="sb-indenthangingN1"><strong>15.</strong> 同样通过 <em>set_props()</em>
这个实例方法来为第二个对象属性赋值。</p>
<hr/></div>
<div class="heading">
<h5 id="ch14lev3sec13"><a id="page_470"/>命名参数和数据检查</h5>
<p class="noindent">目前所有的例子都是关于 <em>House</em>
对象的。下面的例子中，我们会创建一个 <em>Employee</em>
对象。它的构造器会使用参数来设置员工的属性。如果构造器规定了名字、地址和工资的输入顺序，那么参数的顺序出错就会带来没必须要的麻烦：地址成了名字、或者名字成了工资，等等。要避免这样的麻烦，其中一个方法就是用哈希来传递参数。这样的键值对形式就会比较容易一些（当然，拼写错误也会带来其他的问题）。下面的例子展示了如何使用命名参数。</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa07"/>例 14.7</p>
<p class="codelink1"><a id="p14exa07" href="ch14_images.html#p14exa07a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;# <span class="EmpItalic">User of Employee.pm--See Example
14.8 for module</span><br/>1&#160;&#160;<span class="EmpStrong">use Employee;</span><br/>2&#160;&#160;use warnings;<br/>&#160;&#160;&#160;use strict;<br/>3&#160;&#160;my($name, $extension, $address, $basepay, $employee); # <span
class="EmpItalic">Declare</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">my variables</span><br/>4&#160;&#160;print "Enter the employee's name. ";<br/>&#160;&#160;&#160;chomp($name=&lt;STDIN&gt;);<br/>&#160;&#160;&#160;print "Enter the employee's phone extension. ";<br/>&#160;&#160;&#160;chomp($extension=&lt;STDIN&gt;);<br/>&#160;&#160;&#160;print "Enter the employee's address. ";<br/>&#160;&#160;&#160;chomp($address=&lt;STDIN&gt;);<br/>&#160;&#160;&#160;print "Enter the employee's basepay. ";<br/>&#160;&#160;&#160;chomp($basepay=&lt;STDIN&gt;);<br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">Passing arguments as a
hash</span><br/>5&#160;&#160;<span class="EmpStrong">$employee = Employee-&gt;new(</span>
"_<span class="EmpStrong">Name</span>"<span
class="EmpStrong">=&gt;$name,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">Address</span>"<span
class="EmpStrong">=&gt;$address,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">Extension</span>"<span
class="EmpStrong">=&gt;$extension,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">PayCheck</span>"<span
class="EmpStrong">=&gt;$basepay,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">);</span><br/>&#160;&#160;&#160;print "\nThe statistics for $name are: \n";<br/><br/>6&#160;&#160;$employee-&gt;get_stats;<br/><br/>(Output)<br/><span class="EmpItalic">Enter the employee's name. Daniel Savage</span><br/><span class="EmpItalic">Enter the employee's phone extension. 2534</span><br/><span class="EmpItalic">Enter the employee's address. 999 Mission Ave,
Somewhere, CA</span><br/><span class="EmpItalic">Enter the employee's basepay. 2200</span><br/><br/><span class="EmpItalic">The statistics for Daniel Savage are:</span><br/><span class="EmpItalic">Address = 999 Mission Ave, Somewhere, CA</span><br/><span class="EmpItalic">PayCheck = 2200</span><br/><span class="EmpItalic">IdNum = Employee Id not provided!</span><br/><span class="EmpItalic">Extension = 2534</span><br/><span class="EmpItalic">Name = Daniel Savage</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_471"/>注释</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这个程序会用到 <em>Employee.pm</em> 模块。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 为了避免可能的错误，用到了
<em>warnings</em>。而 <em>strict</em>
的使用则是为了跟踪全局变量，以及未定义的变量的意外使用，还有裸字等等。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 创建了一系列的词法私有变量。</p>
<p class="sb-indenthangingN"><strong>4.</strong>
运行此程序的时候，用户会被提示输入一些信息，然后传递给
<em>Employee</em> 模块。</p>
<p class="sb-indenthangingN"><strong>5.</strong>
调用构造器的时候发送给它的参数是键值对。也就是说发送给
<em>Employee</em>
的构造器的是一个哈希。结果是返回了一个对象引用，并赋值到
<em>$employee</em>。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 调用实例方法 <em>get_stats</em>
来打印员工的属性。</p>
<hr/></div>
<p class="indent">下面的例子则显示了模块是如果处理命名参数的。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa08"/>例 14.8</p>
<p class="codelink1"><a id="p14exa08" href="ch14_images.html#p14exa08a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;# <span class="EmpItalic">Module Employee.pm--See Example
14.7 to use this module.</span><br/>1&#160;&#160;<span class="EmpStrong">package Employee;</span><br/>2&#160;&#160;use Carp;<br/>3&#160;&#160;<span class="EmpStrong">sub new</span> {<br/>4&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>5&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">my(%params)=@_;</span>&#160;&#160;&#160;# <span
class="EmpItalic">Receiving the hash that was passed</span><br/>6&#160;&#160;&#160;&#160;&#160;my $ref={<br/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">Name</span>"<span
class="EmpStrong">=&gt;$params{</span>"_<span
class="EmpStrong">Name</span>"<span class="EmpStrong">}</span> || croak("No
name assigned"),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">Extension</span>"<span
class="EmpStrong">=&gt;$params{</span>"_<span
class="EmpStrong">Extension</span>"<span class="EmpStrong">}</span>,<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">Address</span>"<span
class="EmpStrong">=&gt;$params{</span>"_<span
class="EmpStrong">Address</span>"<span class="EmpStrong">}</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">PayCheck</span>"<span
class="EmpStrong">=&gt;$params{</span>"_<span
class="EmpStrong">PayCheck</span>"} ||<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;croak("No pay
assigned"),<br/>9&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">((defined
$params{"_IdNum"})?("_IdNum"=&gt;$params{"_IdNum"}):</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">croak "Employee's id was not provided!\n"</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">);</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;};<br/>10 return bless($ref,$class);<br/>&#160;&#160;&#160;}<br/>11 <span class="EmpStrong">sub get_stats</span>{<br/>12&#160;&#160;&#160;&#160;my $self=shift;<br/>13&#160;&#160;&#160;&#160;foreach my $key <span class="EmpStrong">(keys
%params, %$self)</span>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print $key, " = ",
$self-&gt;{$key}, "\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_472"/>Explanation</p>
<p class="sb-indenthangingN"><strong>1.</strong> The class <em>Employee</em> is declared.</p>
<p class="sb-indenthangingN"><strong>2.</strong> 标准 Perl 库中输出的 <em>Carp</em>
模块可以辅助对错误信息进行打印。所以，这里我们没有用内建的
<em>die</em> 函数，而是使用 <em>Carp</em> 模块提供的
<em>croak</em>
方法来捕获错误并退出，同时打印错误的详细信息。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里定义了构造器方法 <em>new</em>。</p>
<p class="sb-indenthangingN"><strong>4.</strong>
构造器方法的第一个参数是类名。这里我们把它从
<em>@_</em> 数组 shift 出来，并赋值给 <em>$class</em>。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里把 <em>@_</em> 数组剩余的参数赋值给
<em>%params</em>
这个哈希。而它们是通过键值对的顺序发送给构造器的。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里把一个匿名哈希的引用赋值到
<em>$ref</em> 中去。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里的键 <em>Name</em>
被赋予一个值，而值的来源是 <em>%params</em>
哈希。所以，有必要进行错误检查。如果 <em>Name</em>
键没有对应的值，<em>croak</em>
函数就会被调用并退出，从而使用户知道因为 <em>Name</em>
键没有对应的值而导致程序退出。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 同样的方法从 <em>%params</em> 哈希中拷贝得
<em>Address</em> 属性的值。</p>
<p class="sb-indenthangingN"><strong>9.</strong>
这个例子展示了如何检查用户向模块输入的参数。这里的条件赋值语句可以这样读：如果
<em>%params</em> 中有个名为 <em>IdNum</em>
的键有定义的值，那么将这个值赋值给
<em>IdNum</em>；否则就提示用户忘记了输入这个参数。前面的例子中使用了
<em>croak</em>
函数，会因为参数为空导致程序退出。而这里因为采用了不同的检查方法，就可以让程序继续运行下去。</p>
<p class="sb-indenthangingN1"><strong>10.</strong>
在属性赋值之后，对象引用被祝福成类的成员，并返回给调用者。</p>
<p class="sb-indenthangingN1"><strong>11.</strong> 这里定义了实例方法 <em>get_stats</em>。</p>
<p class="sb-indenthangingN1"><strong>12.</strong> 第一个参数从 <em>@_</em> 数组中 shift
出来，并赋值给 <em>$self</em>。这是一个对象的引用。</p>
<p class="sb-indenthangingN1"><strong>13.</strong> 这里进入了 <em>foreach</em>
循环。调用了内置的 <em>keys</em>
函数来获取对象的所有键。下一行打印所有的键和对应的值。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec9">14.2.6 多态和运行时绑定</h4>
<p class="noindent"><em>韦氏字典</em>把多态定义为：</p>
</div>
<p class="blockquote">多态：<em>名词</em> 呈现多种形状的状态或条件。<sup><a
id="ch14fn5a" href="ch14.html#ch14fn5">5</a></sup></p>
<p class="footnote"><a id="ch14fn5" href="ch14.html#ch14fn5a">5</a>. <em>Webster&#8217;s
Encyclopedic Unabridged Dictionary of the English Language</em>, Random
House Value Publishing: Avenel, NJ, 1996, p. 1500.</p>
<p class="noindent">哦，这等于是说 1+1=2！下面的定义来自 Webopedia.com：</p>
<p class="blockquote">也就是说，呈现多种形式的能力。对于面向对象编程来说，多态意味着编程语言有能力对不同的对象（按照数据类型或类的不同而）执行不同的逻辑的能力。</p>
<p class="indent"><a
id="page_473">多态也可以换成其他的专业词汇来描述，而且不论哪种面向对象的术语都绕不开这个概念。中心思想就是同样的方法名可以对应不同的处理逻辑。换句话说，你可以给多个类定义同样名字的方法，而调用的时候不会搞混了。也就是说，只要对象引用正确的话，相应的类总是能找到正确的方法来调用。</p>
<p class="indent">现在让我们进入下一个例子。这次我们来看三个模块：<em>BasketballPlayer.pm</em>、<em>Director.pm</em>
和 <em>Rifleman.pm</em>。这些模块都有一个叫做 <em>shoot()</em>
的方法。而调用模块的代码会载入这三个模块。在它们的构造器得到调用的时候，会返回相应的祝福过的对象引用。当实例方法被调用的时候，因为
Perl 会发送对象引用作为方法的第一个参数，所以 Perl
明白对象属于哪个类，也知道要调用的方法是哪个（哪怕方法的名字完全一样）。Perl
能够查找到对象所属的类（也就是包）中正确的方法来调用，这个能力就是所谓的多态。</p>
<p class="indent">当你调用函数或者方法的时候，调用必须关联到（或者说绑定）函数或方法的定义代码。这会发生在编译时或者运行时。运行时绑定，它能允许程序推后方法的判定，直到程序运行起来以后。也就是说，一旦程序知道调用方法的对象是什么，它就能正确绑定。通过多态和运行时绑定，程序就可以在不使用
<em>if</em>
语句的情况下正确调用（所属类的）方法。这使得继承机制能够非常灵活的实施。</p>
<p class="indent">要想使用多态和运行时绑定的特性，就必须通过面向对象语法来调用，而不能使用
<em>::</em> 语法。假设你有两个类：<em>Director</em> 和
<em>Rifleman</em>。而这两个类都有一个实例方法叫做
<em>shoot</em>。只要你书写 <em>$object</em>-<em>&gt;shoot()</em>
这样的代码，Perl 就能了解到对象所属的类，因为
<em>shoot()</em>
的第一个参数永远都是对象引用（是在构造器中用“祝福”的方法打上编译时的类标签的）。这样就可以放心，<em>Director</em>
不会在开机时射出子弹，而 <em>Rifleman</em>
也不会用摄像机瞄准猎物。当然，你也可以增加更多的类，比如
<em>BasketballPlayer</em>，也带有一个 <em>shoot()</em>
方法。并且，这时候所有的机制仍然可以正常工作。倘若没有运行时绑定和多态，就只能（像下面的例子一样）通过许多条件语句来找到正确的方法调用了：</p>
<p class="codelink"><a id="p473pro01" href="ch14_images.html#p473pro01a">Click here to view code
image</a></p>
<p class="pre">if ( ref($object1) eq "Director") {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;Director::shoot($object1);<br/>elsif ( ref($object2) eq "Rifleman" ){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rifleman::shoot($object2);<br/>else{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;BasketballPlayer::shoot($object3);<br/>}</p>
<p class="noindent">只是，万一你调用 <em>shoot()</em>
的时候发送了错误的对象参数呢？使用面向对象语法的时候就不必担心这点，因为对象引用是自动发送的。所以，就是通过这种类似于潜意识的对象参数发送，以及在祝福时候进行类标记，Perl
就能够实现多态调用机制。如同下面的例子所示，我们用
<em>Director</em> 类来创建 <em>$object1</em>，用 <em>Rifleman</em>
类来创建 <em>$object2</em>，而 <em>$object3</em> 则是用
<em>BasketballPlayer</em> 类创建的。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa09"/>例 14.9</p>
<p class="codelink1"><a id="p14exa09" href="ch14_images.html#p14exa09a">Click here to view code
image</a></p>
<p class="pre1">$object1-&gt;shoot;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">evaluates to</span>&#160;&#160;Director::shoot($object1);<br/>$object2-&gt;shoot;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">evaluates to</span>&#160;&#160;Rifleman::shoot($object2);<br/>$object3-&gt;shoot;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">evaluates
to</span>&#160;&#160;BasketballPlayer::shoot($object3);</p>
<hr/></div>
<p class="indent">下面的例子就是用来说明多态的。下面的三个类，都有各自的构造器（并不是同样的方法名），而
<em>shoot()</em> 这个方法则是三个类共同拥有的。</p>
<p class="indent">用户代码会载入所有三个模块并且创建每个类的实例。每当
<em>shoot()</em> 方法被调用的时候，Perl
总会默默发送对象引用参数。因为 <em>shoot()</em>
会收到祝福过的对象引用，就不会弄错该调用的代码。Perl
能正确定位到所属类当中的方法代码，并运行。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa10"/>例 14.10</p>
<p class="codelink1"><a id="p14exa10" href="ch14_images.html#p14exa10a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;#----------File: BasketballPlayer.pm<br/>1&#160;&#160;<span class="EmpStrong">package
BasketballPlayer;</span>&#160;&#160;# <span class="EmpItalic">Class</span><br/>&#160;&#160;&#160;sub new{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($name, $team, $position)=@_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $player={<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Name"=&gt;$name,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Team"=&gt;$team,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Position"=&gt;$position,<br/>&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;&#160;&#160;return bless($player, $class);<br/>&#160;&#160;&#160;}<br/>2&#160;&#160;<span class="EmpStrong">sub shoot</span> {&#160;&#160;# <span
class="EmpItalic">Instance method for the basketball player</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "$self-&gt;{'Name'} was a
$self-&gt;{'Position'}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;and shot baskets
for the $self-&gt;{Team}.\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;<br/>&#160;&#160;&#160;#----------------File: Director.pm<br/>3&#160;&#160;<span class="EmpStrong">package Director;</span>&#160;&#160;#
<span class="EmpItalic">Class</span><br/>&#160;&#160;&#160;sub new{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $info_ptr=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $director={<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Name"=&gt;$info_ptr-&gt;{"Name"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Movie"=&gt;$info_ptr-&gt;{"Movie"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Type"=&gt;$info_ptr-&gt;{"Type"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;};&#160;&#160;&#160;&#160;&#160;&#160;return
bless($director, $class);<br/>&#160;&#160;&#160;}<br/><a id="page_475"/>4&#160;&#160;<span class="EmpStrong">sub
shoot</span>{&#160;&#160;# <span class="EmpItalic">Instance method for the
director</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "$self-&gt;{'Name'} is shooting
the movie $self-&gt;{'Movie'}.\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;<br/>&#160;&#160;&#160;#----------------File: Rifleman.pm<br/>5&#160;&#160;<span class="EmpStrong">package Rifleman;</span>&#160;&#160;#
<span class="EmpItalic">Class</span><br/>&#160;&#160;&#160;sub init{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($name, $shooting_range)=@_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $rifleman={<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Name"=&gt;$name,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Range"=&gt;$shooting_range,<br/>&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;&#160;&#160;return bless($rifleman, $class);<br/>&#160;&#160;&#160;}<br/>6&#160;&#160;<span class="EmpStrong">sub shoot</span>{&#160;&#160;# <span
class="EmpItalic">Instance method for the rifleman</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "$self-&gt;{'Name'} went to the
$self-&gt;{'Range'} range to shoot<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;target&#160;&#160;&#160;&#160;s.\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;<br/>&#160;&#160;&#160;-------------------File: user.plx-------------------------<br/>7&#160;&#160;<span class="EmpStrong">use BasketballPlayer;</span><br/>&#160;&#160;&#160;<span class="EmpStrong">use Director;</span><br/>&#160;&#160;&#160;<span class="EmpStrong">use Rifleman;</span><br/>&#160;&#160;&#160;use feature qw(say);<br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">Create instances of each
class</span><br/>8&#160;&#160;<span
class="EmpStrong">$ballplayer</span>=BasketballPlayer-&gt;new("Wilt
Chamberlain",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Boston
Globe Trotters",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"center");<br/>9&#160;&#160;<span
class="EmpStrong">$movie_director</span>=Director-&gt;new(
{"Name"=&gt;"Steve McQueen",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Movie"=&gt;"12
Years A Slave",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Type"=&gt;"Historical
Drama"}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>10 <span class="EmpStrong">$gunman</span>=Rifleman-&gt;init("Lucas McCain",
"North Fork Range");<br/>11 say "The basketball player is a ", <span class="EmpStrong">ref
$ballplayer</span>;<br/>12 say "The director is a ", <span class="EmpStrong">ref
$movie_director</span>;<br/>13 say "The rifleman is a ", <span class="EmpStrong">ref $gunman</span>;<br/>14 <span class="EmpStrong">$ballplayer-&gt;shoot();&#160;&#160;#</span>
<span class="EmpItalic">polymorphism</span><br/>15 <span class="EmpStrong">$movie_director-&gt;shoot();</span><br/>16 <span class="EmpStrong">$gunman-&gt;shoot();</span><br/><br/>(Output)<br/>11 <span class="EmpItalic">The basketball player is a
BasketballPlayer</span><br/>12 <span class="EmpItalic">The director is a Director</span><br/>13 <span class="EmpItalic">The rifleman is a Rifleman</span><br/>14 <span class="EmpItalic">Wilt Chamberlain was a center and shot baskets
for the Boston Globe</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Trotters.</span><br/>15 <span class="EmpItalic">Steve McQueen is shooting the movie 12 Years A
Slave.</span><br/>16 <span class="EmpItalic">Lucas McCain went to the North Fork Range range
to shoot targets.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_476"/>代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这是 <em>BasketballPlayer</em>
类，带有构造器和实例变量。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这是 <em>BasketballPlayer</em> 类的 <em>shoot()</em>
实例方法。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 现在进入 <em>Director</em> 类，也带有名为
<em>new()</em> 的构造器和实例变量。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这是 <em>Director</em> 类的 <em>shoot()</em>
实例方法。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 现在进入 <em>Rifleman</em> 类，带有名为
<em>init()</em> 的构造器和实例变量。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这是 <em>Rifleman</em> 类的 <em>shoot()</em>
实例方法。</p>
<p class="sb-indenthangingN"><strong>7.</strong>
用户程序首先载入三个类：<em>BasketballPlayer</em>、<em>Director</em>
和 <em>Rifleman</em>。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 调用 <em>BasketballPlayer</em> 的构造器来获得
<em>BasketballPlayer</em> 类新实例的引用。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 调用 <em>Director</em> 的构造器来获得
<em>Director</em> 类新实例的引用。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 调用 <em>Rifleman</em> 的构造器来获得
<em>Rifleman</em> 类新实例的引用。</p>
<p class="sb-indenthangingN1"><strong>11.</strong> Perl 内置的 <em>ref</em>
函数，调用参数是对象引用，返回的结果是类名（而不是对象变量类型）。对于未被祝福过的引用，返回的结果就是类似于
<em>HASH</em>
这样的字符串。这个例子是让你看到对象引用对应的类标签。</p>
<p class="sb-indenthangingN4"><strong>14&#8211;16.</strong>
多态通过对三个不同类型对象调用各自的 <em>shoot()</em>
方法来显明。因为 Perl
会把对象引用作为第一个参数传递，因此这里不会弄错要调用的代码。祝福过的对象引用如下所示：</p>
<p class="sb-indenthangingNP"><em>BasketballPlayer=HASH(0x7ff98a004ff0),</em></p>
<p class="sb-indenthangingNP"><em>Director=HASH(0x7ff98a033128),</em></p>
<p class="sb-indenthangingNP"><em>Rifleman=HASH(0x7ff98a02d4d8)</em></p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec10">14.2.7 析构器和垃圾回收机制</h4>
<p class="noindent">Perl
时刻跟踪着对象的引用计数，这样可以在引用计数为零是自动销毁对象。如果引用超出了代码的语法范围，Perl
就会触发垃圾收集机制，对失去引用的对象进行销毁并释放内存。所以，你不必担心内存会意外的浪费掉。<sup><a
id="ch14fn6a"
href="ch14.html#ch14fn6">6</a></sup>不过，你还是可以定义
<em>DESTROY</em> 方法来将对象的销毁进行自定义的控制。</p>
</div>
<p class="footnote"><a id="ch14fn6"
href="ch14.html#ch14fn6a">6</a>.
如果你定义了一个自引用的数据结构，那么就得自己负责数据对象的销毁。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="page_477"/><a id="ch14exa11"/>例 14.11</p>
<p class="codelink1"><a id="p14exa11" href="ch14_images.html#p14exa11a">Click here to view code
image</a></p>
<p class="pre1">(The Class)<br/>1&#160;&#160;package Employee;<br/>&#160;&#160;&#160;sub new{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $name = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $ref={"Name"=&gt;$name};<br/>&#160;&#160;&#160;&#160;&#160;&#160;bless($ref, $class);<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $ref;<br/>&#160;&#160;&#160;}<br/><br/>2&#160;&#160;<span class="EmpStrong">sub DESTROY{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $self =
shift;</span><br/>3&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">print "Employee
$self-&gt;{Name} is being destroyed.\n";</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><br/>&#160;&#160;&#160;1;<br/>&#160;&#160;&#160;---------------------------------------------------------------<br/><br/>(The Script)<br/>&#160;&#160;&#160;# <span class="EmpItalic">User of the class</span><br/>4&#160;&#160;<span class="EmpStrong">use Employee;</span><br/>5&#160;&#160;my $emp1 = Employee-&gt;new("1: Daniel");<br/>6&#160;&#160;<span class="EmpStrong">{</span> my $emp2 =
Employee-&gt;new("2: Tom");&#160;&#160;# <span class="EmpItalic">Lexical
scoping</span><br/>7&#160;&#160;&#160;&#160;print "I'm being destroyed.\n";<br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>8&#160;&#160;my $emp3 = Employee-&gt;new("3: Jenny");&#160;&#160;# <span
class="EmpItalic">Create the object</span><br/><br/>(Output)<br/>7&#160;&#160;<span class="EmpItalic">I'm being destroyed.</span><br/>6&#160;&#160;<span class="EmpItalic">Employee 2: Tom is being
destroyed.</span><br/>5&#160;&#160;<span class="EmpItalic">Employee 1: Daniel is being
destroyed.</span><br/>8&#160;&#160;<span class="EmpItalic">Employee 3: Jenny is being
destroyed.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> <em>Employee</em>
类在此得到声明，也同时定义了构造器方法。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 当 <em>Employee</em>
对象不再有存在的必要时，<em>DESTROY</em>
方法被调用，并打印这行信息。第六行的对象是定义在一个块中的。所以，当这块代码执行完毕之后，它就没有存在的必要了。而其他对象要等到整个程序退出时才消亡。</p>
<p class="sb-indenthangingN"><strong>3.</strong>
每当某个对象失去存在的意义时，这一行就被打印出来。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里载入 <em>Employee</em> 模块。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里通过构造器创建了 <em>Employee</em>
类的一个对象引用
<em>$emp1</em>，这个员工的名字是参数中的 <em>Daniel</em>。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里又在块里面创建了一个 <em>Employee</em>
对象。这个对象被赋予了一个 <em>Tom</em>
的名字。因为这个对象是用 <em>my</em>
创建的，所以只能存活在语法范围内。因此，一旦块执行完毕，这个对象就已经没必要存在了，因此会调用它的
<em>DESTROY</em> 方法，然后清理为它分配的内存。</p>
<p class="sb-indenthangingN"><a id="page_478"/><strong>7.</strong> 这一行打印的顺序在名为
<em>Tom</em> 的对象消亡之前。然后 <em>Employee</em>
对象被赋予了键值，然后就是 <em>DESTROY</em> 调用的时机。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 最后又是一个对象（名为
Jenny）被创建，也是这个程序退出之前最后销毁的对象。</p>
<hr/></div>
<div class="heading">
<h3 id="ch14lev1sec3">14.3 匿名子程序、闭包和私有数据</h3>
<p class="noindent">目前我们所有的面向对象代码中都有一个问题，那就是用户可以通过引用来随意操纵数据修改。哪怕我们告诉他们必须通过模块方法来访问对象，仍然没有什么机制能阻止他们来直接访问对象内部的数据。这是因为
Perl
并没有什么特殊的机制来保护类中的数据私有性。不过，对于那些认为无法实现私有数据就不能算面向对象语言的人来说，Perl其实是有许多种方法来做到这点的。其中一种就是使用闭包。</p>
</div>
<div class="heading">
<h4 id="ch14lev2sec11">14.3.1 什么是闭包？</h4>
<p class="noindent">Larry Wall 把闭包说成是一个有态度的匿名函数<sup><a
id="ch14fn7a" href="ch14.html#ch14fn7">7</a></sup> 。Barrie Slaymaker
则把闭包说成是“内衣外穿的对象”。因为对象其实是带有子程序的数据，而闭包则是带有数据的子程序。</p>
</div>
<p class="footnote"><a id="ch14fn7" href="ch14.html#ch14fn7a">7</a>. Perl
编程，第三版，第 262 页；O’Reilly 出版社，Sebastopol
加州，2000 年由 Larry Wall、Tom Christianson 和  Jon Orwant 合著。</p>
<p class="indent">闭包就是一个子程序，它总能保持对 <em>my</em>
变量的访问，哪怕调用的位置已经越过了变量定义所在的块范围也是如此。这个子程序似乎“贴伏”着这些词法变量，在每次调用时都能重用同一组变量。而这些词法变量也总是活跃，直到所有的引用都不再活跃为止。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa12"/>例 14.12</p>
<p class="codelink1"><a id="p14exa12" href="ch14_images.html#p14exa12a">Click here to view code
image</a></p>
<p class="pre1">(The Script)<br/>1&#160;&#160;my $name="Tommy";<br/><br/>2&#160;&#160;{&#160;&#160;my $name = "Grandfather";&#160;&#160;# <span
class="EmpItalic">Lexical variables</span><br/>3&#160;&#160;&#160;&#160;&#160;my $age = 86;<br/>4&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">$ref = sub{ return
"$name is $age.\n"; }</span>&#160;&#160;# <span class="EmpItalic">Anonymous
subroutine</span><br/>&#160;&#160;&#160;}<br/>5&#160;&#160;print "$name is back\n";<br/>6&#160;&#160;<span class="EmpStrong">print $ref-&gt;();</span>&#160;&#160;#
<span class="EmpItalic">Call to subroutine outside the block</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Could also call subroutine with this syntax:
&#38;{$ref};</span><br/><a id="page_479"/>(Output)<br/>5&#160;&#160;<span class="EmpItalic">Tommy is back.</span><br/>6&#160;&#160;<span class="EmpItalic">Grandfather is 86.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里给词法变量 <em>$name</em> 赋值
<em>Tommy</em>。这个变量的生存周期从这里延伸到程序的末尾。</p>
<p class="sb-indenthangingN"><strong>2.</strong>
程序再次进入一个块中。这里给一个新的词法变量
<em>$name</em> 赋值
<em>Grandfather</em>。这个变量直到块的结尾都是有效的。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里定义了另一个词法变量
<em>$age</em>，它也是从此直到快结尾有效。</p>
<p class="sb-indenthangingN"><strong>4.</strong>
在同一个块内又定义了一个匿名子程序，它引用了同一个块内的两个词法变量（也就是
<em>my</em> 变量：<em>$name</em> 和
<em>$age</em>）。然后把这个子程序的引用赋值给
<em>$ref</em>。这个子程序，不论在哪里调用，总是可以访问这两个变量。这个子程序就被称为闭包，因为不论怎么调用，它必然能够访问所在块内的变量。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 执行到这里，<em>$name</em> 的值又变成了
<em>Tommy</em>。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 匿名子程序通过 <em>$ref</em>
引用得到调用。词法变量看似已经超出了生存周期，但是却仍然存在。这是因为引用的存在导致变量不能被释放。只要引用尚存，Perl
就永远不能释放这些变量。</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa13"/>例 14.13</p>
<p class="codelink1"><a id="p14exa13" href="ch14_images.html#p14exa13a">Click here to view code
image</a></p>
<p class="pre1">(The Script)<br/>&#160;&#160;&#160;# <span class="EmpItalic">Closure</span><br/>1&#160;&#160;sub paint {<br/>2&#160;&#160;&#160;&#160;&#160;my $color = shift;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">@_ array is shifted</span><br/>3&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $ref = sub</span>
{&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">Pointer
to an anonymous subroutine</span><br/>4&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;my $object=shift;<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "Paint the $object
$color.\n"; # <span class="EmpItalic">$color still in scope</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;};<br/>6&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return
$ref;</span>&#160;&#160;&#160;&#160;# <span class="EmpItalic">Returns a
pointer (closure)</span><br/>&#160;&#160;&#160;}<br/><br/>7&#160;&#160;<span class="EmpStrong">my $p1</span>=paint("red"); # <span
class="EmpItalic">$p1 is a pointer to anonymous subroutine</span><br/>&#160;&#160;&#160;<span class="EmpStrong">my $p2</span>=paint("blue");<br/>8&#160;&#160;<span class="EmpStrong">$p1-&gt;("flower");</span>&#160;&#160;#
<span class="EmpItalic">Call to anonymous subroutine</span><br/>9&#160;&#160;<span class="EmpStrong">$p2-&gt;("sky");</span><br/>10 use Data::Dumper;<br/>&#160;&#160;&#160;<span class="EmpStrong">$Data::Dumper::Deparse=1;</span><br/><br/>11 print Dumper $p1, $p2;<br/><a id="page_480"/>(Output)<br/>5&#160;&#160;<span class="EmpItalic">Paint the flower red.</span><br/>5&#160;&#160;<span class="EmpItalic">Paint the sky blue.</span><br/>&#160;&#160;&#160;&#160;<span class="EmpItalic">&lt; Data::Dumper
Output&gt;</span><br/>10 <span class="EmpItalic">$VAR1 = sub {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">my $object =
shift();</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">print "Paint the
$object $color.\n";</span><br/>&#160;&#160;&#160;<span class="EmpItalic">};</span><br/>&#160;&#160;&#160;<span class="EmpItalic">$VAR2 = sub {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">my $object =
shift();</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">print "Paint the
$object $color.\n";</span><br/>&#160;&#160;&#160;<span class="EmpItalic">};</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里定义了 <em>paint()</em> 子程序。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这里从 <em>@_</em>
数组中取出值并赋予词法变量 <em>$color</em>。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里把一个匿名子程序的引用赋予
<em>$ref</em>。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这个匿名子程序从 <em>@_</em>
数组中提取一个参数出来。这里提取的值放在
<em>$object</em> 中，第一次提取出来的值是
<em>flower</em>，而第二次提取出来的是 <em>sky</em>。</p>
<p class="sb-indenthangingN"><strong>5.</strong>
这里是闭包真正开始工作的部分。因为之前的词法变量
<em>$color</em> 仍然在作用范围内，而且它会一直存在，哪怕
<em>paint()</em>
子程序调用并退出了也是一样。原因就是匿名子程序仍然需要它的存在。所以，无论何时，<em>$color</em>
都可以使用。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里的 <em>paint()</em>
子程序返回了一个对匿名子程序的引用。如果打印出来的话，引用的内容看上去是这样的：<em>(CODE(0x100804ee8))</em>。引用导致了闭包的存在，也保存了词法变量
<em>$color</em>。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里两次调用 <em>paint()</em>
子程序，并且每次参数都不同。每当 <em>paint()</em>
被调用时候，Perl 都会创建一个新的词法标量
<em>$color</em>。并且每次的值都不同。然后这个变量因为返回的引用而被闭包保护起来。所以，<em>$p1</em>
对应的闭包变量 <em>$color</em> 的值是 <em>red</em>，而
<em>$p2</em> 对应的闭包变量 <em>$color</em> 的值则是
<em>blue</em>。你可以通过在调用 <em>paint()</em> 时打印
<em>\$color</em> 来确认每个变量的地址是不同的。</p>
<p class="pre1">&#160;&#160;&#160;&#160;&#160;&#160;SCALAR(0x7f947382db80)<br/>&#160;&#160;&#160;&#160;&#160;&#160;SCALAR(0x7f947382d4c0)</p>
<p class="sb-indenthangingN"><strong>8, 9.</strong> <em>$p1</em> 和 <em>$p2</em>
其实都是指向第三行定义的匿名子程序的引用。只是因为闭包的存在，导致它们在访问
<em>paint()</em> 定义的 <em>$color</em>
变量的时候访问的是不同的版本。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 我们可以使用 <em>Data::Dumper</em>
来打印出代码引用的内容，但是如果我们不把
<em>$Data::Dumper::Deparse</em>
变量设置为一，就不能打印出匿名子程序的内容，而只能打印出
<em>DUMMY</em>。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec12"><a id="page_481"/>14.3.2 闭包和对象</h4>
<p class="noindent">闭包的作用就是让对象能够隐藏数据，从而避免用户直接存取对象的敏感数据。具体来说，就是在构造器中定义对象的数据，然后用一个匿名子程序来形成闭包。在进行祝福的时候，不是对数据（比如哈希的引用）进行
bless，而是对匿名子程序引用来祝福。于是，构造器返回的是子程序引用，而且这也成了唯一的一个访问私有数据的方法。这个受祝福的匿名子程序之所以能访问对象的数据，是因为他们在定义的时候在同一个词法有效范围中。因为通过子程序来封装数据，所以可以被看成是闭包。从此，只要匿名子程序的引用仍然存在，就可以存取对象的数据。</p>
</div>
<p class="indent"><a href="ch14.html#ch14exa14">例 14.14</a>
展示了如何使用闭包来为对象封装数据的，具体是以下的步骤：</p>
<p class="indenthangingN"><strong>1.</strong> 首先为 <em>Student</em>
类定义构造器方法。构造器将会定义一个空的匿名哈希，用来给每一个新的
<em>Student</em>
对象设置属性。另外，还有一个全局类变量用于记录学生的数量，以及一个匿名子程序用于封装数据，也用于存取对象数据。所以，最后受到祝福并返回的是一个匿名子程序。</p>
<p class="indenthangingN"><strong>2.</strong>
然后定义实例方法来读写数据。记住，这些方法不能直接从参数中获取对象引用了。所以要读写数据现在得通过匿名子程序的引用，而且调用时候得提供合适的参数。</p>
<p class="indenthangingN"><strong>3.</strong> 这里要定义一个析构器来显示将被销毁的
<em>Student</em> 对象。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa14"/>例 14.14</p>
<p class="codelink1"><a id="p14exa14" href="ch14_images.html#p14exa14a">Click here to view code
image</a></p>
<p class="pre1"># <span class="EmpItalic">File is House.pm</span><br/><br/>&#160;&#160;&#160;package House;<br/><br/>1&#160;&#160;my @props=qw(Owner Color Price);&#160;&#160;# <span
class="EmpItalic">Define property keys</span><br/><br/>2&#160;&#160;sub new{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($class)=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my @values=@_;&#160;&#160;# <span
class="EmpItalic">Values for properties</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my %data;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Will store properties</span><br/>3&#160;&#160;&#160;&#160;&#160;@data{@props}=@values;&#160;&#160;# <span
class="EmpItalic">Create the hash with keys and values</span><br/><br/>4&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $access_ptr =
sub</span>{&#160;&#160;# <span class="EmpItalic">Anonymous subroutine</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "Caller is
",(caller)[0],"\n";<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;my($access_type, $key,
$value) = @_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Determines if setting or getting data</span><br/>6&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;die "Direct access not
allowed" if caller() ne "House";<br/><a id="page_482"/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if
($access_type eq "set" &#38;&#38; $key eq "Price"){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;die
"Can't change Price\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ($access_type eq "set"){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$data{$key}=$value;&#160;&#160;#
<span class="EmpItalic">Closure, %data still available here</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>9&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ($access_type eq "get"){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return
$data{$key};<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;};<br/>10&#160;&#160;&#160;&#160;<span class="EmpStrong">return bless( $access_ptr,
$class)</span>;&#160;&#160;<span class="EmpItalic"># Bless anonymous
sub</span><br/>&#160;&#160;&#160;}&#160;&#160;# <span class="EmpItalic">End new</span><br/><br/>11 sub set {<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($self, $key, $value)= @_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;("set", $key, $value);<br/>&#160;&#160;&#160;}<br/>12 sub get {<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($self, $key)= @_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;("get",$key);<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;1;</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> <em>House</em> 类的所有对象都有
<em>Owner</em>、<em>Color</em> 和 <em>Price</em>
属性，它们是存储在 <em>@props</em> 数组里面的。</p>
<p class="sb-indenthangingN"><strong>2.</strong>
构造器用来创建并祝福对象。首先是通过哈希来设置属性，然后是通过用户代码来设置具体的值。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 用键值对的方式来给 <em>%data</em>
赋值，这里用到了哈希切片的语法。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这个 <em>$access_ref</em>
变量得到的赋值是一个匿名子程序，于是成为一个闭包。这个子程序引用被祝福成一个类的实例，也可以用来读写
<em>House</em>
对象的数据。用户代码必须通过这个函数引用来存取封装的数据。闭包使得
<em>%data</em>
中的属性可以存取，哪怕这个数据看似已经超出了定义范围。</p>
<p class="sb-indenthangingN"><strong>5.</strong>
这个子程序带有三个参数：存取类型（要么是
<em>set</em>，要么是
<em>get</em>）、一个对象的属性，以及对应的值。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里 Perl 内置的函数 <em>caller()</em>
返回的是被调用的函数所在的包名。如果这个包与
<em>House</em>
不一致的话，就会打印错误信息并退出。这点我们后面会更加明白。目前来说，这意味着你不能在用户代码中直接存取对象的数据，而必须通过类定义的方法来完成。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 如果调用的参数中存取类型是
<em>set</em>，而对象的属性是
<em>Price</em>，那么就打印错误信息，拒绝设置价格属性的值，并且退出。</p>
<p class="sb-indenthangingN"><a id="page_483"/><strong>8.</strong> 如果存取类型是
<em>set</em>，那么就设置对象的值。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 如果存取类型是
<em>get</em>，那么读取属性对应的值。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 这里通过 bless
来将匿名子程序的引用祝福，并返回调用者。而在之前的例子中，祝福并返回的都是
<em>HASH</em>。</p>
<p class="sb-indenthangingN1"><strong>11.</strong> 这里定义的是 <em>set</em>
方法，用户调用它的时候其实不是直接完成数据的修改，而是通过间接呼叫对应的子程序来完成的。因为第一个参数就指向了匿名子程序，而不是匿名哈希、数组或者标量的引用。第二个参数则是对象的属性，最后一个参数才是对应的值。因此
<em>$self</em>
其实是在第十行祝福过的匿名子程序，访问对象的数据靠得也是它。</p>
<p class="sb-indenthangingN1"><strong>12.</strong> 这里的 <em>get</em> 方法的工作机制与
<em>set</em> 类似，因为也是通过调用 <em>$self</em>
指向的匿名子程序来读取数据的。</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa15"/>例 14.15</p>
<p class="codelink1"><a id="p14exa15" href="ch14_images.html#p14exa15a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;# <span class="EmpItalic">User of the House Module</span><br/>1&#160;&#160;use House;&#160;&#160;# <span class="EmpItalic">Load the House
module</span><br/><br/>2&#160;&#160;my $obj1 = House-&gt;new("John","red","10000");<br/>&#160;&#160;&#160;my $obj2 = House-&gt;new("Alice","green","20000");<br/><br/>3&#160;&#160;print "The owner of the first house is ",
$obj1-&gt;get("Owner"),"\n";<br/>&#160;&#160;&#160;print "The owner of the second house is ",
$obj2-&gt;get("Owner"),"\n";<br/><br/>4&#160;&#160;$obj1-&gt;set("Owner"=&gt;"Mary");<br/>&#160;&#160;&#160;$obj1-&gt;set("Style"=&gt;"ranch");<br/>&#160;&#160;&#160;print "After reset for Alice:\n";<br/>5&#160;&#160;print "Alice sold her house to ", $obj1-&gt;get("Owner"),"\n";<br/>6&#160;&#160;#$obj1-&gt;set("Price"=&gt;"50");&#160;&#160;&#160;# <span
class="EmpItalic">Can't change price</span><br/>7&#160;&#160;#$ obj1-&gt;("set","Owner"=&gt;"Bank");&#160;&#160;# <span
class="EmpItalic">Direct access not allowed</span><br/><br/>(Ouput)<br/>3&#160;&#160;<span class="EmpItalic">The owner of the first house is
John</span><br/>&#160;&#160;&#160;<span class="EmpItalic">The owner of the second house is
Alice</span><br/>5&#160;&#160;<span class="EmpItalic">After reset for Alice:</span><br/>6&#160;&#160;<span class="EmpItalic">Alice sold her house to Mary</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 载入 <em>House</em> 模块。</p>
<p class="sb-indenthangingN"><strong>2.</strong>
创建两个房屋对象，通过构造器设置相应的参数属性。（这里所有的房屋对象其实都是祝福过的匿名子程序引用。）</p>
<p class="sb-indenthangingN"><strong>3.</strong> 通过 <em>get()</em>
方法来打印两个房屋的拥有者。这里的第一个参数是房屋对象的引用，而第二个参数则是具体的属性
<em>Owner</em>。返回的是对应的键值。（请参考
<em>House.pm</em> 第九行的定义。）</p>
<p class="sb-indenthangingN"><a id="page_484"/><strong>4.</strong> 这里调用 <a
id="page_484"/><strong>4.</strong> 中定义的 <em>set()</em>
方法，用哈希格式来发送键和对应的值。（请参考
<em>House.pm</em> 第十一行的定义。）</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这一行通过
<em>$obj1</em>-<em>&gt;get(&#8220;Owner&#8221;)</em>
打印出来的信息说明房屋的拥有者已经改变了。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 用户不能将 <em>Price</em> 设为 $50.00。请参考
<em>House.pm</em>
模块中第七行的代码。如果这么调用的话，程序会崩溃。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里显示用户如何企图（绕过
<em>House.pm</em> 定义的 <em>set()</em> 方法）通过 <em>$obj1</em>
引用来直接修改数据。如果这么做的话，<em>caller()</em>
函数（<em>House.pm</em> 第六行）会返回
&#8220;main&#8221;，于是会打印错误信息并退出。如果用户通过
<em>$obj1</em>-<em>&gt;set(&#8217;Owner&#8217;=&gt;&#8217;Bank&#8217;)</em>
这样的方式来调用 <em>set()</em> 方法的话，就等于是从
<em>House.pm</em> 模块的 <em>set()</em>
方法中发起对匿名子程序的调用。所以 <em>set()</em>
函数返回的就是
<em>House</em>。也就是说，这里的底线是：调用者必须是
<em>House</em>，否则退出。</p>
<hr/></div>
<div class="heading">
<h3 id="ch14lev1sec4">14.4 继承</h3>
<p class="noindent"><strong>继承</strong>的含义是从已有的某个类中继承方法定义，并形成一个新类。新类可以对已有类的代码进行增加或者修订，从而实现类的定制，而不必完全重头开始发明一切。这里的原则就是，从已有类可以延伸出许多的子类，而且所有子类都有共同的根基，但又可以发展出各自的细分特色来。这一类的思维或组织结构其实并不陌生，你应该在生物学的课程上看到过对植物和动物的分类方法：门纲目科属种等等。另外，面向程序的编程中也有类似的概念，就是通过组合代码中的可复用程序来完成指定的任务。</p>
</div>
<p class="indent">在面向对象编程中，一旦类书写出来，也通过了调试，就可以把它部署在一个类库中供其他程序员调用。程序员可以对现存类增加功能，而不必重写整个类。这个实现的机制就是继承，也就是从现存类衍生新类。正是因为这个类库继承机制的存在，面向对象语言才得到广泛的接受。现在我们来看看
Perl 是怎样实现继承的。</p>
<div class="heading">
<h4 id="ch14lev2sec13">14.4.1 <em>@ISA</em> 数组和的方法调用</h4>
<p class="noindent">列在 <em>@ISA</em>
数组中的是当期类的父类，或者说是基类。这就是 Perl
实现继承的方法。如果 Perl
在调用某个方法，而且在当前的包（也就是类）中找不到，那么就会从
<em>@ISA</em>
数组中的其他包查找。如果仍然找不到的话，就会搜索
<em>AUTOLOAD</em>
函数，并进行调用。如果最后连这个也找不到的话，就搜索一个特殊的名为
<em>UNIVERSAL</em> 的预定义包。其实这个 <em>UNIVERSAL</em>
类是所有类的父类，也就是所有对象类的最高层次祖先。</p>
</div>
<p class="indent">注意，在常见的子程序调用过程中不会搜索 <em>@ISA</em>
数组，只有方法调用的语法才会触发这个搜索过程。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa16"/>例 14.16</p>
<p class="codelink1"><a id="p14exa16" href="ch14_images.html#p14exa16a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;#!/bin/perl<br/>&#160;&#160;&#160;# <span class="EmpItalic">Example of attempting
inheritance without updating</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">the @ISA array</span><br/>1&#160;&#160;{ <span class="EmpStrong">package Grandpa;</span><br/>2&#160;&#160;&#160;&#160;&#160;$name = "Gramps"; # <span
class="EmpItalic">Global package variable for Grandpa</span><br/>3&#160;&#160;&#160;&#160;&#160;sub greetme {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">print "Hi $Child::name I'm your $name from package
Grandpa.\n";</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>4&#160;&#160;{ <span class="EmpStrong">package Parent;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">This package
is empty</span><br/>&#160;&#160;&#160;}<br/>5&#160;&#160;{ <span class="EmpStrong">package Child;</span><br/>6&#160;&#160;&#160;&#160;&#160;$name = "Baby";<br/>7&#160;&#160;&#160;&#160;&#160;print "Hi I'm $name in the Child Package
here.\n";<br/>8&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">Parent-&gt;greetme();</span>&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Use method invocation syntax</span><br/>&#160;&#160;&#160;}<br/><br/>(Output)<br/>7&#160;&#160;<span class="EmpItalic">Hi I'm Baby in the Child Package
here.</span><br/>8&#160;&#160;<span class="EmpItalic">Can't locate object method "greetme"
via package "Parent" at</span><br/>&#160;&#160;&#160;<span class="EmpItalic">inher2 line 23.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里声明了 <em>Grandpa</em> 包。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这里在 <em>Grandpa</em> 包中将全局标量
<em>$name</em> 设置为 <em>Gramps</em>。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里定义了 <em>greetme</em>
子程序，在调用时会执行其中的 <em>print</em> 语句。而
<em>$Child::name</em> 则值得是 <em>Child</em>
包中定义的全局标量 <em>$name</em>。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里定义的是 <em>Parent</em>
包，是一个空包。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里定义的是 <em>Child</em>
包。这个包将会尝试调用另一个包中的方法。尽管这里的对象和方法无人使用，但是这个例子的目标是展示如何从另一个类中继承一个方法过来。</p>
<p class="sb-indenthangingN"><strong>8.</strong> Perl 无法从 <em>Parent</em> 包中找到
<em>greetme</em> 的定义，只能打印错误信息。</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_486"/><a id="ch14exa17"/>例 14.17</p>
<p class="codelink1"><a id="p14exa17" href="ch14_images.html#p14exa17a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;#!/bin/perl<br/>&#160;&#160;&#160;# <span class="EmpItalic">Example of attempting
inheritance by updating the @ISA array</span><br/>1&#160;&#160;{ <span class="EmpStrong">package Grandpa;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$name = "Gramps";<br/>2&#160;&#160;&#160;&#160;&#160;sub greetme {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">print "Hi $Child::name I'm your $name from package
Grandpa.\n";</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/><br/>3&#160;&#160;{ <span class="EmpStrong">package Parent;</span><br/>4&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">@ISA=qw(Grandpa);</span>&#160;&#160;# <span
class="EmpItalic">Grandpa is a package in the @ISA array.</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">This package
is empty.</span><br/>&#160;&#160;&#160;}<br/><br/>5&#160;&#160;{ <span class="EmpStrong">package Child;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$name = "Baby";<br/>6&#160;&#160;&#160;&#160;&#160;print "Hi I'm $name in the Child Package
here.\n";<br/>7&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">Parent-&gt;greetme();</span>&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Parent::greetme() will not fail</span><br/>&#160;&#160;&#160;}<br/><br/>(Output)<br/>6&#160;&#160;<span class="EmpItalic">Hi I'm Baby in the Child Package
here.</span><br/>7&#160;&#160;<span class="EmpItalic">Hi Baby I'm your Gramps from package
Grandpa.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里声明了 <em>Grandpa</em> 包。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这里定义了 <em>greetme</em> 子程序，其中的
<em>print</em>
语句在调用时会得到执行机会。<em>$Child::name</em> 指向
<em>Child</em> 包中定义的标量 <em>$name</em>。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里声明了 <em>Parent</em> 包。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里在 <em>@ISA</em> 数组中赋值 <em>Grandpa</em>
包的名字。所以，如果 Perl 无法在 <em>Child</em>
包中找到某个方法的定义，就会试着找 <em>@ISA</em>
数组中列出的 <em>Grandpa</em>
包里面有没有定义。在常规的子程序调用中并没有查询
<em>@ISA</em>
数组的步骤，因为这并不是方法调用。尽管这里的子程序从技术上来说不怎么像是一个方法，通过对
<em>@ISA</em> 数组的搜索，它还是会调用 <em>greetme</em>
这个类方法。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里声明的是 <em>Child</em> 包。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这一行将会在 <em>Child</em>
包中得到打印机会。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里在 <em>Parent</em> 包中调用类方法
<em>greetme</em>。通过 <em>@ISA</em> 数组来触发 Perl 对
<em>Grandpa</em> 包进行搜索，从而解决 <em>Parent</em>
包中不能找到的方法带来的问题。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec14">14.4.2 <em>$AUTOLOAD</em>、<em>sub AUTOLOAD</em> 和 <em>UNIVERSAL</em></h4>
<p class="noindent">如果在当前包以及 <em>@ISA</em>
数组中的其他包里面都找不到某个方法的定义，那么就会试着调用
<em>AUTOLOAD</em> 函数。在调用它的时候，<em>$AUTOLOAD</em>
变量会被赋予正在调用的子程序的名字。而被掉子程序的参数也会进入
<em>AUTOLOAD</em> 子程序的 <em>@_</em> 数组。如果你对
<em>$AUTOLOAD</em>
变量进行赋值的话，那个在无法匹配的方法调用发生的时候就会调用这个变量中的名字对应的方法。而且如果通过
<em>AUTOLOAD</em> 子程序和 <em>$AUTOLOAD</em>
变量进行匹配，那么无论是方法调用语法还是普通语法都会生效。如果以上一切都不能匹配的话，Perl
就会尝试在 <em>UNIVERSAL</em> 包中定位方法。<em>UNIVERSAL</em>
类最起码定义了三个方法，是所有类都必须继承的。他们是
<em>isa()</em>、<em>can()</em> 和 <em>VERSION()</em>（请参考<a
href="ch14.html#ch14tab02">表 14.2</a>）。另外，可以通过输入
<em>perldoc UNIVERSAL</em> 命令来查询最新的文档。</p>
</div>
<div class="tab-heading">
<div class="image"><a id="ch14tab02"/><img src="graphics/14tab02.jpg" alt="Image"/></div>
<p class="tab-caption"><strong>表 14.2</strong><em>isa()</em>、<em>can()</em> 和
<em>VERSION()</em> 方法</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa18"/>例 14.18</p>
<p class="codelink1"><a id="p14exa18" href="ch14_images.html#p14exa18a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;{ <span class="EmpStrong">package Grandpa;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$name = "Gramps";<br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sub greetme
{</span><br/>2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">print "Hi $Child::name I'm your $name from package
Grandpa.\n";</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;}<br/><br/>3&#160;&#160;{ <span class="EmpStrong">package Parent;</span><br/>4&#160;&#160;&#160;&#160;&#160;sub AUTOLOAD{<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "<span
class="EmpStrong">$_[0]</span>: $_[1] and $_[2]\n";<br/>6&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "You know us after
all!\n";<br/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "The unheard of
subroutine is called <span class="EmpStrong">$AUTOLOAD</span>.\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>8&#160;&#160;{ <span class="EmpStrong">package Child;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$name = "Baby";<br/>9&#160;&#160;&#160;&#160;&#160;print "Hi I'm $name in the Child Package
here.\n";<br/>10&#160;&#160;&#160;&#160;<span class="EmpStrong">Parent-&gt;unknown("Mom",
"Dad");</span>&#160;&#160;&#160;# <span class="EmpItalic">Undefined
subroutine</span><br/>&#160;&#160;&#160;}<br/><br/>(Output)<br/>2&#160;&#160;<span class="EmpItalic">Hi Baby I'm your Gramps from package
Grandpa.</span><br/>9&#160;&#160;<span class="EmpItalic">Hi I'm Baby in the Child Package
here.</span><br/>5&#160;&#160;<span class="EmpItalic">Parent: Mom and Dad</span><br/>6&#160;&#160;<span class="EmpItalic">You know us after all!</span><br/>7&#160;&#160;<span class="EmpItalic">The unheard of subroutine is called
Parent::unknown.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_488"/>Explanation</p>
<p class="sb-indenthangingN"><strong>1.</strong> The package <em>Grandpa i</em>s declared. It contains
one subroutine.</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这一行从 <em>Grandpa</em> 包中打印出来。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里定义了 <em>Parent</em> 包。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里因为存在 <em>AUTOLOAD</em>
子程序。在第十行又有一个未定义的子程序调用（这个调用有两个参数
<em>Mom</em> 和 <em>Dad</em>）。所以，Perl 意识到 <em>Child</em>
包中找不到子程序定义，于是就去查看 <em>@ISA</em>
数组，因为仍然找不到，就会去查找 <em>AUTOLOAD</em>
子程序。</p>
<p class="sb-indenthangingNP">这里定义的是 <em>AUTOLOAD</em> 子程序。</p>
<p class="sb-indenthangingN"><strong>5.</strong>
因为这个函数是用类方法的方式来调用的，所以 <em>@_</em>
数组中的第一个参数是类的名字。其余的参数就是之前提到的
<em>Mom</em> 和 <em>Dad</em>。</p>
<p class="sb-indenthangingN"><strong>6.</strong>
打印这一行是为了显明我们执行到了这里。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里的 <em>$AUTOLOAD</em>
变量包含了类名和未定义的子程序名。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 这里定义的是 <em>Child</em> 包。</p>
<p class="sb-indenthangingN"><strong>9.</strong>
打印这一行是为了显明我们执行到了这里。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 这里 <em>Child</em> 包想要调用 <em>Parent</em>
包中的一个方法。而 <em>Parent</em> 包并未定义这个名为
<em>unknown</em> 的子程序。不过，它确实定义了一个
<em>AUTOLOAD</em>
子程序，所以这里它会得到执行，因为没有其他的子程序可以找到。</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa19"/>例 14.19</p>
<p class="codelink1"><a id="p14exa19" href="ch14_images.html#p14exa19a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;{ <span class="EmpStrong">package Grandpa;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$name = "Gramps";<br/>2&#160;&#160;&#160;&#160;&#160;sub greetme {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "Hi $Child::name
I'm your $name from package Grandpa.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>3&#160;&#160;{ <span class="EmpStrong">package Parent;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">This package
is empty</span><br/>&#160;&#160;&#160;}<br/>4&#160;&#160;{ <span class="EmpStrong">package Child;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$name = "Baby";<br/>5&#160;&#160;&#160;&#160;&#160;print "Hi I'm $name in the Child Package
here.\n";<br/>6&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">Parent-&gt;greetme();</span><br/>&#160;&#160;&#160;}<br/><br/>7&#160;&#160;<span class="EmpStrong">package UNIVERSAL;</span><br/>8&#160;&#160;<span class="EmpStrong">sub AUTOLOAD {</span><br/>9&#160;&#160;&#160;&#160;&#160;print "The UNIVERSAL lookup package.\n";<br/>10&#160;&#160;&#160;&#160;<span
class="EmpStrong">Grandpa-&gt;greetme();</span><br/>&#160;&#160;&#160;}<br/><br/>(Output)<br/>2&#160;&#160;<span class="EmpItalic">Hi I'm Baby in the Child Package
here.</span><br/>9&#160;&#160;<span class="EmpItalic">The UNIVERSAL lookup package.</span><br/>5&#160;&#160;<span class="EmpItalic">Hi Baby I'm your Gramps from package
Grandpa.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_489"/>Explanation</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里声明了 <em>Grandpa</em> 包。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这个包中定义了子程序 <em>greetme</em>。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里声明了 <em>Parent</em> 包，是一个空包。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里声明了 <em>Child</em> 包。</p>
<p class="sb-indenthangingN"><strong>5.</strong>
打印这一行是为了显明程序执行到了这里。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里用类方法的语法来调用 <em>Parent</em>
包中的 <em>greetme</em>
子程序。因为这个类中并未定义此方法，也不能在
<em>@ISA</em> 数组中找到帮助，并且这个 <em>Parent</em>
包也没有 <em>AUTOLOAD</em> 函数，因此 Perl 最终只能查找
<em>UNIVERSAL</em> 包。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这是内定的名为 <em>UNIVERSAL</em>
的基类。因为所有的类都从此类继承，因此 <em>UNIVERSAL</em>
其实就是隐含的附加在了 <em>@ISA</em> 数组的末尾。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 这里自动调用了 <em>UNIVERSAL</em> 类的
<em>AUTOLOAD</em> 函数。</p>
<p class="sb-indenthangingN2"><strong>9, 10.</strong> 在 <em>AUTOLOAD</em> 函数中最终调用了
<em>Grandpa</em> 包中的 <em>greetme()</em> 函数。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec15">14.4.3 衍生类</h4>
<p class="noindent">如同之前介绍的，所谓<strong>继承</strong>就是一个新类可以从另一个已有类继承方法定义。已有类被称为<strong>基类</strong>、<strong>父类</strong>，或者<strong>超类</strong>，而新类往往被称为<strong>衍生类</strong>、<strong>子类</strong>或者<strong>亚类</strong>。基类定义的方法所有的子类都会继承，而子类可以超越父类实现崭新的功能。</p>
</div>
<p class="indent">如果衍生类都来自于一个基类，那么就被称为是<strong>单继承</strong>。在实际生活中，如果一个小孩从父亲那里继承了画画的天赋，那么就是单继承。如果衍生类或子类来自于一个以上的基类，那么就被称为<strong>多继承</strong>。同样的，实际生活中一个小孩可能从父亲那里继承了画画的天赋，而且同时从母亲那里继承了歌唱的天赋。在
Perl
里面，衍生类从基类那里继承来的方法，可以事后增加或必要时进行修正。</p>
<p class="indent">实现继承的机制就是通过 <em>@ISA</em> 数组。在<a
href="ch13.html#ch13">第十三章
“模块化、封包话和库！”</a>当中，我们分析了 Perl
的标准库和我们可以自行构建的模块。为了将模块或者语义引入程序，要使用
<em>use</em> 函数（调用的时候只需要模块名，不需要带上
.<em>pm</em>
附属名）。模块可以选择在载入时向其他包输出符号表。通过一个名为
<em>Exporter.pm</em> 的特殊模块来进行符号表（主要是列在
<em>@EXPORT</em> 和 <em>@EXPORT_OK</em>
数组中）的输入和输出。如果你还记得的话，<em>Exporter.pm</em>
模块就是通过列入 <em>@ISA</em>
数组的方法来继承必要的方法，从而完成它的使命的。但是，如果一个模块的功能主要是实现一个类的话，那么大多数情况下是不需要
<em>Exporter</em>
支持就可以工作的。注意在下面的例子中，类方法和实例方法都未进行任何形式的符号表输出。</p>
<p class="indent">下面的例子是关于继承的。用户程序不必和基类
<em>Employee</em> 发生任何直接关联。衍生类 <em>Salesman</em> 和
<em>Teacher</em> 都继承了 <em>Employee</em>，因此它们都会通过
use 来载入基类 <em>Employee</em>。<a "href="ch14.html#ch14fig05">图
14.5</a> 会更好的显明继承关系。</p>
<div class="fig-heading">
<div class="image"><a id="page_490"/><a id="ch14fig05"/><img src="graphics/14fig05.jpg" alt="Image"/></div>
<p class="fig-caption"><strong>图 14.5</strong>，共同基类的继承关系图</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa20"/>例 14.20</p>
<p class="codelink1"><a id="p14exa20" href="ch14_images.html#p14exa20a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;# <span class="EmpItalic">Module Employee.pm</span><br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">The Base Class</span><br/>1&#160;&#160;<span class="EmpStrong">package Employee;</span><br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>&#160;&#160;&#160;# <span class="EmpItalic">Constructor method</span><br/>2&#160;&#160;<span class="EmpStrong">sub init</span> {<br/>3&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>4&#160;&#160;&#160;&#160;&#160;my %info = @_;<br/>5&#160;&#160;&#160;&#160;&#160;my $self = {_Name=&gt;$info{"_Name"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_StartDate=&gt;$info{"_StartDate"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_BasePay=&gt;$info{"_BasePay"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>6&#160;&#160;&#160;&#160;&#160;return bless($self, $class);<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;# <span class="EmpItalic">Some instance methods</span><br/>&#160;&#160;&#160;sub get_name{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $self-&gt;{_Name};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;sub get_startdate{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $self-&gt;{_StartDate};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;sub get_basepay{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $self-&gt;{_BasePay};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_491"/>代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里的 <em>Employee</em>
基类其实源自一个名叫 <em>Employee.pm</em> 的文件。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这里的 <em>init</em>
方法是一个构造器，能设置所有员工的属性。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 第一个参数是被调用的方法所在的类名。</p>
<p class="sb-indenthangingN"><strong>4.</strong>
这个函数的调用接口是一个哈希格式的键值对。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里吧 <em>%info</em>
哈希的值赋给员工的属性。</p>
<p class="sb-indenthangingN"><strong>6.</strong>
新员工的引用被祝福称为类的对象，类名（作为第一个参数）成为祝福的标签。</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa21"/>例 14.21</p>
<p class="codelink1"><a id="p14exa21" href="ch14_images.html#p14exa21a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;package Salesman;<br/>&#160;&#160;&#160;use lib("/usr/local/bin/baseclass");&#160;&#160;# <span
class="EmpItalic">Update @INC</span><br/>&#160;&#160;&#160;use v5.10.0;<br/>&#160;&#160;&#160;use feature qw(state say);<br/>2&#160;&#160;use base qw(Employee);&#160;&#160;# <span
class="EmpItalic">Updates @ISA</span><br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>3&#160;&#160;sub count_salesman{&#160;&#160;&#160;# <span
class="EmpItalic">Class method</span><br/>4&#160;&#160;&#160;&#160;&#160;state $counter=0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$counter++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $counter;<br/>&#160;&#160;&#160;}<br/>5&#160;&#160;sub new&#160;&#160;{&#160;&#160;# <span
class="EmpItalic">Constructor for Salesman</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($class)= shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my %data=@_;<br/>6&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $emp =
$class-&gt;init("_Name"=&gt;$data{_Name},</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_StartDate"=&gt;$data{_StartDate},</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_BasePay"=&gt;$data{_BasePay},</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>7&#160;&#160;&#160;&#160;&#160;$emp-&gt;{"_AnnualSales"}=$data{"_AnnualSales"};<br/>&#160;&#160;&#160;&#160;&#160;&#160;$emp-&gt;{"_Commission"}=$data{"_Commission"};<br/>8&#160;&#160;&#160;&#160;&#160;say "This is $emp-&gt;{_Name}, salesman #",
count_salesman();<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $emp;<br/>&#160;&#160;&#160;}<br/>9&#160;&#160;sub calculate_pay{<br/>10&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $rate = $self-&gt;{"_Commission"};<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $sales = $self-&gt;{"_AnnualSales"};<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $base = $self-&gt;{"_BasePay"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $pay = $sales * $rate + $base;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $pay;<br/>&#160;&#160;&#160;}<br/>11 sub DESTROY{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "$self-&gt;{_Name} is leaving the
firm.\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_492"/>代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 通过 <em>Salesman.pm</em> 来声明了
<em>Salesman</em> 类的存在。</p>
<p class="sb-indenthangingN">通过 <em>base</em> 模块来修改 <em>@ISA</em> 数组，并载入
<em>Employee.pm</em>
模块。当然，也可以通过这样的方式来修改 <em>@ISA</em>：</p>
<p class="pre2">push(@ISA,"Employee");<br/>use Employee;</p>
<p class="sb-indenthangingNP">在 Perl 5.16 和更高的版本中，你还可以这样写：</p>
<p class="pre2">use parent Employee;</p>
<p class="sb-indenthangingN4"><strong>3, 4.</strong>
这里的计数子程序会记录目前为止创建的销售人员的数量。这里使用了
<em>state</em> 这个功能来保持 <em>$counter</em>
变量的值在多次调用之间保持有效，也就是说每次访问的时候不必担心它的值已经恢复到了零。这个子程序是一个类方法，它对某个具体的对象实例来说没有意义，因此它的第一个参数也不会是引用。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里定义了 <em>Salesman</em>
类的构造器方法。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里我们看到，从 <em>Employee</em> 类（参考
<em>Employee.pm</em>）继承来的 <em>init</em> 方法（不在当前类
<em>Salesman</em>  中定义）得到了调用。当 <em>init</em>
调用发生的时候，Perl 会先查看当前的 <em>Salesman</em>
类，因为无法找到定义，于是就查看 <em>@ISA</em>
数组，发现了其中的关键所在。注意，这里调用
<em>Employee</em> 类的 <em>init()</em>
方法的时候，发送的第一个参数是
<em>Salesman</em>。因为这里的对象是被祝福成了
<em>Salesman</em> 类的，而不是 <em>Employee</em>
类。其他的参数都是为 <em>Employee</em>
对象的属性而设的。最终，一个祝福过的新 <em>Salesaman</em>
对象被返回。</p>
<p class="sb-indenthangingN"><strong>7.</strong>
现在祝福过的销售人员对象，会得到更多有关销售人员的属性。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 每当一个新的 <em>Salesman</em>
对象创建的时候，都会调用 <em>count_salesman</em>
函数。这个类方法不需要对象引用就能调用。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 为 <em>Salesman</em> 类定义了一个存取方法
<em>calculate_pay()</em>。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 第一个参数是对象引用，是由 Perl
在调用时候默认发送的。</p>
<p class="sb-indenthangingN1"><strong>11.</strong> 这里的 <em>DESTROY</em>
方法是在对象的有效期达到时调用的，通常这意味着程序退出的时候。</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa22"/>例 14.22</p>
<p class="codelink1"><a id="p14exa22" href="ch14_images.html#p14exa22a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;<span class="EmpStrong">package Teacher</span>;<br/>&#160;&#160;&#160;use v5.10.0;<br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>&#160;&#160;&#160;use feature qw(state say);<br/>2&#160;&#160;<span class="EmpStrong">our @ISA=qw(Employee)</span>;<br/>&#160;&#160;&#160;<span class="EmpStrong">use Employee</span>;<br/><br/>&#160;&#160;&#160;my $tracker;<br/><a id="page_493"/>3&#160;&#160;sub count_teacher{&#160;&#160;&#160;# <span
class="EmpItalic">Class method</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;state $counter=0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$counter++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $counter;<br/>&#160;&#160;&#160;}<br/>4&#160;&#160;sub new&#160;&#160;{&#160;&#160;# <span
class="EmpItalic">Constructor for Teacher</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($class)= shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my %data=@_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $emp =
$class-&gt;init("_Name"=&gt;$data{_Name},<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_StartDate"=&gt;$data{_StartDate},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_BasePay"=&gt;$data{_BasePay},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;$tracker=count_teacher();<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $emp;<br/>&#160;&#160;&#160;}<br/>6&#160;&#160;<span class="EmpStrong">sub set_courses</span>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $cptr=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;{"_Courses"}=$cptr;<br/>&#160;&#160;&#160;}<br/>7&#160;&#160;sub get_courses{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return "@{$self-&gt;{'_Courses'}}";<br/>&#160;&#160;&#160;}<br/><br/>8&#160;&#160;<span class="EmpStrong">END</span>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "$tracker teachers were
created.\n";<br/>&#160;&#160;&#160;}</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里定义了 <em>Teacher</em> 类。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 在这个模块中，<em>@ISA</em>
是直接修改的，没有使用 <em>base.pm</em> 或者 <em>parent.pm</em>
这类语法结构。这里列出了它的基类，所以 <em>Teacher</em>
这个子类可以继承基类的方法。其实，这里要做的不只是修改
<em>@ISA</em> 数组的修改，也必须通过 <em>use</em>
语句来载入基类。而使用 <em>use parent</em> 或者 <em>use
base</em> 语法的时候，这两个动作其实是自动完成的。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里使用类方法来跟踪目前为止创建的
<em>Teacher</em> 对象的数量。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里定义的 <em>new()</em>
构造器方法通过哈希来定义教师对象的属性，并且将祝福过的引用返回给调用者。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 同样的，这里类似于之前的 <em>Salesman</em>
类的构造，<em>Teacher</em> 从 <em>Employee</em> 继承了
<em>init()</em> 方法，也进行了调用。这里调用的
<em>init()</em> 构造器对 <em>Employee</em>
类进行了基础属性的初始化，并且将 <em>Employee</em> 对象以
<em>Teacher</em> 对象引用的形式返回。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里对教师对象调用 <em>set_courses()</em>
方法，并将课程列表作的引用作为附加参数。这些课程会设置为对象的一个新属性。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里的 <em>get_courses()</em>
方法将会通过查找
<em>$self-&gt;{Courses}</em>，获得教师的课程列表并返回。</p>
<p class="sb-indenthangingN"><a id="page_494"/><strong>8.</strong>
当程序将要退出的时候，这个特殊的 <em>END</em>
子程序将会打印目前创建的 <em>Teacher</em>
对象的数量。这比起使用 <em>DESTROY</em>
方法要好一些，因为 <em>DESTROY</em>
方法每当教师对象将被释放的时候就会被调用。因此，如果你创建了六个教师对象，那么打印信息的数量也就是六行。</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa23"/>例 14.23</p>
<p class="codelink1"><a id="p14exa23" href="ch14_images.html#p14exa23a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;# <span class="EmpItalic">The Driver (user) Program</span><br/>1&#160;&#160;use Salesman;<br/>2&#160;&#160;use Teacher;<br/>&#160;&#160;&#160;use Data::Dumper;<br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>3&#160;&#160;<span class="EmpStrong">my
$salesguy1=Salesman-&gt;new("_Name"=&gt;"Nicky McDonald",</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_StartDate"=&gt;"12/12/2010",</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_BasePay"=&gt;25000,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_AnnualSales"=&gt;1200,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_Commission"=&gt;.05,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">);</span><br/>4&#160;&#160;my $pay=$salesguy1-&gt;calculate_pay();<br/>&#160;&#160;&#160;printf "$salesguy1-&gt;{_Name} made \$%.2f last
year.\n\n", $pay;<br/><br/>5&#160;&#160;<span class="EmpStrong">my
$salesguy2=Salesman-&gt;new("_Name"=&gt;"Rick Gonzales",</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_StartDate"=&gt;"12/12/2010",</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_BasePay"=&gt;80000,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_AnnualSales"=&gt;12200,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_Commission"=&gt;.08,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">);</span><br/>6&#160;&#160;$pay=$salesguy2-&gt;calculate_pay;<br/>&#160;&#160;&#160;printf "$salesguy2-&gt;{_Name} made \$%.2f last
year.\n\n", $pay;<br/><br/>7&#160;&#160;<span class="EmpStrong">my
$teacher=Teacher-&gt;new("_Name"=&gt;"Charles Lee",</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_StartDate"=&gt;"08/12/2013",</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_BasePay"=&gt;55000,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">);</span><br/><br/>8&#160;&#160;<span class="EmpStrong">$teacher-&gt;set_courses(["Basic Math",
"Algebra", "Calculus"]);</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">Pass ref to Array of
courses</span><br/>&#160;&#160;&#160;print
$teacher-&gt;get_name,"\n";&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Inheritance</span><br/>&#160;&#160;&#160;print $teacher-&gt;get_startdate,"\n"; # <span
class="EmpItalic">Inheritance</span><br/>&#160;&#160;&#160;print $teacher-&gt;get_basepay,"\n" ;&#160;&#160;# <span
class="EmpItalic">Inheritance</span><br/>&#160;&#160;&#160;print $teacher-&gt;get_courses,"\n";&#160;&#160;&#160;#
<span class="EmpItalic">Teacher's access method</span><br/><br/>&#160;&#160;&#160;$Data::Dumper::Varname="employee";&#160;&#160;# <span
class="EmpItalic">Give Dumper a user-defined</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">variable name</span><br/>9&#160;&#160;print Dumper($salesguy1, $teacher); # <span
class="EmpItalic">Dump out data for two objects</span><br/><a id="page_495"/><span class="EmpItalic">(Output)</span><br/>&#160;&#160;&#160;<span class="EmpItalic">This is Nicky McDonald, salesman
#1</span><br/><br/>&#160;&#160;&#160;<span class="EmpItalic">Nicky McDonald made $25060.00 last
year.</span><br/><br/>&#160;&#160;&#160;<span class="EmpItalic">This is Rick Gonzales, salesman
#2</span><br/><br/>&#160;&#160;&#160;<span class="EmpItalic">Rick Gonzales made $80976.00 last
year.</span><br/><br/>&#160;&#160;&#160;<span class="EmpItalic">Charles Lee</span><br/>&#160;&#160;&#160;<span class="EmpItalic">08/12/2013</span><br/>&#160;&#160;&#160;<span class="EmpItalic">55000</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Basic Math Algebra Calculus</span><br/>&#160;&#160;&#160;<span class="EmpItalic">$employee1 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_AnnualSales' =&gt; 1200,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_BasePay' =&gt; 25000,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_Commission' =&gt; '0.05',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_StartDate' =&gt; '12/12/2010',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_Name' =&gt; 'Nicky McDonald'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'Salesman' );</span><br/>&#160;&#160;&#160;<span class="EmpItalic">$employee2 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_BasePay' =&gt; 55000,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_StartDate' =&gt; '08/12/2013',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_Courses' =&gt; [</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Basic Math',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Algebra',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Calculus'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">],</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_Name' =&gt; 'Charles Lee'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'Teacher' );</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Rick Gonzales is leaving the
firm.</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Nicky McDonald is leaving the
firm.</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">1 teachers were
created.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里将 <em>Salesman</em> 类载入内存。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这里将 <em>Teacher</em> 类也载入内存。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里通过调用构造器方法来创建一个新的
<em>Salesman</em>
对象。属性是通过哈希的方式来设置的。发送的是键值对，这样，用户就可以按照任何喜欢的顺序来设置属性。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里调用了 <em>Salesman</em> 的实例方法
<em>calculate_pay</em> 来获取对象的薪酬属性。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里创建了另一个 <em>Salesman</em> 对象。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里为另一个 <em>Salesman</em>
对象来计算薪酬。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里创建了一个新的 <em>Teacher</em>
对象。因为这里构造器 <em>new()</em> 的第一个参数是类名
<em>Teacher</em>，所以调用的构造器也是针对 <em>Teacher</em>
对象的（多态性）。</p>
<p class="sb-indenthangingN"><a id="page_496"/><strong>8.</strong> 这里调用了教师的存取方法
<em>set_courses</em>()。它的参数首先是隐含的对象引用，然后就是一个课程数组的引用。这些课程将会被设置为
<em>Teacher</em>
的一个属性。下面几行中，使用了从基类继承来的方法来获取
<em>Teacher</em> 的属性。</p>
<p class="sb-indenthangingN"><strong>9.</strong>
这里导出了两个员工对象，一个是销售，另一个是教师。他们都是通过
<em>Data::Dumper</em>
展示的。你可以看到每个员工都有各自合适的类。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec16">14.4.4 多重继承和 Moose 角色</h4>
<p class="noindent">当一个类从多于一个的基类（或父类）继承时，就被称为多重继承。在
Perl 当中，多重继承其实就是某个类的 <em>@ISA</em>
数组中有多个类。</p>
</div>
<p class="codelink"><a id="p596pro01" href="ch14_images.html#p596pro01a">Click here to view code
image</a></p>
<p class="pre">package&#160;&#160;Child;<br/>our @ISA = qw (Mother Father Teacher);</p>
<p class="indent">这里的搜索是深度优先的，也就是说 Perl 会首先查看
<em>Mother</em> 和它的父类，然后才查看 <em>Father</em>
和它的父类，最后才是 <em>Teacher</em>
和它的父类。这就类似于日常生活中的情况，在家族树的上方有多条祖先路径几乎总是会带来困惑。</p>
<p class="indent">角色是多重继承的一个选择。类似于 <em>Java</em>
当中的接口，或者 Smalltalk 中的
Traits（特性，也就是一个角色，定义了方法和属性的集合，类要实现角色的要求，就可以被其他的类共享）。角色本身并不是类。下面是
Moose 手册中对角色的描述：</p>
<p class="blockquote">角色是植入类的。实际上来说，角色当中定义的方法、方法修饰词和属性都是融入那个消化角色的类。这些属性和方法看起来好象是类当中定义的一样。那些消耗类的子类会继承所有的方法和属性。</p>
<p class="indent">例如，架设 <em>Guard</em> 类和 <em>Researcher</em>
类都从我们之前创建的 <em>Employee</em>
类进行扩展，而且他们都需要一个方法来确认合乎安保协定。那么，你可以通过多重继承来设计，让他们都同时继承
<em>Employee</em> 和 <em>Clearance</em>
类。但是，继承其实意味着这样的关系，就是衍生类其实是父类的特例。你可以说
<em>Guard</em>
类其实就是特殊的员工类，但是他并不是一个特殊的
<em>Clearance</em>
类。另外，也不是所有的员工都需要安保协定，比如我们的
<em>Salesman</em>
就不必。所以，在这里创建角色似乎更加能够满足我们的需求。角色意味着类需要达到特定的条件，或者说“消化”某个类来满足角色的需要。比如，<em>Guard</em>
和 <em>Salesman</em> 都可以从 <em>Employee</em>
继承所有员工的基本要求，但是 <em>Guard</em> 类必须满足
<em>Clearance</em> 的角色需要，而 <em>Salesman</em>
则不必。所以，这里最适合我们的就是构造一个角色。换句话说，角色真正关心的是“能不能”，而非“是不是”。</p>
<p class="indent"><a id="page_497"/>因为 Perl
没有实现内置的角色机制，所以就必须通过模块来支持。目前最为常见的是
Moose 模块，它对 Perl 5 的对象机制进行了拓展。可以参考<a
href="app03.html#app03">附录 C Moose，Perl 5
的后现代对象系统简介</a>。另外还有一个叫做 Moo 的 Moose
子集，在启动方面更加迅速。（参考 <em><a
href="http://perlmaven.com/videos/oop-with-moo">http://perlmaven.com/videos/oop-with-moo</a>.</em>。）另外，Moose
还有一个简化版本，叫做 <em>Role::Tiny</em>
的模块，可以理解为新概念的 Moose 简餐。</p>
<p class="indent">在下面额度例子中，我们展示了如何用 <em>Moose::Role</em>
来创建角色。在这个例子中，我们定义了一个名为
<em>Radius</em> 的包。类的名字叫做
<em>Shape::Circle</em>。这里的 <em>Circle</em> 类有一个
<em>color</em> 属性，和一个 <em>calculate_area</em>
方法。为了计算圆的面积，我们必须知道半径。如果我们想要为
<em>Circle</em> 类编写 <em>setRadius</em>
方法的话，那么对于球体或者圆锥体对象，还是要再次提供设置半径的机制。如果我们想要通过继承树来解决这个问题的话，我们可能会描述
<em>Circle</em> 是 <em>Shape</em> 的特例，而 <em>Rectangle</em>
虽然是 <em>Shape</em> 的特例，但是只有 <em>Circle</em>
有半径概念。所以，如果通过角色来解决这个问题，就要容易的多。任何有半径概念的类都可以共享
<em>Radius</em> 角色，确保它提供了 <em>setRadius</em> 和
<em>getRadius</em> 方法，或者最起码确保模块中有
<em>setRadius</em> 方法。否则的话，Perl 就会报出一场。通过
<em>Moose::Role</em> 模块，我们可以创建一个类似常规模块的
<em>.pm</em>
文件，定义一个角色包，其中指定的属性和方法必须由客户模块来“消化”。Moose
的角色不是类，也不能实例化，他们就是简单的角色而已。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa24"/>例 14.24</p>
<p class="codelink1"><a id="p14exa24" href="ch14_images.html#p14exa24a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;package Radius;<br/><br/>2&#160;&#160;<span class="EmpStrong">use
Moose::Role</span>;&#160;&#160;&#160;# <span class="EmpItalic">Automatically
turns on strict and warnings</span><br/><br/>3&#160;&#160;has 'radius' =&gt; (&#160;&#160;# <span
class="EmpItalic">Attributes and accessors</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;is =&gt; 'rw',<br/>&#160;&#160;&#160;&#160;&#160;&#160;isa =&gt; 'Int',<br/>&#160;&#160;&#160;&#160;&#160;&#160;required =&gt; 1,<br/>&#160;&#160;&#160;)<br/>&#160;&#160;&#160;1;<br/><br/>4&#160;&#160;package Shape::Circle;<br/>&#160;&#160;&#160;use Math::Trig;<br/>5&#160;&#160;<span class="EmpStrong">use Moose;</span><br/>&#160;&#160;&#160;<span class="EmpStrong">with 'Radius'</span>;&#160;&#160;#
<span class="EmpItalic">Radius is a Role</span><br/><br/>6&#160;&#160;has 'color'=&gt;(&#160;&#160;# <span
class="EmpItalic">Define</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;is =&gt; 'rw',<br/>&#160;&#160;&#160;&#160;&#160;&#160;isa =&gt; 'Str',<br/>&#160;&#160;&#160;&#160;&#160;&#160;default =&gt; 'blue'<br/>&#160;&#160;&#160;);<br/><a id="page_498"/>7&#160;&#160;sub calculate_area{&#160;&#160;# <span
class="EmpItalic">Define method for Circle uses radius</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $area=$self-&gt;{'radius'} ** 2 * pi;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $area;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;package main;<br/>&#160;&#160;&#160;use Data::Dumper;<br/><br/>8&#160;&#160;<span class="EmpStrong">my $c1=Shape::Circle-&gt;new('radius'
=&gt; 6);</span>&#160;&#160;# <span class="EmpItalic">Required
argument</span><br/>9&#160;&#160;print Dumper $c1;&#160;&#160;# <span class="EmpItalic">See the
new Circle object</span><br/>10 <span
class="EmpStrong">$c1-&gt;radius(3);</span>&#160;&#160;&#160;&#160;# <span
class="EmpItalic">radius is a setter</span><br/>11 print "The radius is ", <span
class="EmpStrong">$c1-&gt;radius;</span>&#160;&#160;# <span
class="EmpItalic">radius is a getter</span><br/>12 printf "The area is %.2f\n ",&#160;&#160;<span
class="EmpStrong">$c1-&gt;calculate_area;</span><br/>13 print Dumper $c1;<br/><br/>(Output)<br/>9&#160;&#160;$<span class="EmpItalic">VAR1 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'color' =&gt; 'blue',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'radius' =&gt; 6</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'Shape::Circle' );</span><br/>11 <span class="EmpItalic">The radius is 3</span><br/>12 The area is 28.27<br/>13 <span class="EmpItalic">$VAR1 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'color' =&gt; 'blue',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'radius' =&gt; 3</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'Shape::Circle' );</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里的 <em>Radius.pm</em> 其实是一个 Moose
角色。它可以被其他需要半径的类来使用（或者说被消化）。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这里的 <em>Moose::Role</em> 其实是 Moose
的扩展模块。如果你的 Perl 版本是早于 5.16，那么 Moose
是需要单独下载的。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里的角色中设置了一个叫做 <em>radius</em>
的属性，它的值应该是整数，是可读写的（<em>rw</em>）。对于消化这个角色的类的构造器来说，提供半径也是必须的。当类消化角色的时候，角色中所有的方法和属性都被添加到类里面去了，好像类自己定义了它们一样。Moose
会自动为消化它的类创建构造器，以及属性的存取方法（名为
<em>radius</em>）。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里声明了 <em>Shape::Circle</em> 类。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这个 <em>Shape::Circle</em> 类将要消化
<em>Radius</em> 角色。这里的 <em>with</em>
函数用来将角色载入当前类。现在这个类将会获取
<em>Radius</em> 角色引入的半径属性。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 为 <em>Circle</em> 定义了一个 <em>color</em>
属性。这个属性是可读写的（<em>rw</em>）字符串（<em>Str</em>），默认的值是
<em>blue</em>。</p>
<p class="sb-indenthangingN"><a id="page_499"/><strong>7.</strong> 这里的 <em>calculate_area</em>
方法使用了 <em>radius</em>
属性（从角色消化而来），以及来自 <em>Math::Trig</em> 的
<em>pi</em> 函数，用来计算圆形的面积。</p>
<p class="sb-indenthangingN"><strong>8.</strong> Moose 提供了 <em>new</em>
构造器，用来创建新的祝福过的对象。用户调用 <em>new</em>
的时候要带上半径作为参数。这是角色在第三行定义
<em>radius</em> 属性的时候规定的：<em>required=&gt;1</em>;。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 这里用 <em>Dumper</em>
来打印新创建的对象和属性。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 这里将半径设为 3。Moose
根据角色的定义，自动为 <em>radius</em>
属性创建了一个同名的设置方法。</p>
<p class="sb-indenthangingN1"><strong>11.</strong> Moose 同样创建了一个读取方法，名为
<em>radius</em>，用来读取半径的大小。</p>
<p class="sb-indenthangingN1"><strong>12.</strong> 这里为 <em>$c1</em> 对象调用了
<em>calculate_area</em> 方法，来获取面积的大小。</p>
<p class="sb-indenthangingN1"><strong>13.</strong> 这里用 <em>Dumper</em> 来打印
<em>Shape::Circle</em> 对象。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec17">14.4.5 覆盖父类的方法，以及 <em>SUPER</em> 虚类</h4>
<p class="noindent">有的时候两个类可以有相同的方法名。如果衍生类的方法名和基类相同的话，那么就会优先于基类得到调用机会。想要跳过衍生类，直接调用基类的同名方法，就得提供完整的方法名（类名加上两个引号，然后是方法名）。不过，也可以用虚类
<em>SUPER</em>
来实现对父类方法的调用。比如，<em>$self</em>-<em>&gt;SUPER::setName</em>
调用的就是当前模块的父类的 <em>setName</em>
方法，跳过了当前类的 <em>setName</em>
方法。这个机制使得子类能对父类的方法进行包装或者修饰，从而形成自己的方法。也可以完全忽略自己的方法，而完全采用父类的方法。（你也可以从
CPAN 下载 <em>SUPER</em>
模块来对父类的寻找进行定制。）<sup><a id="ch14fn8a"
href="ch14.html#ch14fn8">8</a></sup></p>
</div>
<p class="footnote"><a id="ch14fn8" href="ch14.html#ch14fn8a">8</a>. 注意 <em>SUPER</em>
其实不是一个方法，而是一个虚拟包。关于它的文档可以在
<em>perlobj</em> 的 Method Invocation
那一节找到。另外，它的位置是相对于当前包来说的，而不是你调用的时候所处的包。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa25"/>例 14.25</p>
<p class="codelink1"><a id="p14exa25" href="ch14_images.html#p14exa25a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;<span class="EmpStrong">package Employee;</span>&#160;&#160;#
<span class="EmpItalic">Base class</span><br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>&#160;&#160;&#160;sub new
{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Employee's constructor is defined</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my %params = @_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = { Name=&gt;$params{"Name"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Salary=&gt;$params{"Salary"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;&#160;&#160;bless ($self, $class);<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/><a id="page_500"/>2&#160;&#160;<span class="EmpStrong">sub display</span>
{&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Instance method</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;foreach my $key ( @_){<br/>3&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "$key:
$self-&gt;{$key}\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>4&#160;&#160;&#160;&#160;&#160;print "The class using this display method is
", ref($self),"\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;<br/>&#160;&#160;&#160;---------------------------------------------------------------------<br/>5&#160;&#160;<span class="EmpStrong">package Salesman;</span>&#160;&#160;#
<span class="EmpItalic">Derived class</span><br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>6&#160;&#160;use base qw(<span class="EmpStrong">Employee);</span><br/>7&#160;&#160;<span class="EmpStrong">sub new</span>
{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Constructor in derived Salesman class</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my (%params) = @_;<br/>8&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $self =
$class-&gt;SUPER::new(%params);</span>&#160;&#160;# <span
class="EmpItalic">Call constructor</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">in base class</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;{Commission} =
$params{Commission};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;sub set_salary {<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;{Salary}=$self-&gt;{Salary} +
$self-&gt;{Commission};<br/>&#160;&#160;&#160;}<br/>9&#160;&#160;<span class="EmpStrong">sub display</span>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my @args = @_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "Stats for the Salesman\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "-" x 25, "\n";<br/>10&#160;&#160;&#160;&#160;<span
class="EmpStrong">$self-&gt;SUPER::display(@args);</span>&#160;&#160;# <span
class="EmpItalic">SUPER references the parent class</span><br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;<br/>&#160;&#160;&#160;&#160;-----------------------------------------<br/>&#160;&#160;&#160;# <span class="EmpItalic">User or Driver Program</span><br/>11 use Salesman;<br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>12 my $emp = new Salesman ( "Name", "Tom Savage",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Salary",
50000,&#160;&#160;&#160;# <span class="EmpItalic">Call to constructor</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Commission",
1500,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;$emp-&gt;set_Salary;&#160;&#160;# <span
class="EmpItalic">Call to the access method</span><br/>13 <span class="EmpStrong">$emp-&gt;display( "Name" , "Salary",
"Commission");</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Call Salesman's display method</span><br/><br/>(Output)<br/>9&#160;&#160;<span class="EmpItalic">Stats for the Salesman</span><br/>&#160;&#160;&#160;<span class="EmpItalic">-------------------------</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Name: Tom Savage</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Salary: 51500</span><br/>&#160;&#160;&#160;<span class="EmpItalic">The class using this display
method is Salesman</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_501"/>Explanation</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里声明了 <em>Employee</em>
类。它包含了一个叫做 <em>new</em>
的构造器方法，以及一个实例方法名为 <em>display</em>。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这里定义了 <em>Employee</em> 类的
<em>display</em> 方法。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里显示了员工的属性。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里用 <em>ref</em>
函数返回了对象所属的类名。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里声明了 <em>Salesman</em> 类。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 它是一个衍生类，基类是 <em>Employee</em>。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里定义的是 <em>Saleman</em> 的析构器。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 这里通过 <em>SUPER</em> 虚类来调用
<em>Employee</em> 类的 <em>new</em> 方法。它能将 <em>Salesman</em>
发送到 <em>Employee</em>
类中，同时附带上那些初始化需要的属性，然后经过祝福得到一个新的
<em>Salesman</em> 对象。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 这是 <em>Salesman</em> 类的 <em>display</em>
方法。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 这里通过使用虚类 <em>SUPER</em>
这个名字，使得对 <em>display</em> 方法的调用转向了父类
<em>Employee</em> 中的同名方法。</p>
<p class="sb-indenthangingN1"><strong>11.</strong> 这里是用户代码，它载入了 <em>Salesman</em>
模块。</p>
<p class="sb-indenthangingN1"><strong>12.</strong> 这里创建了一个新的 <em>Salesman</em>
对象，不过是通过 <em>SUPER</em> 虚类来实现的。</p>
<p class="sb-indenthangingN1"><strong>13.</strong> 这里调用了 <em>display</em> 方法。因为
<em>Salesman</em> 类中就有一个 <em>display</em>
方法，因此它会优先得到执行机会。</p>
<hr/></div>
<div class="heading">
<h3 id="ch14lev1sec5">14.5 老旧文档，为模块撰写文档</h3>
<p class="noindent">对于类的用户来说，模块作者最重要的一个任务就是：认真的书写模块的使用手册。这也被称为公布调用接口。不论是一个面向对象的类还是一个过程化的模块，关于如何调用功能的用户手册（比如方法的参数列表）都是必不可少的。而且，哪怕是未来对功能的实现进行了改进，公开的调用接口也不应该轻易变动。</p>
</div>
<p class="indent">Perl 5 为了书写模块文档而提供了一个叫做 <em>pod</em>
的文档格式。这个 <em>pod</em> 系列的指令集，类似于 HTML
标签或者 <em>nroff</em>
指令，可以嵌入于代码文件中。这种被戏称为老旧文档的格式，一旦经过
Perl
的工具指令的处理，就可以翻译成许多种著名的文档格式。维基百科是这样描述
<em>pod</em> 格式的。<sup><a id="ch14fn9a"
href="ch14.html#ch14fn9">9</a></sup></p>
<p class="footnote"><a id="ch14fn9" href="ch14.html#ch14fn9a">9</a>. 参见 <em><a
href="http://en.wikipedia.org/wiki/Plain_Old_Documentation#Example">http://en.wikipedia.org/wiki/Plain_Old_Documentation#Example</a>.</em></p>
<div class="fig-heading">
<div class="image"><a id="page_502"/><a id="ch14fig06"/><img src="graphics/14fig06.jpg" alt="Image"/></div>
<p class="fig-caption"><strong>图 14.6</strong> 维基百科的 <em>pod</em> 例子</p>
</div>
<div class="heading">
<h4 id="ch14lev2sec18">14.5.1 <em>pod</em> 文件</h4>
<p class="noindent">如果你钻研 Perl
的标准库的话，就会发现许多文档，用于描述模块的功能和使用方法。（你可以从输入
<em>perldoc perlpod</em>
开始。）这些文档要么与程序混合在一起，要么是附加在程序的末尾的
<em>_ _END_ _</em> 标记之后。这些文档全都可以统称为
<em>pod</em>，也就是老旧文档的意思。所谓 <em>pod</em>
文件，其实就是那些在纯文本（utf-8）文件中嵌入的特殊标记指令。这些标记可以被类似
<em>pod2html</em>、<em>pod2latex</em>、<em>pod2text</em> 或
<em>pod2man</em>
的工具程序翻译成各种文档格式。宗旨就是通过简单的文档格式来获取多种多样的文档呈现效果。其实
UNIX 的 <em>man</em> 格式就是一个用 <em>nroff</em>
指令来编写的文档格式。因为 <em>pod</em>
指令的存在，如今在脚本当中嵌入可以翻译为文本、HTML、LaTex
或者 <em>nroff</em> 格式文档变得十分简单。</p>
</div>
<p class="indent">任何的 <em>pod</em>
文档都是用等号（<em>=</em>）开头的。对于 <em>pod</em>
翻译器来说，等号开头的 <em>pod</em>
指令有着特殊的意义。而指令的结尾则是一个空行。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa26"/>例 14.26</p>
<p class="codelink1"><a id="p14exa26" href="ch14_images.html#p14exa26a">Click here to view code
image</a></p>
<p class="pre1">(The standard Perl library, under the subdirectory Math.)<br/><br/>=<span class="EmpStrong">head1</span> NAME<br/><br/>Math::BigFloat - Arbitrary length float math package<br/><br/>=<span class="EmpStrong">head1</span> SYNOPSIS<br/><br/>&#160;&#160;use Math::BigFloat;<br/>&#160;&#160;$f = Math::BigFloat-&gt;new($string);<br/><br/>&#160;&#160;$f-&gt;fadd(NSTR) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;addition<br/>&#160;&#160;$f-&gt;fsub(NSTR) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;subtraction<br/>&#160;&#160;$f-&gt;fmul(NSTR) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;multiplication<br/>&#160;&#160;$f-&gt;fdiv(NSTR[,SCALE]) returns
NSTR&#160;&#160;&#160;&#160;&#160;division to SCALE places<br/>&#160;&#160;$f-&gt;fneg() return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;negation<br/>&#160;&#160;$f-&gt;fabs() return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;absolute
value<br/>&#160;&#160;$f-&gt;fcmp(NSTR) return
CODE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;compare
undef,&lt;0,=0,&gt;0<br/>&#160;&#160;$f-&gt;fround(SCALE) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;round
to SCALE digits<br/>&#160;&#160;$f-&gt;ffround(SCALE) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;round at
SCALEth place<br/>&#160;&#160;$f-&gt;fnorm() return
(NSTR)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;normalize<br/>&#160;&#160;$f-&gt;fsqrt([SCALE]) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sqrt to
SCALE places<br/><br/>(Here is the documentation found at the end of the <span
class="EmpItalic">BigFloat.pm</span> module in <span
class="EmpStrong">=head1</span> DESCRIPTION<br/><br/>All basic math operations are overloaded if you declare your big<br/>floats as<br/><br/>&#160;&#160;&#160;$float = new Math::BigFloat
"2.123123123123123123123123123123123";<br/><br/>=over 2<br/><br/><span class="EmpStrong">=item</span> number format<br/><br/>canonical strings have the form /[+-]\d+E[+-]\d+/ . Input values can<br/>have inbedded whitespace.<br/><br/><a id="page_504"/><span class="EmpStrong">=item</span> Error returns 'NaN'<br/><br/>An input parameter was "Not a Number" or divide by zero or sqrt of<br/>negative number.<br/><br/><span class="EmpStrong">=item</span> Division is computed to<br/><br/>C&lt;max($div_scale,length(dividend)+length(divisor))&gt; digits by default.<br/>Also used for default sqrt scale.<br/><br/>=back<br/><br/><span class="EmpStrong">=head1</span> BUGS<br/><br/>The current version of this module is a preliminary version of the<br/>real thing that is currently (as of perl5.002) under development.<br/><br/><span class="EmpStrong">=head1</span> AUTHOR<br/><br/>Mark Biggar<br/><br/>=cut</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sidebarpara">之前的文本就是一个 <em>pod</em>
文档。文档中许多行都是用等号开头的，等号后面是一个
<em>pod</em>
指令，然后就是一个空行，再跟着就是一段文本。Perl
提供的翻译程序可以读入 <em>pod</em>
文件，然后翻译成易于阅读的纯文本、HTML、LaTeX 或者
<em>nroff</em> 文件。下一节会介绍这些 <em>pod</em>
文件翻译器。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec19">14.5.2 <em>pod</em> 指令</h4>
<p class="noindent">在文本中嵌入 <em>pod</em>
指令是非常简单的。命令开始于任何一行的起点，总是用类似
<em>=pod</em>（或者其他的 <em>pod</em>
指令）开始的，而且都是用 <em>=cut</em> 终止的。从
<em>=pod</em> 到 <em>=cut</em>
之间的文本对编译器来说都是被忽略的（好像注释行一样）。这些指令比注释强的地方在于，它们可以用于创建各种格式的文本（比如粗体、斜体、纯文本、缩进或者标题行等等）。</p>
</div>
<div class="tab-heading">
<div class="image"><a id="ch14tab03"/><img src="graphics/14tab03.jpg" alt="Image"/></div>
<p class="tab-caption"><strong>表 14.3</strong> <em>pod</em> 指令集</p>
</div>
<div class="heading">
<h5 id="ch14lev3sec14">检查 pod 指令</h5>
<p class="noindent">为了检查 <em>pod</em> 指令书写的正确性，你可以使用 Perl
提供的 <em>podchecker</em>
工具。首先，要正确定位模块所在的路径，可以输入这个命令：</p>
</div>
<p class="pre"><span class="EmpStrong">perldoc -l</span> Module.pm</p>
<p class="noindent">然后输入</p>
<p class="pre"><span class="EmpStrong">podchecker</span> path/Module.pm</p>
<p class="noindent">最好是它这样返回：</p>
<p class="pre">path/Module.pm <span class="EmpStrong">pod syntax OK.</span></p>
<div class="heading">
<h4 id="ch14lev2sec20"><a id="page_506"/>14.5.3 怎样使用 <em>pod</em> 翻译器</h4>
<p class="noindent">Perl 发行版中带来的 <em>pod</em> 翻译器，它们都存放在主
Perl 目录下的 <em>bin</em> 子目录中，比如
<em>/usr/bin/perl5/bin</em> 就是一个常见的位置。</p>
</div>
<p class="indent">主要的四个翻译器是</p>
<p class="indenthangingB">&#8226; <em>pod2html</em>（HTML 翻译器）</p>
<p class="indenthangingB">&#8226; <em>pod2text</em>（纯文本翻译器）</p>
<p class="indenthangingB">&#8226; <em>pod2man</em>（<em>nroff</em> 翻译器，就是 UNIX
<em>man</em> 文档格式）</p>
<p class="indenthangingB">&#8226; <em>pod2latex</em>（LaTex 翻译器）</p>
<p class="indent">最简单的使用方法就是把他们都拷贝到你自己的目录中去。比如：</p>
<p class="codelink"><a id="p506pro01" href="ch14_images.html#p506pro01a">Click here to view code
image</a></p>
<p class="pre">$ cp /usr/bin/perl5/bin/pod2text ~/</p>
<p class="noindent">你也可以把工具脚本拷贝到同一个目录中：</p>
<p class="codelink"><a id="p506pro02" href="ch14_images.html#p506pro02a">Click here to view code
image</a></p>
<p class="pre">$ cp /usr/bin/perl5/lib/BigFloat.pm ~/</p>
<p class="indent">现在，如果你列出自己的目录当中的内容，就能看到
<em>pod</em> 翻译器和样例模块。</p>
<p class="pre">$ ls<br/>BigFloat.pm<br/>pod2text</p>
<div class="heading">
<h4 id="ch14lev2sec21">14.5.4 把 <em>pod</em> 文档翻译成纯文本</h4>
<p class="noindent">对于文本终端用户来说，最简单的翻译 <em>pod</em>
文档的指令就是 Perl 内置的 <em>perldoc</em>
命令。它可能不在你的执行路径中，但是通常就在 Perl
的执行路径 <em>bin</em> 目录中。下面的指令可以展示
<em>BigFloat.pm</em> 模块内置的文档：</p>
</div>
<p class="pre">perldoc Math::BigFloat</p>
<p class="indent">另一个翻译 <em>pod</em>
指令到文本文件的方式就是用翻译器来处理模块文件，并且将产生的文本转储于文件中。如果你没有进行文件转储，那么输出就会发送到屏幕。</p>
<p class="codelink"><a id="p506pro03" href="ch14_images.html#p506pro03a">Click here to view code
image</a></p>
<p class="pre">$ pod2text BigFloat.pm &gt; BigFloat.Text<br/>$ cat BigFloat.Text&#160;&#160;(The output file after pod commands have been<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;translated
into text.)<br/><br/>NAME<br/>&#160;&#160;&#160;&#160;Math::BigFloat - Arbitrary length float math package<br/><br/>SYNOPSIS<br/>&#160;&#160;&#160;&#160;&#160;&#160;use Math::BigFloat;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f = Math::BigFloat-&gt;new($string);<br/><br/><a id="page_507"/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fadd(NSTR)
return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;addition<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fsub(NSTR) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;subtraction<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fmul(NSTR) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;multiplication<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fdiv(NSTR[,SCALE])&#160;&#160;&#160;returns
NSTR&#160;&#160;&#160;division to SCALE places<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fneg() return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;negation<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fabs() return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;absolute
value<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fcmp(NSTR) return
CODE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;compare
undef,&lt;0,=0,&gt;0<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fround(SCALE) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;round
to SCALE digits<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;ffround(SCALE) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;round at
SCALEth place<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fnorm() return
(NSTR)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;normalize<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fsqrt([SCALE]) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sqrt to
SCALE places<br/><br/>DESCRIPTION<br/>&#160;&#160;&#160;&#160;All basic math operations are overloaded if you
declare your big<br/>&#160;&#160;&#160;&#160;floats as<br/><br/>$float=newMath::BigFloat"2.123123123123123123123123123123123";<br/><br/>&#160;&#160;&#160;&#160;&#160;number format<br/>&#160;&#160;&#160;&#160;&#160;canonical strings have the form
/[+-]\d+E[+-]\d+/ . Input<br/>&#160;&#160;&#160;&#160;&#160;values can have inbedded whitespace.<br/><br/>&#160;Error returns 'NaN'<br/>&#160;&#160;&#160;&#160;&#160;&#160;An input parameter was "Not a Number" or
divide by zero or<br/>&#160;&#160;&#160;&#160;&#160;&#160;sqrt of negative number.<br/><br/>&#160;Division is computed to<br/>&#160;&#160;&#160;&#160;&#160;&#160;`max($div_scale,length(dividend)+length(divisor))'
digits by<br/>&#160;&#160;&#160;&#160;&#160;&#160;default. Also used for default sqrt
scale.<br/><br/>BUGS<br/>&#160;&#160;&#160;&#160;The current version of this module is a preliminary
version of<br/>&#160;&#160;&#160;&#160;the real thing that is currently (as of perl5.002)
under<br/>&#160;&#160;&#160;&#160;development.<br/><br/>AUTHOR<br/>&#160;&#160;&#160;&#160;Mark Biggar</p>
<div class="heading">
<h4 id="ch14lev2sec22">14.5.5 将 <em>pod</em> 转化成 HTML</h4>
<p class="noindent">要产生 HTML 格式的文档，需要使用 <em>pod2html</em> 指令：</p>
</div>
<p class="codelink"><a id="p507pro01" href="ch14_images.html#p507pro01a">Click here to view code
image</a></p>
<p class="pre">$ pod2html BigFloat.pm BigFloat.pm.html</p>
<p class="indent">这里 <em>pod2html</em> 翻译器会创建一个名为
<em>BigFloat.pm.html</em>
的文件。于是你可以打开浏览器，用【文件】【打开】菜单或者【CTRL+O】热键来打开
<em>BigFloat.pm.html</em> 文件。如果直接输入 URL
的话，应该是类似 <em>file:///yourdirectory
path/BigFloat.pm.html</em> 这样的地址。<sup><a id="ch14fn10a"
href="ch14.html#ch14fn10">10</a></sup></p>
<p class="footnote"><a id="ch14fn10"
href="ch14.html#ch14fn10a">10</a>.
如果你执行翻译指令的时候看到了很奇怪的警告信息，那么很可能是因为
<em>.pm</em> 文件当中有链接文档，但是 <em>pod</em>
翻译器无法定位那个文档。</p>
<div class="fig-heading">
<div class="image"><a id="page_508"/><a id="ch14fig07"/><img src="graphics/14fig07.jpg" alt="Image"/></div>
<p class="fig-caption"><strong>图 14.7</strong> 通过浏览器来查看 Perl 文档</p>
</div>
<div class="heading">
<h3 id="ch14lev1sec6">14.6 使用 Perl 标准库中的对象</h3>
<p class="noindent">在<a href="ch13.html#ch13">第 13 章
模块、封包和发布！</a>中，我们首先查看了 Perl 5.16
发行包中的标准库。在其中有许多 Perl
模块以及子目录中的附加模块。<a href="ch13.html#ch13">第 13
章</a>的例子主要覆盖的是那些非面向对象的模块。所以，主要的编程接口都是子程序，而非方法。现在，你已经了解了
Perl
是如何处理对象和方法的，下面的例子就会展示那些使用了面向对象技术的模块。</p>
</div>
<div class="heading">
<h4 id="ch14lev2sec23"><a id="page_509"/>14.6.1 一个 Perl 标准库中的面向对象模块</h4>
<p class="noindent">下面介绍的 <em>BigFloat</em>
模块，就是一个面向对象模块，主要的功能是提供任意精度的浮点数计算。它能支持
<em>/[+-]\d*\.?\d*E[+-]\d+/</em> 这样的数据格式。当你得到 NaN
这样的结果时，就意味着一个无法处理的数值，比如任何数字除以零的结果，或者是对负数进行平方根计算的结果。这个
<em>BigFloat</em> 模块使用了 <em>overload</em>
模块提供的功能，从而能够让你重定义 Perl
内置的运算符的功能。在下面的例子中，操作符是用键的形式来表达的，而相应的方法则是用键值的形式来表达。（可以参考
Perl 标准库当中的 <em>overload.pm</em> 了解更多。）</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa27"/>例 14.27</p>
<p class="codelink1"><a id="p14exa27" href="ch14_images.html#p14exa27a">Click here to view code
image</a></p>
<p class="pre1">(The File: <span class="EmpItalic">BigFloat.pm</span>)<br/><br/>1&#160;&#160;package Math::BigFloat;<br/>2&#160;&#160;use Math::BigInt;<br/><br/>&#160;&#160;&#160;use Exporter;&#160;&#160;# <span class="EmpItalic">Just
for use to be happy</span><br/>&#160;&#160;&#160;@ISA = (Exporter);<br/>3&#160;&#160;<span class="EmpStrong">use overload</span><br/>4&#160;&#160;'+'&#160;&#160;&#160;&#160;=&gt;&#160;&#160;sub {new
Math::BigFloat &#38;fadd},<br/>&#160;&#160;&#160;'-'&#160;&#160;&#160;&#160;=&gt;&#160;&#160;sub {new
Math::BigFloat<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$_[2]?
fsub($_[1],${$_[0]}) : fsub(${$_[0]},$_[1])},<br/>&#160;&#160;&#160;'&lt;=&gt;'&#160;&#160;=&gt;&#160;&#160;sub {new
Math::BigFloat<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$_[2]?
fcmp($_[1],${$_[0]}) : fcmp(${$_[0]},$_[1])},<br/>&#160;&#160;&#160;'cmp'&#160;&#160;=&gt;&#160;&#160;sub {new Math::BigFloat<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$_[2]?
($_[1] cmp ${$_[0]}) : (${$_[0]} cmp $_[1])},<br/>&#160;&#160;&#160;'*'&#160;&#160;&#160;&#160;=&gt;&#160;&#160;sub {new
Math::BigFloat &#38;fmul},<br/>&#160;&#160;&#160;'/'&#160;&#160;&#160;&#160;=&gt;&#160;&#160;sub {new
Math::BigFloat<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$_[2]?
scalar fdiv($_[1],${$_[0]}) :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;scalar
fdiv(${$_[0]},$_[1])},<br/>&#160;&#160;&#160;'neg'&#160;&#160;=&gt;&#160;&#160;sub {new Math::BigFloat
&#38;fneg},<br/>&#160;&#160;&#160;'abs'&#160;&#160;=&gt;&#160;&#160;sub {new Math::BigFloat
&#38;fabs},<br/>&#160;&#160;&#160;qw(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;""&#160;&#160;&#160;stringify<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0+&#160;&#160;&#160;numify)&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Order of arguments unsignificant</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;;<br/><br/>5&#160;&#160;<span class="EmpStrong">sub new</span> {<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($class) = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($foo) = fnorm(shift);<br/>6&#160;&#160;&#160;&#160;&#160;panic("Not a number initialized to
Math::BigFloat")<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if
$foo eq "NaN";<br/>7&#160;&#160;&#160;&#160;&#160;bless \$foo, $class;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">&lt; Methods continue
here. Module was too long to put here&gt;</span><br/><a id="page_510"/>&#160;&#160;&#160;# <span
class="EmpItalic">Addition</span><br/>8&#160;&#160;<span class="EmpStrong">sub fadd</span> { #(fnum_str, fnum_str)
return fnum_str<br/>&#160;&#160;&#160;&#160;&#160;&#160;local($x,$y) =
(fnorm($_[$[]),fnorm($_[$[+1]));<br/>&#160;&#160;&#160;&#160;&#160;&#160;if ($x eq 'NaN' || $y eq 'NaN') {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NaN';<br/>&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;local($xm,$xe) =
split('E',$x);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;local($ym,$ye) =
split('E',$y);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;($xm,$x e,$ym,$ye) =
($ym,$ye,$xm,$xe) if ($xe &lt; $ye);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#38;norm(Math::BigInt::badd($ym,$xm.('0'
x ($xe-$ye))),$ye);<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;<span class="EmpItalic">&lt; Methods continue
here&gt;</span><br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">divisionbb</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">args are dividend, divisor,
scale (optional)</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">result has at most max(scale,
length(dividend),</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">length(divisor)) digits</span><br/>9&#160;&#160;<span class="EmpStrong">sub
fdiv</span>&#160;&#160;&#160;&#160;#<span class="EmpItalic">(fnum_str,
fnum_str[,scale]) return fnum_str</span><br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;local($x,$y,$scale) = (fnorm($_[$[]),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fnorm($_[$[+1]),$_[$[+2]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;if ($x eq 'NaN' || $y eq 'NaN' || $y eq
'+0E+0') {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'NaN';<br/>&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;local($xm,$xe) =
split('E',$x);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;local($ym,$ye) =
split('E',$y);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$scale = $div_scale if
(!$scale);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$scale = length($xm)-1
if (length($xm)-1 &gt; $scale);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$scale = length($ym)-1
if (length($ym)-1 &gt; $scale);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$scale = $scale +
length($ym) - length($xm);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#38;norm(&#38;round(Math::BigInt::bdiv($xm.('0'
x $scale),$ym),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$ym),$xe-$ye-$scale);<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里声明了 <em>BigFloat</em> 类。这里的
<em>BigFloat.pm</em> 文件存放在 Perl 标准库目录中的
<em>Math</em> 子目录下。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这里 <em>BigFloat</em> 类会用到 <em>BigInt</em>
模块的功能。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 载入 <em>overload</em> 之后，我们就可以修改
Perl 内置操作符的功能。比如，对于 <em>BigFloat</em>
类来说，操作符 <em>+</em>
可以是一个键，而它的值则是一个匿名子程序，其逻辑是创建一个对象，然后调用
<em>fadd</em> 子程序完成加法。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里覆盖了 <em>+</em>
操作符的功能，原理之前已经解释了。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这是 <em>BigFloat</em> 的构造器方法。</p>
<p class="sb-indenthangingN"><a id="page_511"/><strong>6.</strong>
如果某个值不能转化成数字的话，那么就打印这段错误信息。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里将对象祝福成类的成员。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 这是真正完成加法的子程序。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 这是完成除法的子程序。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec24">14.6.2 使用 Perl 标准库中的对象模块</h4>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa28"/>例 14.28</p>
<p class="codelink1"><a id="p14exa28" href="ch14_images.html#p14exa28a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;use warnings;<br/>2&#160;&#160;<span class="EmpStrong">use Math::BigFloat;</span>&#160;&#160;#
<span class="EmpItalic">BigFloat.pm is in the Math directory</span><br/><br/>3&#160;&#160;my $number = "000.95671234e-21";<br/>4&#160;&#160;my <span class="EmpStrong">$mathref =
Math::BigFloat-&gt;new("$number");</span>&#160;&#160;# <span
class="EmpItalic">Create the object</span><br/><br/>5&#160;&#160;print "\$mathref is in class ", <span
class="EmpStrong">ref($mathref)</span>, "\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Where is the object</span><br/><br/>6&#160;&#160;print <span class="EmpStrong">$mathref-&gt;fnorm()</span>,
"\n";&#160;&#160;# <span class="EmpItalic">Use methods from the class</span><br/><br/>7&#160;&#160;print "The sum of $mathref + 500 is: ", <span
class="EmpStrong">$mathref-&gt;fadd("500"),</span> "\n";<br/>8&#160;&#160;print "Division using <span class="EmpStrong">overloaded
operator: ", $mathref / 200.5,</span> "\n";<br/>9&#160;&#160;print "Division using fdiv method:", <span
class="EmpStrong">$mathref-&gt;fdiv("200.5"),</span> "\n";<br/><br/>10 print "Enter a number ";<br/>&#160;&#160;&#160;chomp($numstr = &lt;STDIN&gt;);<br/><br/>11 if ( <span class="EmpStrong">$mathref-&gt;fadd($numstr) eq "NaN"</span>
){<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "You didn't enter a number.\n"};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;# <span class="EmpItalic">Return value of NaN means the
string is not a number,</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">or you divided by zero, or you
took the square root</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">of a negative number.</span><br/><br/>(Output)<br/>5&#160;&#160;<span class="EmpItalic">$mathref is in class
Math::BigFloat</span><br/>6&#160;&#160;<span class="EmpItalic">+95671234E-29</span><br/>7&#160;&#160;<span class="EmpItalic">The sum of
.00000000000000000000095671234 + 500 is:</span><br/>&#160;&#160;&#160;<span
class="EmpItalic">+50000000000000000000000095671234E-29</span><br/>8&#160;&#160;<span class="EmpItalic">Division using overloaded
operator:</span><br/>&#160;&#160;&#160;<span
class="EmpItalic">.000000000000000000000004771632618453865336658354114713216957606</span><br/>9&#160;&#160;<span class="EmpItalic">Division using fdiv method:</span><br/>&#160;&#160;&#160;<span
class="EmpItalic">+4771632618453865336658354114713216957606E-63</span><br/>10 <span class="EmpItalic">Enter a number hello</span><br/>11 <span class="EmpItalic">You didn't enter a number.</span></p>
<hr/></div>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_512"/>代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 打开 <em>warnings</em> 选项。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这里通过 <em>use</em> 函数来载入
<em>BigFloat.pm</em>
模块。因为这个模块文件是存放在库目录的 <em>Math</em>
子目录下的，所以载入的时候要在前面加上这个目录和两个冒号。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里对 <em>$number</em>
赋予一个高精度的数值（<em>e</em> 的幂值）。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 现在真正通过 <em>BigFloat</em>
构造器方法创建一个对象引用，并存入 <em>$mathref</em> 中。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里的 <em>ref</em> 函数能返回类的名字。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里调用了 <em>fnorm</em>
方法来对原先存放在 <em>$number</em>
中的数值进行规范化。对前置的多余的零进行了清理。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 用 <em>fadd</em> 方法来给这个数加了
<em>500</em>。</p>
<p class="sb-indenthangingN"><strong>8.</strong>
这次使用了操作符覆盖的方法来进行除法运算，这里的
<em>/</em> 操作符被指向一个名为 <em>fdiv</em>
的类方法。你可以参考<a href="ch14.html#ch14exa26">例
14.26</a>中的 <em>BigFloat.pm</em> 代码。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 这次又直接用 <em>fdiv</em>
方法来进行除法运算，没有使用操作符来完成。输出稍稍有所不同。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 用户被提示输入一个数字。</p>
<p class="sb-indenthangingN1"><strong>11.</strong> 如果 <em>fadd</em> 方法返回的数值是
<em>NaN</em>（不是一个数值），就打印这行信息。这样可以确保用户输入的是一个有效的数值。</p>
<hr/></div>
<div class="heading">
<h3 id="ch14lev1sec7">14.7 应知应会</h3>
<p class="indenthangingN"><strong>1.</strong> 面向对象是什么意思？</p>
</div>
<p class="indenthangingN"><strong>2.</strong> 包和类有什么区别？</p>
<p class="indenthangingN"><strong>3.</strong> 什么是方法？</p>
<p class="indenthangingN"><strong>4.</strong> 类方法的第一个参数是什么？</p>
<p class="indenthangingN"><strong>5.</strong> 什么函数是用来产生对象的？</p>
<p class="indenthangingN"><strong>6.</strong> 什么是属性？</p>
<p class="indenthangingN"><strong>7.</strong> 什么是实例方法？</p>
<p class="indenthangingN"><strong>8.</strong> Perl 语言有没有自己的 <em>private</em>
关键字？</p>
<p class="indenthangingN"><strong>9.</strong> 你如何命名一个类？类要存放在哪里？</p>
<p class="indenthangingN1"><strong>10.</strong> 类方法调用，这个说法是什么意思？</p>
<p class="indenthangingN1"><strong>11.</strong> 什么是多态？</p>
<p class="indenthangingN1"><a id="page_513"/><strong>12.</strong> 请问 <em>@ISA</em>
数组的用处是什么？</p>
<p class="indenthangingN1"><strong>13.</strong> 什么是衍生类？</p>
<p class="indenthangingN1"><strong>14.</strong> 什么是 <em>SUPER</em> 类？</p>
<p class="indenthangingN1"><strong>15.</strong> 什么是闭包？</p>
<p class="indenthangingN1"><strong>16.</strong> 什么是角色？</p>
<p class="indenthangingN1"><strong>17.</strong> 什么是 Moose？</p>
<p class="indenthangingN1"><strong>18.</strong> 怎样给类编写文档？</p>
<p class="indenthangingN1"><strong>19.</strong> 什么是 <em>pod</em> 翻译器？</p>
<p class="indenthangingN1"><strong>20.</strong> 请问 <em>pod</em> 指令是如何使用的？</p>
<div class="heading">
<h3 id="ch14lev1sec8">14.8 下一步是什么？</h3>
<p class="noindent"><a href="ch15.html#ch15">第十五章 Perl 连接 MySQL</a>专注于使用
Perl 来访问 MySQL
关系数据库系统（一个非常流行的、开源的、功能完整的关系数据库系统）。你会学到如何从
MySQL 客户端发送命令，以及如何使用 Perl 的 DBI
模块来发送同样的命令。</p>
</div>
<div class="heading">
<h3 id="ch14lev1sec9">练习 14：这一课的目标是什么？</h3>
<p class="indent"><strong>第一部分—对象简介</strong></p>
</div>
<p class="indenthangingN"><strong>1.</strong> 编写一个叫做 <em>Rightnow.pm</em>
的模块，其中有三个方法：</p>
<p class="indenthangingNA"><strong>a.</strong> 名为 <em>new</em> 的构造器方法。</p>
<p class="indenthangingNA"><strong>b.</strong> 一个名为 <em>set_time</em>
的方法，用来设置时间。使用的是 <em>localtime</em>
函数来获取时间。</p>
<p class="indenthangingNA"><strong>c.</strong> 一个名为 <em>print_time</em>
的方法用来打印时间。这个方法有一个参数用来控制打印的格式是军用时间还是标准时间。比如
<em>print_time(&#8220;Military&#8221;);</em>。</p>
<p class="indenthangingNA"><strong>d.</strong> 在另一个 Perl 脚本中使用 <em>Rightnow</em>
模块并建造一个相应的对象；并且调用它的
<em>print_time</em> 方法来打印如下的信息：</p>
<p class="pre2">Time now: 2:48:20 PM<br/>Time now: 14:48:20</p>
<p class="indent"><a id="page_514"/><strong>第二部分—对象进阶</strong></p>
<p class="indenthangingN"><strong>1.</strong> 为一个名为 <em>Student</em>
的类创建一个对象。<em>Student</em>
对象的属性会通过参数发送给构造器方法。<em>Student</em>
对象的属性包括三个：学生的 <em>name</em>，及其
<em>major</em> 科目，以及一系列正在学习的
<em>courses</em>。创建一个实例方法，名为
<em>show_student</em>，用来展示这个 <em>Student</em>
对象。类模块的用户代码则要创建两个学生对象并且逐个展示。</p>
<p class="indenthangingN"><strong>2.</strong> 为 <em>Student</em>
对象增加四个属性，比如学生的地址、学号、入学日期和学费。这样，学生的学籍档案看起来就像这样：</p>
<p class="indenthangingNP">Address: 140 Kennedy Drive,</p>
<p class="indenthangingNP">Luxembourg City, Luxembourg</p>
<p class="indenthangingNP">ID: 123A</p>
<p class="indenthangingNP">StartDate: 01/10/07</p>
<p class="indenthangingNP">Tuition: 5400.55</p>
<p class="indenthangingNP">现在你要怎么处理这些输入呢？如果构造器要处理这么多的信息，不如考虑创建一个存取方法名为
<em>set_student</em>。最后，你要用这个类来创建三个学生对象。</p>
<p class="indenthangingN"><strong>3.</strong>
创建两个新的存取方法，都带有参数。一个名为
<em>add_courses</em>，另一个名为
<em>drop_courses</em>。这两个方法允许用户给学生增加或减少参数中的课程。比如：</p>
<p class="indenthangingNP"><em>$obj&gt;add_courses([&#8220;C++&#8221;, &#8220;Java&#8221;]);</em></p>
<p class="indenthangingN"><strong>4.</strong>
现在你要是用一个类方法来跟踪学生的数量。每当一个新的学生入学时候，就增加相应的计数。在程序退出之前（通过
<em>END</em> 块来）打印出学生的总数。</p>
<p class="indenthangingN"><strong>5.</strong>
现在要将学生数据记录到文件中。数据格式是如下的行记录：</p>
<p class="codelink"><a id="p514pro01" href="ch14_images.html#p514pro01a">Click here to view code
image</a></p>
<p class="pre2">John Doe:14 Main St:3456IX:Math:Trigonometry,Calculus,French:<br/>01/01/06:4500</p>
<p class="indenthangingN"><strong>6.</strong>
创建另一个文件来记录学生的数量。每当程序启动时，都要从这个文件中读取学生数目。每当新学生入学时，要打印出
<em>Welcome, John D</em> 这样的欢迎信息。</p>
<p class="indent"><a
id="page_515"/><strong>第三部分—创建一个面向对象的模块</strong></p>
<p class="indenthangingN"><strong>1.</strong> 创建一个面向对象的模块 <em>Checking.pm</em>
。这个对象是关于帐目平衡的，而子程序则实际上是方法。构造器需要初始化最起码两个属性：<em>balance</em>
和 <em>account
number</em>。后面这个帐号信息会一参数的形式传给构造器。而余额则是从交易中算出来的，初始为零。当你创建交易文件时，需要在文件名中包含帐号。文件中包含着帐号、余额和日期。通过这个
<em>Checking</em> 模块来构造一台 ATM 机。</p>
<p class="indenthangingN"><strong>2.</strong> 请你构造两个以上的 <em>Checking</em>
对象来跟踪多个帐号。</p>
<p class="indent"><strong>第四部分—继承</strong></p>
<p class="indenthangingN"><strong>1.</strong> 创建一个 <em>Pet</em>
类，带有一个构造器和一个存取方法。构造器负责初始化宠物的属性，比如：</p>
<p class="indenthangingNP"><em>owner</em></p>
<p class="indenthangingNP"><em>name</em></p>
<p class="indenthangingNP"><em>gender</em></p>
<p class="indenthangingNA"><strong>a.</strong> 这个存取方法叫做
<em>eat()</em>。它的参数只有一个：宠物食物的类型。比如，狗粮的品牌是
Alpo。而狗这个类并没有定义自己的 <em>eat()</em>
方法，而是从父类继承。</p>
<p class="indenthangingNA"><strong>b.</strong> 创建两个从 <em>Pet</em>
继承的子类，比如一个类叫做 <em>Dog</em>，另一个叫做
<em>Cat</em>。它们都是用 <em>Pet</em>
的构造器来创建的，而且追加了它们自己的属性。他们都有自己的
<em>speak()</em> 方法，却没有定义自己的 <em>eat()</em> 方法。</p>
<p class="indenthangingN"><strong>2.</strong> 现在我们创建一个名为 <em>Bank.pm</em>
的基类，以及两个使用这个类的模块：<em>Checking</em> 和
<em>Savings</em>。</p>
<p class="indenthangingNA"><strong>a.</strong> 基类 <em>Bank.pm</em>
可以有，也可以没有构造器，但是必须要包含
<em>deposit()</em>、<em>withdraw()</em> 和 <em>get_balance()</em>
三个方法，和 <em>Checking.pm</em> 一样。</p>
<p class="indenthangingNA"><strong>b.</strong> 现在从 <em>Checking.pm</em> 移除 <em>deposit()</em>
和 <em>withdraw()</em> 方法。这样，使用 <em>Checking.pm</em>
的代码会从 <em>Bank.pm</em> 继承这些方法，因为 <em>@ISA</em>
数组的存在。</p>
<p class="indenthangingNA"><strong>c.</strong> 创建另一个模块名为 <em>Savings.pm</em>。</p>
<p class="indenthangingNA"><strong>d.</strong> <em>Checking.pm</em> 和 <em>Savings.pm</em> 都使用
<em>Bank</em>
模块并继承它的方法。只是这两个模块都有自己的构造器和属性。其中一个属性是账户的状态，要么是
&#8220;active&#8221;，要么是 &#8220;closed.&#8221;。<em>Savings</em>
账户的日息是 1%，起存最低额度是 $200。而 <em>Checking</em>
账户则有一个赊账保护机制，对于那些超额提取的账户收取每次
$35 的罚金。而且，会在赊账总额超过 $300
的时候锁定账户。这类的账户最小的起存额度是 $25。</p>
<p class="indenthangingNA"><strong>e.</strong> The <em>Checking.pm</em> and <em>Savings.pm</em> modules
will each have its own account numbers and registers.</p>
<p class="indenthangingNA"><a id="page_516"/><strong>f.</strong> The ATM script will use both
modules. The user script will have a main menu allowing the user to select
either of the two accounts. After getting a new account object, the user can
select from the types of transactions (submenu in your original
<em>Checking.pm</em> module) for that account and continue transactions
until he is ready to quit. When he exits, his account register balance will
be updated and he will be asked if he wants to return to the main menu. If
he says &#8220;yes,&#8221; he will see the main menu again, and if he says
&#8220;no,&#8221; the program will exit, giving him his balance. You will
have to uniquely name the register for each account so you can differentiate
between savings and checking accounts.</p>
<p class="indenthangingNAP">Example: <em>perl user.pl</em> (where user input is in bold)</p>
<p class="indenthangingNAP">Welcome!</p>
<p class="indenthangingNAP">Select an account type:</p>
<p class="indenthangingNAPN">1) Checking</p>
<p class="indenthangingNAPN">2) Savings</p>
<p class="indenthangingNAP"><strong>1</strong></p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>1</strong></p>
<p class="indenthangingNAP">How much do you want to deposit? 5.00</p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>3</strong></p>
<p class="indenthangingNAP">Your balance is $30.00</p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>2</strong></p>
<p class="indenthangingNAP"><a id="page_517"/>How much do you want to withdraw? 5.00</p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>3</strong></p>
<p class="indenthangingNAP">Your balance is $25.00</p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>4</strong></p>
<p class="indenthangingNAP">Return to the main menu? <strong>Y</strong></p>
<p class="indenthangingNAP">Welcome!</p>
<p class="indenthangingNAP">Select an account type:</p>
<p class="indenthangingNAPN">1) Checking</p>
<p class="indenthangingNAPN">2) Savings</p>
<p class="indenthangingNAP"><strong>2</strong></p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>3</strong></p>
<p class="indenthangingNAP">Your balance is $100.00</p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>1</strong></p>
<p class="indenthangingNAP"><a id="page_518"/>How much do you want to deposit? <strong>25</strong></p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>4</strong></p>
<p class="indenthangingNAP">Your balance is 125.00.</p>
<p class="indent"><strong>Part 5</strong></p>
<p class="indenthangingN"><strong>1.</strong> Go to the <em>pod</em> directory in the standard Perl
library. Look for <em>perlpod.html</em>. The file contains Larry
Wall&#8217;s user interface for using <em>pod</em> commands to document your
Perl programs.</p>
<p class="indenthangingN"><strong>2.</strong> Go to your browser and in the Location box, type:</p>
<p class="codelink"><a id="p518pro01" href="ch14_images.html#p518pro01a">Click here to view code
image</a></p>
<p class="pre2">file:/&lt;directory-to -your-library-file&gt;/Pod/pod.html</p>
<p class="indenthangingNP">Now you have the instructions for creating <em>pod</em> documentation.</p>
<p class="indenthangingN"><strong>3.</strong> Create a published interface for your
<em>Checking.pm</em> module. Embed <em>pod</em> commands in your
<em>Checking.pm</em> script explaining how the module should be used. Follow
the guidelines of the modules in the library; for example, there should be a
NAME, SYNOPSIS, DESCRIPTION, AUTHOR, and so forth. Run the <em>pod</em> file
through the <em>pod2html</em> filter and display the documentation in your
browser. Use the <em>perldoc</em> command to print your documentation on the
terminal screen.</p>
</body>
</html>
