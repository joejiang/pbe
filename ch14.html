<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>十四章 Bless 那些东西！（面向对象的 Perl）</title>
<link rel="stylesheet" type="text/css" href="9780133593044.css"/>
</head>
<body>
<h2 id="ch14"><a id="page_447"/><span class="pd_ash">Chapter 14.</span> Bless Those
Things! (Object-Oriented Perl)</h2>
<div class="heading">
<h3 id="ch14lev1sec1">14.1 面向对象建模</h3>
<p class="noindent">学完本章之后，你应该可以读写下面的代码：</p>
</div>
<p class="pre">use Cirle::Area;<br/>use base qw(Shape);<br/>$c1 = Circle::Area-&gt;new();<br/>$c2 = Circle::Area-&gt;new();<br/><br/>$c1-&gt;setRadius(5);<br/>$c1-&gt;setArea();<br/>$c2-&gt;setRadius(12);<br/>$c2-&gt;setArea();<br/><br/>print $c1-&gt;getArea();</p>
<div class="heading">
<h4 id="ch14lev2sec1">14.1.1 什么是对象？</h4>
<p class="noindent">对象就是那些我们每天打交道的东西。大多数编程语言，比如
<em>Java</em> 和
<em>C++</em>，都有对象的设计，于是也就被称为是面向对象的编程语言。面向对象是一种按照真实世界的对象概念来设计程序的方法。早期的
Perl 并不支持面向对象，但是到了 Perl 4 到 5
的更新时候，面向对象的设计就被添加到了这个语言的功能中。</p>
</div>
<p class="indent">现在，许多程序员开始使用一个叫做 Moose 的模块来简化
Perl 的面向对象。我们稍后会介绍
Moose，不过目前我们先从传统的 Perl 风格开始讨论。</p>
<p class="indent">面向对象其实不是适合每个人的，也不一定是解决问题的最佳方案。并非每种问题都会推动你使用面向对象的风格。但是当程序越来越大、越来越复杂、越来需要代码重用、操作数据越来越复杂，也越来越需要在多个程序员之间分享代码的时候，面向对象就开始越来越有效率。请参考
<em><a
href="http://perldoc.perl.org/perlootut.html">http://perldoc.perl.org/perlootut.html</a></em>
这个文档。</p>
<p class="indent">面向对象是一种组织数据成为的单一元素的机制。比如
<em>C++</em> 和 <em>Java</em>
都是用<strong>对象</strong>变量来给数据打包的语言。要问什么是对象，那么就要比对真实世界的事物，比如一只猫、一台电脑或者一个员工。在语言学中，猫、电脑和员工都被称为名词。</p>
<p class="indent">然后，用来描述名词的词是形容词。比如：“猫是贼黑的”；“电脑是又轻薄而飞速的”；“员工的名字叫约翰”。在面向对象语言中，形容词被称为<strong>属性</strong>。</p>
<p class="indent">语言中用来描述动作的被称为动词。在这里我们叫它们<strong>方法</strong>。比如“猫吃了又睡”；“电脑启动，也会死机”；“员工在上班”。Perl
的方法其实就是特殊的子程序。</p>
<p class="indent">对象的数据一般来说是<strong>私有</strong>的。消息是通过方法来发给对象的，而方法通常是<strong>公共</strong>的。这个保护数据私有而公布访问方法的机制叫做<strong>数据封装</strong>。这是所有面向对象编程的基本理念。如果你手头有个对象叫做
<em>account</em>，那么处理它的方法就应该叫
<em>view()</em>、<em>withdraw()</em> 和 <em>deposit()</em>
等等。私有的是 account
的那些细节，而存取细节的方法是公开的，就好象大家都知道要用银行卡塞到
ATM 机才能操作一样。你能做的事情就是通过 ATM
菜单来管理你的钱，而不是直接钻到机器里面去拿钱。</p>
<div class="heading">
<h4 id="ch14lev2sec2">14.1.2 什么是类？</h4>
<p class="noindent">在面向对象语言中，打包数据和方法的机制就叫做<strong>类</strong>。类用来包装描述对象的各种属性，以及各种用来调用的<strong>方法</strong>。不过说到底，类的存在只是为了做模板或者蓝图的用处，描述了对象可能的细节和作为。类代表了一些相似的对象，比如一类员工、一种车辆或者某型的电脑。</p>
</div>
<p class="indent">数据包装和信息隐藏其实是相关的词汇，在面向对象的领域是非常普遍的理念。当我们用类来包装对象的属性和方法的时候，实际的数据就和用户分隔开了，也可以被称为<strong>封装</strong>在类里面了。类的用户只能通过类的设计者提供的方法来访问数据。对于
Perl 来说，没有类似 <em>C++</em> 和 <em>Java</em> 当中的
<em>private</em> 和 <em>public</em> 关键词。</p>
<p class="indent">对于类来说，对象就代表着实实在在的人、地点或者别的东西。类的作用是像蓝图一样规定对象的模型。而那些对象就是从这个类的模子里面产生出来的。比如
<em>Employee</em> 类的作用就是为了产生有具体
<em>name</em>，具体 <em>address</em> 和 <em>phone number</em>
的对象。那些从类里面产生的 <em>employee</em>
对象可能有所不同，但是肯定都有 <em>Employee</em> 类规定的
<em>name</em>、<em>address</em> 和 <em>phone number</em>
属性。尽管对象可能修改值的内容，但是总是属于
<em>Employee</em>
这个类的。类可以被进一步衍生为更高级的类。比如从
<em>Computer</em> 类来衍生出 <em>Laptop</em> 类，或者
<em>SmartPhone</em> 类。这样就可以重用 <em>Computer</em>
类里面定义的那些功能。这个衍生类的方法就叫做
<strong>inheritance</strong>。</p>
<p class="indent">在 Perl
原始的设计中，包就能担任面向对象体系中的类的功能。这对
Perl
来说并不是一个崭新的概念，因为数据的封装其实通过包就可以完成。还记得我们之前在谈到包的时候提到的朦朦胧胧的数据隐藏吗？因为每个包都有自己的符号表，其实也就是一个哈希，用来维护当前包中的全局名字（也就是非
<em>my</em>
名字）。这就使得为包创建的变量和子程序可以在包中拥有自己的独立名空间。所以，因为早期引入包这个概念，Perl
其实比大家的期望更早就加入了面向对象大家庭。</p>
<p class="indent">上一章我们创建了一个含有子程序的包，也就是 Perl
模块。当时我们组织代码的风格是过程性的，或者称为自顶向下的。当时我们关注的就是怎样在数据上执行子程序而已。而这一章，我们关注的更多是数据或对象，虽然做的还是同样的事情。Perl
5
引入的新语法能帮助我们更妥善的表达面向对象的思维模型。其实，面向过程或者面向对象的区别在于是专注于动作还是专注于对象。</p>
<p class="indent">在 Tom Christianson 写的讨论 Perl 和对象的网页（主题是
“Easy Perl5 Object
Intro”）中，他谈到人们常常会不好意思用那些为 Perl 5
的新面向对象语法而开发的模块。但是，有些问题确实适合用对象的思路来解决。Christianson
认为人们不应该避开这类模块，因为其实使用这类模块仍然是便利的，而且也不意味着要完全适应相关的复杂理念。哪怕你以后也不会对面向对象开发有兴趣，但是相信你仍然时不时要用到一些对象思路的模块。阅读这一章应该有助于你理解这类模块的设计理念。</p>
<p class="footnote"><a id="ch14fn1" href="ch14.html#ch14fn1a">1</a>. 请访问 <em><a
href="http://perl.com/doc/FMTEYEWTK/easy_objects.html">http://perl.com/doc/FMTEYEWTK/easy_objects.html</a></em>
来阅读 Tom Christianson 的 Web 页面.</p>
<div class="heading">
<h4 id="ch14lev2sec3">14.1.3 面向对象的基本术语</h4>
<p class="noindent">面向对象编程是一个非常宏大的主题。在这个领域中的书籍数量难以估计。为了构造更加复杂的软件，九零年代的许多开发人员已经从传统的、自顶向下的开发转变到面向对象的编程语言。这本书并不打算专门讨论面向对象的设计和编程。但是，还是有一些面向对象的词汇需要探讨清楚，才能开始介绍
Perl 的面向对象特性。请参考表 14.1 列出的这些词汇。</p>
</div>
<div class="tab-heading">
<div class="image"><a id="page_450"/><a id="ch14tab01"/><img src="graphics/14tab01.jpg" alt="Image"/></div>
<p class="tab-caption"><strong>表 14.1</strong> 面向对象关键词</p>
</div>
<div class="heading">
<h3 id="ch14lev1sec2">Perl 的类、对象和方法，与真实世界的对照</h3>
<p class="noindent">如同之前提到，面向对象是一种组织程序的方法，用来解决类似真实世界中的对象相关的问题。首先，你要买下一块地产来建造房屋。然后，你会雇佣一个建筑师来规划新房子的蓝图。当然，你要决定什么建筑风格、多少房间、门窗的数量等等。接着，你要找一些工人来建造房屋。竣工之后，你要拿到开门的钥匙，然后进去涂抹装饰整理房屋、丢掉建筑垃圾。</p>
</div>
<p class="indent">不过，既然你手头已经有了建筑蓝图，以后就可以再买一块类似的新地产，建造一个类似的新房子。只不过这次可以涂上新的颜色、改变庭院的设计等等。也就是说，你可以有一个设计相同、但完全崭新的房子，当然地址也完全不同。</p>
<p class="indent">在面向对象语言来说，房子就是一个对象，也就是一个名词。设计风格和房间的数量都是描述对象的属性，有点像是形容词。而涂抹、打扫、展示房间等等都是有关对象的动作。类就是建筑师设计的蓝图。</p>
<p class="indent">所有这些必有都有助于我们之后（通过更多例子）渐渐明白
Perl 是如何穿件、操作并销毁对象的。</p>
<div class="heading">
<h4 id="ch14lev2sec4">14.2.1 步骤</h4>
<p class="noindent">这一章会详细讨论许多的主题。作为梗概，下面的步骤有助于我们创建（并定义）一种叫做对象的新数据类型：</p>
</div>
<p class="indenthangingN"><strong>1.</strong>
定义什么是你需要的对象（名词），以及对象要达成的功能（设计），并封装成类。比如，房屋、员工、圆型、数据库、文件句柄或者别的东西。</p>
<p class="indenthangingN"><strong>2.</strong>
在一个类的包里面创建新的对象（也就是一个标量、数组、哈希或子程序之类的引用）。通过构造器，给它一个唯一的标识。</p>
<p class="indenthangingN"><strong>3.</strong>
通过属性的赋值来描述这个对象。这个描述过程也可以事后在程序中慢慢完成。</p>
<p class="indenthangingN"><strong>4.</strong>
把这个对象祝福成为某个类的实例，从而使对象和类产生关联。</p>
<p class="indenthangingN"><strong>5.</strong>
定义实例方法来访问这个对象，从而说明对象的使用方法。</p>
<p class="indent">在定义了类、对象和方法之后，我们可以这样来定义用户接口：</p>
<p class="indenthangingN"><strong>1.</strong>
使用这个类，也就是把它载入程序的内存空间。</p>
<p class="indenthangingN"><strong>2.</strong> 通过构造器来创建一个对象实例。</p>
<p class="indenthangingN"><strong>3.</strong> 通过访问方法来操作此对象。</p>
<p class="indent">最后我们可以：</p>
<p class="indenthangingN"><strong>1.</strong> 通过继承来重用类。</p>
<p class="indenthangingN"><strong>2.</strong> 销毁对象，也就是从内存中释放对象。</p>
<div class="heading">
<h4 id="ch14lev2sec5">14.2.2 一个完成的面向对象 Perl 程序</h4>
<p class="noindent">在讨论细节之前，我们先看一个完整的面向对象 Perl
脚本，然后在这一章中一步步的分析解说。在这一章的末尾，你应该可以毫无困难的解读其中所有的代码了。实际上，这个例子可以说是非常基础的，所以你会有很多改进的意见。目前，这个例子还可以用来做一个起步的模板。注意这里的类定义和调用代码是在同一个文件当中的。稍后我们会把他们分成两个部分。一个是类的实现叫做模块文件，另外一个文件是模块的调用代码。明确的说，我们会创建一个模块
House.pm，还有一个用户调用程序。</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_452"/><a id="ch14exa01"/>例 14.1</p>
<p class="codelink1"><a id="p14exa01" href="ch14_images.html#p14exa01a">Click here to view code
image</a></p>
<p class="pre1">package House;&#160;&#160;# <span class="EmpItalic">House class</span><br/>use warnings;<br/>use strict;<br/>sub new{&#160;&#160;# <span class="EmpItalic">The constructor method</span><br/>&#160;&#160;&#160;my $class=shift;<br/>&#160;&#160;&#160;my $house_obj={ "Owner"=&gt;"Planet Bank",&#160;&#160;#
<span class="EmpItalic">Properties</span>/<span
class="EmpItalic">attributes</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Color"=&gt;"Beige",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Payment"=&gt;undef,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;return bless($house_obj, $class); # <span
class="EmpItalic">The blessing creates the object</span><br/>}<br/><br/>sub set_owner{&#160;&#160;# <span class="EmpItalic">Instance/Access
methods</span><br/>&#160;&#160;&#160;my $self=shift;<br/>}<br/>sub set_color{<br/>&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;$self-&gt;{"Color"}=shift;<br/>}<br/>sub set_payment{<br/>&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;my $payment=shift;<br/>&#160;&#160;&#160;$self-&gt;{"Payment"}=$payment unless $payment &lt; 0;;<br/>}<br/>sub get_owner{&#160;&#160;# <span class="EmpItalic">Retrieve data from the
object</span><br/>&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;return $self-&gt;{Owner};<br/>}<br/><br/>#----------<span class="EmpItalic">End of Class
definition</span>----------------------------------<br/><br/># <span class="EmpItalic">User of the Class</span><br/>use Data::Dumper;&#160;&#160;# <span class="EmpItalic">We'll look at the
structure of the object</span><br/><br/>my $house1=House-&gt;new();&#160;&#160;&#160;# <span class="EmpItalic">Make
a new house object and get back</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">its address</span><br/>my $house2=House-&gt;new();&#160;&#160;&#160;# <span class="EmpItalic">Make
another house object</span><br/>$house2-&gt;set_owner("Mr. T"); # <span class="EmpItalic">Change the default
owner of the</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">second house</span><br/>$house2-&gt;set_payment("2000");# <span class="EmpItalic">Set the payment of
the second house</span><br/>print "The owner of my first house is ", $house1-&gt;get_owner(),"\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Retrieve data from the first house.</span><br/><br/>print Dumper($house1,$house2);&#160;&#160;# <span class="EmpItalic">Look at
the content of the</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">house objects</span><br/><a id="page_453"/>(Output)<br/><span class="EmpItalic"></span><br/><span class="EmpItalic">$VAR1 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Owner' =&gt; 'Planet Bank',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Payment' =&gt; undef,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Color' =&gt; 'Beige'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'House' );</span><br/><span class="EmpItalic">$VAR2 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Owner' =&gt; 'Mr. T',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Payment' =&gt; 2000,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Color' =&gt; 'Beige'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'House' );</span><br/>&#160;&#160;<span class="EmpItalic">}</span></p>
<hr/></div>
<div class="heading">
<h5 id="ch14lev3sec1">Perl 包就是类</h5>
<p class="noindent">包用来实现类。面向对象的 Perl 并没有 Class
这个关键字，而是把包称作类。类代码通常是存放在一个附属名为
.<em>pm</em>
的文件中的，主文件名通常就是类名。如果你想要区分这两个关键词的话，那么类就是一个带有特殊子程序（称为方法，用来创建和操作对象）的包。Perl
的包通常含有以下几个部分：</p>
</div>
<p class="indenthangingN"><strong>1.</strong> 用来定义对象的数据。</p>
<p class="indenthangingN"><strong>2.</strong>
用来创建对象，并祝福此对象的构造函数。</p>
<p class="indenthangingN"><strong>3.</strong>
其他的特殊子程序，称为方法，用来创建、访问、操作并销毁对象。</p>
<p class="indent">不像其他编程语言，在 Perl 当中并没有
<em>private</em>、<em>public,</em> 或者 <em>protected</em>
这样的关键字。Perl
使用包的名字空间机制来存储类数据和方法，而 <em>my</em>
函数用来将变量限定在词法范围，并通过 <em>bless</em>
函数来确保创建的对象都能找到对应的类。总之，对象就是匿名哈希、数组或者子程序的引用，对于它们的存取是通过特殊的方法函数来实现的，而引用就是访问对象的方法。</p>
<div class="heading">
<h5 id="ch14lev3sec2">Perl 类</h5>
<p class="noindent">因为类其实就是一个包，所以它可以拥有自己的符号表，其中的全局数据或函数可以在类的外部直接访问。</p>
</div>
<p class="indent">与其他语言不同的是，Perl
并没有严格的区别模块的公有或私有边界。.<sup><a
id="ch14fn2a"
href="ch14.html#ch14fn2">2</a></sup>为了要实现私有数据，需要使用特殊的技巧（请参考本章后面
<a href="ch14.html#ch14lev1sec3">14.3
节</a>的匿名子程序、闭包和私有数据）。</p>
<p class="footnote"><a id="ch14fn2" href="ch14.html#ch14fn2a">2</a>. Perl
编程，第二版，第 287 页；O&#8217;Reilly 出版社，Sebastopol
加州，1998 年由 Larry Wall 和 Randal Schwartz 合著。</p>
<div class="fig-heading">
<div class="image"><a id="page_454"/><a id="ch14fig01"/><img src="graphics/14fig01.jpg" alt="Image"/></div>
<p class="fig-caption"><strong>图 14.1</strong> 类的构成</p>
</div>
<div class="heading">
<h4 id="ch14lev2sec6">14.2.3 Perl 对象</h4>
<div class="heading">
<h5 id="ch14lev3sec3">引用</h5>
<p class="noindent">在开始之前，需要通过一个引用来创建 Perl
对象。如果你仍然不熟悉如何使用引用的话，可能需要参考<a
href="ch12.html#ch12">第十二章</a>。基本上，引用就是一个标量，其中存放的是其他变量的地址。引用可以指向一个无名的数据，于是被称为<strong>匿名变量</strong>。比如，下面就是一个名为
<em>$ref</em>
的引用，指向了一个匿名哈希，其中有两个键值对：</p>
</div>
</div>
<p class="codelink"><a id="p454pro01" href="ch14_images.html#p454pro01a">Click here to view code
image</a></p>
<p class="pre">my $ref={"Owner"=&gt;"Tom", "Price"=&gt;"25000"};</p>
<p class="indent">为了存取匿名哈希，就需要使用箭头操作符来对
<em>$ref</em> 引用（也就是指针）进行如下的反引用：</p>
<p class="pre">$ref-&gt;{"Owner"}</p>
<p class="indent">为了要构造一个 Perl
对象，首先得创造一个引用。尽管引用可以指向任何的数组、标量或子程序，不过通常是指向一个匿名哈希的。哈希中存放的是数据的名称和对应的对象属性。</p>
<div class="heading">
<h5 id="ch14lev3sec4">什么是祝福？</h5>
<p class="noindent">引用必须被“祝福”过，才能成为一个 Perl
对象；换句话说，这个被引用指向的东西必须知道自己属于哪个包。实现的方法就是把引用祝福为一个包。你可以把这个祝福过程理解为构造了一个新的数据类型，也就是真正的对象。</p>
</div>
<p class="codelink"><a id="p455pro01" href="ch14_images.html#p455pro01a">Click here to view code
image</a></p>
<p class="pre"><a id="page_455"/>my $ref={Owner=&gt;"Tom", Price=&gt;250000};&#160;&#160;#
<span class="EmpItalic">Properties Owner, Price</span><br/><span class="EmpStrong">bless($ref, "House");</span>&#160;&#160;# <span
class="EmpItalic">Tag the reference as belonging to a House</span><br/><span class="EmpStrong">return $ref</span>;&#160;&#160;# <span
class="EmpItalic">A reference to the object is returned to the caller</span></p>
<p class="indent">这个 <em>bless</em>
函数就是用来实现这样的功能：它期待两个参数，第一个参数是引用，而第二个可选参数是类（也就是包）的名字。然后这个
<em>bless</em>
函数就给被引用的东西打上相应的标签。其实就是创建一个内部指针来跟踪对象属于的包。对象（其实通常是哈希）于是就被祝福成了相应的类的成员实例。如果调用的时候没有可选的第二个参数的话，那么
<em>bless</em> 函数就会用当前的包名字来祝福对象。</p>
<p class="indent">然后 <em>bless</em> 函数返回祝福过的对象。在<a
href="ch14.html#ch14fig02">图
14.2</a>中，对象地址在祝福前后都会显明。注意在祝福以后，为这个对象打上的类标签是
<em>House</em>。</p>
<div class="fig-heading">
<div class="image"><a id="ch14fig02"/><img src="graphics/14fig02.jpg" alt="Image"/></div>
<p class="fig-caption"><strong>图 14.2</strong> 祝福前后的地址。</p>
</div>
<p class="indent">因为祝福过程使得对象和包的名字（也就是类名）产生关联，Perl
就能够跟踪对象所属的包。于是我们不需要调用时候使用
::
这样的语法。一个对象可以被祝福成为某个类的实例，然后再次被祝福成为另一个类的实例。但是，一个对象某个时刻只可能属于一个类。一旦对象得到祝福，就不必再考虑使用
<em>@EXPORT_OK</em> 或者 <em>@EXPORT</em>
数组这样的方法来输出符号表。实际上，作为一个默认的规矩，只要是面向对象的模块，就不必输出任何符号。</p>
<div class="heading">
<h4 id="ch14lev2sec7"><a id="page_456"/>14.2.4 Methods Are Perl Subroutines</h4>
<div class="heading">
<h5 id="ch14lev3sec5">Definition</h5>
<p class="noindent">所谓<strong>方法</strong>是个一个与对象互动的子程序。比如，它可以用来创建对象，存取或者修改对象的数据。方法作为一个特殊的属于类的子程序，他的第一个参数总是以下的东西之一：</p>
</div>
</div>
<p class="indenthangingN"><strong>1.</strong> 类名（也就是包名）</p>
<p class="indenthangingN"><strong>2.</strong> 对象的引用</p>
<p class="indent">第一个参数是 Perl
默默发送的。哪怕你调用过程的时候没有带上任何参数，Perl
还是会自动带上一个参数，要么是包名字，要么就是对象引用。否则，它就和其他子程序没有任何区别了。在<a
href="ch14.html#ch14exa01">例 14.1
</a>中，我们创建了两个房子对象。创建的不走是通过一个叫做
<em>new</em>
的方法实现的（当然这个方法也可以用其他任何的名字）。在例子中，调用的时候我们首先是书写类名
<em>House</em>，然后是一个箭头，<em>House</em>-<em>&gt;new()</em>。Perl
会把箭头左边的东西作为第一个参数传递给方法。所以，当你调用的
<em>new()</em> 方法检查第一个参数的时候，其实是有个叫做
<em>House</em> 的类名在其中的。</p>
<p class="indenthangingN"><strong>1.</strong> Perl 暗暗的把类名发送给 <em>new()</em>
方法。</p>
<div class="image"><img src="graphics/456pro01.jpg" alt="Image"/></div>
<p class="indenthangingNP">尽管调用 <em>new()</em> 方法的参数列表是空的，Perl
还是会把箭头左边的部分发送给方法。作为这个例子，发给
<em>new()</em> 方法的是 <em>House</em> 这个名字。</p>
<p class="indenthangingN"><strong>2.</strong> Perl 发送给 <em>$house2</em> 对象的
<em>set_owner()</em> 方法的是一个引用。</p>
<p class="codelink"><a id="p456pro02" href="ch14_images.html#p456pro02a">Click here to view code
image</a></p>
<p class="pre"><span class="EmpStrong">$house2-&gt;set_owner</span>("Mr. T"); # <span
class="EmpItalic">Perl sends the address of the second</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">house as the first argument to set_owner()</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">and "Mr. T" as the second argument</span></p>
<p class="indent">这里 <em>set_owner()</em>  方法的第一个参数看似
<em>Mr. T</em>，实际却不是。对第二个房子对象的引用
<em>$house2</em>
才是。只是这次我们是通过箭头左边的引用，而不是类名来传递这个参数的。Perl
会自动把引用作为第一个参数，而 <em>Mr. T</em>
只能排在第二。这样，你就可以确认 Perl
能知道是哪个房子属于 Mr T。</p>
<div class="heading">
<h5 id="ch14lev3sec6"><a id="page_457"/>方法的类型</h5>
<p class="noindent">现在我们已经做了简单的介绍，下面就是关于方法的深入介绍。方法有两种类型：类方法（或者称为静态方法），或者实例方法。<sup><a
id="ch14fn3a"
href="ch14.html#ch14fn3">3</a></sup>类方法的第一个参数应该是类名，而实例方法的第一个参数应该是实例引用。</p>
</div>
<p class="footnote"><a id="ch14fn3"
href="ch14.html#ch14fn3a">3</a>.
每本书（的作者）对方法有不同的分类方法。比如，Larry
Wall 就把方法分类为：类方法、实例方法和两栖方法。</p>
<p class="indent"><strong>类方法</strong>顾名思义就是对整个类起作用的方法。比如，这种方法可以创建对象，或者在一组对象上操作。这样的方法也是独立的，也就是说它并不依赖于对象（作为第一个参数）。比如，统计对象总数，这样的方法需要跟踪并管理为类创建的所有对象，所以很适合作为类方法。又比如，对于对象的创建来说，这样的<strong>构造器</strong>方法也是典型的类方法，所以第一个参数必然是类名。对于
Perl 来说，构造器方法通常被命名为
<em>new</em>，当然我们也可以随心所欲的使用其他的名称。另外，创建对象的操作通常被称为<strong>实例化</strong>，或者叫做创建类实例。</p>
<p class="indent">而<strong>实例方法</strong>也可以被称为存取方法或者赋值方法（英文名称为
Mutator
method），它们用来定义对象数据的赋值、修改和读取。在创建实例之前，对象方法毫无用处。然而，一旦对象引用创建好了，实例方法就可以通过引用（通常是
<em>$this</em> 或
<em>$self</em>）来操作对象数据。这类的方法期待第一个参数是对象引用。这样，方法才知道要作用在哪个对象上面。所以，<em>$dogref</em>-&gt;<em>speak()</em>
这样的调用就会通过狗对象的引用来获取“旺旺”这样的结果，而
<em>$catref</em>-<em>&gt;speak()</em>
这个调用会返回的则是猫猫对象的“喵喵”声。Perl
知道怎么正确的处理对象引用。</p>
<div class="heading">
<h5 id="ch14lev3sec7">调用方法</h5>
<p class="noindent">Perl
提供了一种特殊的语法来调用方法。与之前的包方法调用语法
<em>package::function</em>
不同，现在我们用两种方法来调用：类方法调用，或者实例方法调用。对于每种调用来说又有两种语法：面向对象语法或者间接语法。如果你使用对象的话，任何一种调用都是可以的，只是面向对象的语法来得更加清晰一点。以前那种两个冒号的语法有点歧义，不建议使用。</p>
</div>
<p class="indent"><strong>注意</strong>：方法与一般的子程序差别在于第一个隐含的参数，要么是类的名字，要么就是对象引用。如果你调用的方法接受三个参数，那么实际上就会传给它四个参数。第一个参数就是面向对象语法的箭头左边的对象。</p>
<div class="heading">
<h6 id="ch14lev4sec1">类方法语法</h6>
<p class="noindent">假定方法名叫 <em>new</em>，而返回的值存储在 <em>$ref</em>
这个对象的引用中。</p>
</div>
<p class="codelink"><a id="p457pro01" href="ch14_images.html#p457pro01a">Click here to view code
image</a></p>
<p class="pre">1) $ref = class-&gt;new( list of arguments );&#160;&#160;&#160;# <span
class="EmpItalic">object-oriented syntax</span><br/>2) $ref = new class ( list of arguments );&#160;&#160;&#160;# <span
class="EmpItalic">indirect syntax</span></p>
<p class="indent"><a id="page_458"/>如果类名叫 <em>House</em>，Perl 会把调用</p>
<p class="pre">$ref = House-&gt;new();</p>
<p class="noindent">翻译成</p>
<p class="pre1">$ref = House::new(House);</p>
<div class="heading">
<h6 id="ch14lev4sec2">实例方法调用</h6>
<p class="noindent">假定方法名叫 <em>display</em>，而引用对象名叫 <em>$obj</em>。</p>
</div>
<p class="codelink"><a id="p458pro01" href="ch14_images.html#p458pro01a">Click here to view code
image</a></p>
<p class="pre">1) $obj-&gt;display( list of arguments );&#160;&#160;&#160;&#160;# <span
class="EmpItalic">object-oriented syntax</span><br/>2) display $obj ( list of arguments );&#160;&#160;&#160;&#160;# <span
class="EmpItalic">indirect syntax</span></p>
<p class="indent">这个例子中使用了箭头符号来调用方法，这种语法就是最常用的面向对象语法。我们会在这本书中使用这种语法。而那种没有箭头符号的调用方法是间接调用语法。</p>
<p class="indent">当 Perl
发现前两种调用方法发生的时候，它都能明白这个对象对应的类是什么，因为这个对象已经得到了所谓的“祝福”，也就是说有一个指针在跟踪它。<sup><a
id="ch14fn4a" href="ch14.html#ch14fn4">4</a></sup></p>
<p class="footnote"><a id="ch14fn4"
href="ch14.html#ch14fn4a">4</a>.
这种跟踪的机制被称为是运行时绑定，请参考《高级 Perl
编程》；O’Reilly 出版社，Sebastopol 加州，1997 年由
Srinivasan, S. 著。</p>
<p class="indent">不论你这样调用</p>
<p class="pre">display $ref (<span class="EmpStrong">arguments...</span>);</p>
<p class="noindent">或者</p>
<p class="pre">$ref-&gt;display(<span class="EmpStrong">arguments...</span>);</p>
<p class="noindent">只要 <em>$ref</em> 是一个名叫 <em>House</em>
类的对象指针，那么 Perl 就会把调用翻译成</p>
<p class="codelink"><a id="p458pro02" href="ch14_images.html#p458pro02a">Click here to view code
image</a></p>
<p class="pre">House::display($ref, arguments...);</p>
<div class="heading">
<h5 id="ch14lev3sec8">使用构造器来创建对象</h5>
<p class="noindent">为要创建 <em>House</em>
类，我们先得创建一个包。这个包被命名为
<em>House</em>。而且，这个包现在就是面向对象术语中的<strong>类</strong>了。一个对象的创建是通过名为构造器的方法来实现的，这样你的程序就知道怎样访问对象的内存空间了。</p>
</div>
<p class="indent">属性用来描述对象的特性，比如拥有者、风格、大小、颜色等等。在我们的例子里面，房子的属性包括
<em>Owner</em>，<em>Color</em> 和
<em>Payment</em>。设置属性的方法非常繁多。通常，属性是通过一个匿名哈希（包含的键值对）来存储的。</p>
<p class="indent">在之后的例子里面，类名是
<em>House</em>，而构造器的名字叫做 <em>new()</em>。<em>new()</em>
这个名字不是必然的，你可以根据实际情况选择最适合的名字。因为我们正在建造一座新房子，所以
<em>new()</em>
这个名字看上去还是很适合的。当然，我们也可以使用
<em>create()</em>、<em>build()</em>、<em>startup()</em> 或者
<em>init()</em>。构造器的作用就是为新的 <em>House</em>
对象分配内存，也就是说获得对象引用。我们可以事后再设置属性的值，而分配地址的任务不能拖延。这就好像你造房子的时候必须先选址一样的。</p>
<p class="indent">类似其他的函数，构造器可以从主调代码中获得其他的参数，从而给实例变量赋值。下一步就是确保
Perl 能追踪实例地址对应的类。这里 <em>house</em>
对象之所以知道它属于 <em>House</em> 类，是因为 <em>bless</em>
函数起到的作用。简单来说，它能把输入的指针变成对象。也就是给那个内存打上
House 标签，而不是别的什么 Car、Horse 或者 Cat 之类。</p>
<p class="indent"><a href="ch14.html#ch14exa02">例 14.2</a>
显示了构造器的定义方法：创建引用，通过 <em>bless</em>
来构造对象。在这段代码中，我们只是定义方法。后面，我们会调用它。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa02"/>例 14.2</p>
<p class="codelink1"><a id="p14exa02" href="ch14_images.html#p14exa02a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;<span class="EmpStrong">package
House;</span>&#160;&#160;&#160;# <span class="EmpItalic">Name of the
class</span><br/><br/>2&#160;&#160;<span class="EmpStrong">sub new</span>{&#160;&#160;# <span
class="EmpItalic">The constructor method</span><br/><br/>3&#160;&#160;&#160;&#160;&#160;&#160;my $class=shift @_;&#160;&#160;# <span
class="EmpItalic">First argument is the name of the class</span><br/>4&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
$house_obj</span>={ "Owner"=&gt;"Planet Bank", # <span
class="EmpItalic">Default attributes</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Color"=&gt;"Beige",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Payment"=&gt;undef,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/><br/>5&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">bless($house_obj, $class);</span>&#160;&#160;# <span
class="EmpItalic">Create the object by blessing it</span><br/>6&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return
$house_obj</span>;<br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">The blessing transforms the
ordinary pointer into a pointer to an</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">object. The object now belongs
to the House</span> class.<br/>&#160;&#160;&#160;}</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 声明 <em>House</em>
包。这个包可以被称为类，因为它包含一个方法，而且这个方法会“祝福”一个引用。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 在面向对象术语中，<em>new</em>
子程序被称为是<strong>构造器</strong>。构造器的主要任务就是创建并初始化一个对象。在
Perl
来说，并没有什么特殊的语法来识别它。这个方法被称为是类方法，因为它的第一个参数（可以从
@_ 中 shift 出来）是类名。（参考 <a
href="ch14.html#ch14exa04">例 14.4</a>
了解怎样调用）这个子程序的任务就是把引用“祝福”成某个类的成员，然后返回这个引用。这个子程序可以被称为<strong>方法</strong>，而返回的东西被称为是<strong>对象</strong>。整个包被称为是一个<strong>类</strong>。</p>
<p class="sb-indenthangingN"><a id="page_460"/><strong>3.</strong>
这类子程序收到的第一个参数是包名（也就是类名），这里是
<em>House</em>。这也是方法和普通子程序的另一个区别所在。方法的第一个参数是类名，或者可以说成是对象名。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这个 <em>$house_obj</em>
对象引用被指向一个匿名哈希。其中 <em>Payment</em>
得到的值是
<em>undef</em>，也就是说目前这个字段的值无法确定。这些键值对的存在是为了给
<em>house</em>
对象提供默认值。你也可以使用一个空哈希来产生对象，比如
<em>$house_obj = {}</em>。这些值可以通过<a
href="ch14.html#ch14exa03">例 14.3</a>定义的方法来存取。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 引用 <em>$house_obj</em> 作为 <em>bless()</em>
函数的第一个参数，而此函数的第二个参数是类名。得到“祝福”的其实不是引用，而是引用指向的东西，或者称为
<strong>referent</strong>。于是我们会给这个地址存储的东西打上一个类名标签，使得一个普通引用变成一个对象引用。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 现在可以把对象引用返回给调用者。</p>
<hr/></div>
<div class="heading">
<h5 id="ch14lev3sec9">创建实例方法</h5>
<p class="noindent">在构造器方法以外，还可以定义其他方法。在面向对象的世界里，这些方法被称为公共方法，也就是用来访问对象的方法（只是必须等到对象创建以后）。它们定义了对象的动作，也就是可以对它做点什么，或者它可以做点什么。实际上，方法应该是访问对象的唯一途径才对。</p>
</div>
<p class="indent">对我们的 <em>house</em>
对象来说，应该有个一方法叫做迁入，另一个方法可能叫做打扫，还有展示等等。对于
Perl
来说，方法其实就是升级版的子程序。下面我们就定义
<em>House</em>
类的三个实例方法（或者叫做赋值方法、存取方法等等）。这三个方法包括
<em>set_owner()</em>、<em>set_color()</em> 和
<em>set_price()</em>，其实都需要等到对象实例创建之后才能用。换句话说，你不可能对一个尚不存在的房子做许多奇怪的动作，比如刷墙或出售。<strong>实例方法的第一个参数永远是对象引用。</strong>一旦方法获取了对象的地址，就能知道它属于哪个类（或者说它被祝福成了那个类），也就可以按照相应的类定义的代码来执行（比如设定值、返回值、修改默认值；或者是例子中的计算按揭额度、修建车库、打扫厨房、拆毁房子等等）。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa03"/>例 14.3</p>
<p class="codelink1"><a id="p14exa03" href="ch14_images.html#p14exa03a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;package House;&#160;&#160;&#160;# <span class="EmpItalic">Name
of the class</span><br/><br/>2&#160;&#160;sub new{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $house_obj={ "Owner"=&gt;"Planet
Bank",&#160;&#160;&#160;# <span class="EmpItalic">Default attributes</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Color"=&gt;"Beige",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Payment"=&gt;undef,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;&#160;&#160;return bless($house_obj, $class);<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;#--------------------------------------------------------------------<br/><a id="page_461"/>&#160;&#160;&#160;# <span class="EmpItalic">Create the
instance methods that will manipulate the object</span><br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">The setter methods</span><br/>3&#160;&#160;<span class="EmpStrong">sub
set_owner{</span>&#160;&#160;&#160;# <span class="EmpItalic">Access or
instance methods</span><br/>4&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my ($self,
$owner)= @_;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">First argument is a pointer to the house
object</span><br/>5&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">$self-&gt;{"Owner"}=$owner;</span>&#160;&#160;&#160;#
<span class="EmpItalic">Set a new owner</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;<span class="EmpStrong">sub set_color{</span>&#160;&#160;#
<span class="EmpItalic">Setter method</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
($self,$color) = @_;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">First argument
is a pointer to the house object.</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">$self-&gt;{"Color"}=$color;</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><br/>&#160;&#160;&#160;<span class="EmpStrong">sub set_payment{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my ($self,
$payment) = @_;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">$self-&gt;{"Payment"}=$payment;</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">The getter methods</span><br/><span class="EmpStrong">6&#160;&#160;sub get_owner{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
$self=shift;</span><br/><span class="EmpStrong">7&#160;&#160;&#160;&#160;&#160;return
$self-&gt;{"Owner"};</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;<span class="EmpStrong">sub get_color{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
$self=shift;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return
$self-&gt;{"Color"};</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;<span class="EmpStrong">sub get_payment{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $self=shift;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return
$self-&gt;{"Payment"};</span><br/>&#160;&#160;&#160;}</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这个类名叫 <em>House</em>。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 构造器定义了默认属性。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 以下开始定义实例方法。现在定义的是
<em>set_owner</em>
方法，算是一个赋值方法（或者称为存取方法）。它的作用就是为对象存入数据。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里 <em>set_owner</em>
收到的第一个参数是对象引用，被赋值到 <em>$self</em>
变量中，这是一个常用变量名，当然也可以使用你喜欢的任何其他名字。第二个参数才是这个对象将要获取的
<em>Owner</em> 属性值。当用户调用这个方法的时候，Perl
会默默的把对象引用作为第一个参数传递过去，然后才是用户代码中的其他参数。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 通过 <em>$self</em> 这个对象引用来设置
<em>Owner</em> 属性的值。</p>
<p class="sb-indenthangingN"><strong>6.</strong>
这个方法叫做读取方法，作用就是从对象中取出数据。第一个参数仍然是对象地址，进入变量
<em>$self</em> 中。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里返回的是 <em>Owner</em> 属性的值。</p>
<hr/></div>
<div class="heading">
<h5 id="ch14lev3sec10"><a id="page_462"/>调用方法（用户端）</h5>
<p class="noindent">目前我们已经创建了类和方法，现在是时间来调用方法了。在这里，我们把方法的定义和使用放在一个文件里。不过，到了下一节我们就会把它们分成两个文件：一个是类模块文件（<em>.pm</em>
结尾），另一个是用户端的逻辑。不论是使用一个文件还是多个，类的定义总是要和主程序分开的。在下面的例子中，实例方法定义被裁剪了，以便缩短样例代码的长度。</p>
</div>
<div class="fig-heading">
<div class="image"><a id="ch14fig03"/><img src="graphics/14fig03.jpg" alt="Image"/></div>
<p class="fig-caption"><strong>图 14.3</strong> 不同地址的两所房子</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa04"/>例 14.4</p>
<p class="codelink1"><a id="p14exa04" href="ch14_images.html#p14exa04a">Click here to view code
image</a></p>
<p class="pre1"># <span class="EmpItalic">The Class Definition Outside the Main Part of the
Program</span><br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>1&#160;&#160;package House;&#160;&#160;&#160;# <span class="EmpItalic">Name
of the class</span><br/>2&#160;&#160;sub new{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $house_obj={ "Owner"=&gt;"Planet
Bank", # <span class="EmpItalic">Default attributes</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Color"=&gt;"Beige",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Payment"=&gt;undef,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;&#160;&#160;return bless($house_obj, $class);<br/>&#160;&#160;&#160;}<br/>#------------------------------------------------------------------------<br/>&#160;&#160;&#160;# <span class="EmpItalic">Create the functions/methods
that will manipulate the object</span><br/>3&#160;&#160;sub set_owner{&#160;&#160;&#160;# <span
class="EmpItalic">Access or instance methods</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">First
argument is a pointer to the house object</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;{"Owner"}=shift;&#160;&#160;&#160;#
<span class="EmpItalic">Now set a new owner.</span><br/>&#160;&#160;&#160;}<br/><a id="page_463"/>&#160;&#160;&#160;sub set_color{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">First argument
is a pointer to the house object.</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;{"Color"}=shift;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;sub set_payment{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;{"Payment"}=shift;<br/>&#160;&#160;&#160;}<br/><br/>4&#160;&#160;<span class="EmpStrong">sub get_owner{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
$self=shift;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return
$self-&gt;{Owner};</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><br/><span
class="EmpStrong">#------------------------------------------------------</span><br/><span class="EmpStrong">#</span>&#160;&#160;<span class="EmpItalic">Now we
enter the main part or user part of the program</span><br/>&#160;&#160;&#160;use Data::Dumper;&#160;&#160;# <span
class="EmpItalic">Dump out both objects to display contents</span><br/><br/>5&#160;&#160;<span class="EmpStrong">my $house1 = House-&gt;new();</span> #
<span class="EmpItalic">Call constructor to create</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">a new house object</span><br/><br/>6&#160;&#160;<span class="EmpStrong">my $house2=House-&gt;new();</span> #
<span class="EmpItalic">Create another house object</span><br/><br/>7&#160;&#160;<span class="EmpStrong">$house2-&gt;set_owner("Mr. T");</span>
# <span class="EmpItalic">Call access method for the second house</span><br/><br/>&#160;&#160;&#160;<span
class="EmpStrong">$house2-&gt;set_payment("2000");</span><br/><br/>8&#160;&#160;<span class="EmpStrong">print "The owner of my first house is
",$house1-&gt;get_owner(),"\n";</span><br/><br/>9&#160;&#160;print Dumper($house1,$house2);&#160;&#160;# <span
class="EmpItalic">Take a look at the two instances</span><br/><br/>(Output)<br/><span class="EmpItalic"></span><br/><span class="EmpItalic">$VAR1 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Owner' =&gt; 'Planet Bank',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Payment' =&gt; undef,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Color' =&gt; 'Beige'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'House' );</span><br/><span class="EmpItalic">$VAR2 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Owner' =&gt; 'Mr. T',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Payment' =&gt; '2000',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Color' =&gt; 'Beige'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'House' );</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_464"/>注解</p>
<p class="sb-indenthangingN"><strong>1.</strong> 声明 <em>House</em> 类。</p>
<p class="sb-indenthangingN"><strong>2.</strong>
这里的构造器方法创建了新房屋的引用，然后祝福称为类。换句话说，它创建了
<em>House</em> 类的一个实例。</p>
<p class="sb-indenthangingN"><strong>3.</strong>
现在开始创建实例方法，从而为房屋对象设置属性或者读取属性。</p>
<p class="sb-indenthangingN"><strong>4.</strong>
这里定义的是一个读取方法，用于从房屋对象获取数据。</p>
<p class="sb-indenthangingN"><strong>5.</strong>
现在用户可以开始创建访问对象的实例了。方法是通过
<em>new()</em>
这个构造器方法。第一个参数其实是箭头左边的类名。返回的是一个“祝福”过的房屋对象，被存放到
<em>$house1</em> 变量中。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里又创建了另一个房屋对象
<em>$house2</em>，返回的同样是它的引用。</p>
<p class="sb-indenthangingN"><strong>7.</strong>
一旦我们得到了对象的实例，就可以通过引用定位并为它赋值了。这里的实例方法
<em>set_owner()</em> 默认会收到 <em>$house2</em>
作为第一个参数，也就是箭头左边的变量。这里 Perl
会正确的定位到第二所房子，并且设置它的主人，也就是第二个参数中的
<em>Mr. T</em>。从而覆盖构造器默认填充的属性值 <em>Planet
Bank</em>。</p>
<p class="sb-indenthangingN"><strong>8.</strong>
现在我们会从第一所房子里读取它的主人信息，通过的是
<em>get_owner()</em> 方法。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 这里用 <em>Data::Dumper</em>
函数来显示两所房子的数据。（其实你可以把打印出来的东西存到一个文件里面去，用来重新构造两个对象。）如果你在打印之前设置
<em>$Data::Dumper::Terse=1</em> 的话，输出的 <em>$VAR1</em> 和
<em>$VAR2</em>
变量名就会省去。想要了解更多对象序列化的专题知识的话，请参考
<em><a
href="http://perl.find-info.ru/perl/025/advperl2-chp-4-sect-2.html">http://perl.find-info.ru/perl/025/advperl2-chp-4-sect-2.html</a></em>。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec8">14.2.5 创建一个面向对象模块</h4>
<p class="noindent">在上一个例子中，所有的代码都是都堆放在了一个单独的包文件中。现在是时候来创建一个模块了。</p>
</div>
<p class="indent"><a href="ch14.html#ch14fig04">图
14.4</a>展示了一个简单的面向对象模块的结构，以及用户接口。这里，包装在
<em>.pm</em>
文件里面的是一个模块的定义。文件中的包将被称为是<em>类</em>，也就是
<em>House</em>
类。一般来说，类名要和模块文件名相对应，也就是去掉
<em>.pm</em>
这个附属名的结果。类定义中的子程序，现在叫做
<em>methods</em>
方法，之前的例子中就是这样的。这里定义的第一个方法名叫
<em>new</em>，是一个构造器方法。它的作用是定义并创建对象。用户调用这个模块的这个方法，就可以获得一个新的
<em>House</em>
对象实例。而其他的实例方法则负责存取对象数据。并且只能在拥有对象实例引用的时候，才能调用实例方法。</p>
<div class="fig-heading">
<div class="box">
<hr/>
<p class="noindent"><a id="ch14fig04"/>模块文件，名为 <em>House.pm</em></p>
<hr/>
<p class="codelink"><a id="p465pro01" href="ch14_images.html#p465pro01a">Click here to view code
image</a></p>
<p class="pre1"><span class="EmpStrong">package House</span>;&#160;&#160;# <span
class="EmpItalic">House is the class</span><br/># <span class="EmpItalic">The package name normally matches the filename
minus the .pm extension</span><br/>sub
new{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Constructor method</span><br/>&#160;&#160;&#160;my $class =
shift;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">First argument is the name of the class</span><br/>&#160;&#160;&#160;my $house_obj = {
};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Create the reference/pointer.</span><br/>&#160;&#160;&#160;bless($house_obj, $class);&#160;&#160;&#160;# <span
class="EmpItalic">Bless the referent; Create an object</span><br/>&#160;&#160;&#160;return
$house_obj;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Return a reference to the object</span><br/>}<br/><br/>sub
set_owner{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Access/instance method</span><br/>&#160;&#160;&#160;my $self =
shift;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">First argument is a reference to the object</span><br/>&#160;&#160;&#160;$self-&gt;{"Owner"}=shift;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Sometimes called a "setter" method</span><br/>}<br/>sub
get_owner{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Access/instance method</span><br/>&#160;&#160;&#160;my $self =
shift;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">First argument is a reference to the object</span><br/>&#160;&#160;&#160;return $self-&gt;{"Owner"};&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Sometimes called a "getter" method</span><br/>}<br/><span class="EmpStrong">1</span>;&#160;&#160;# <span class="EmpItalic">Must
return a true value, or module won't load</span></p>
<hr/>
<p class="noindent">The user of the Class; the Perl script, <em>myHouse.plx</em></p>
<hr/>
<p class="codelink"><a id="p465pro02" href="ch14_images.html#p465pro02a">Click here to view code
image</a></p>
<p class="pre1"><span class="EmpStrong">use House;</span>&#160;&#160;# <span
class="EmpItalic">Tell Perl to load House.pm</span><br/><br/>my $house1 = House-&gt;new();&#160;&#160;&#160;# <span
class="EmpItalic">Call class constructor.</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Get back a reference to a new house. Perl
sends</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">the name of the class as its first argument</span><br/>my $house2 = House-&gt;new();&#160;&#160;&#160;# <span
class="EmpItalic">Create another house object</span><br/><br/>$house1-&gt;set_owner("B of A"); # <span class="EmpItalic">Call access
method;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Perl sends the address of the first house</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">object, to method set_owner()</span><br/><br/>print "The owner of the first house is ", $house1-&gt;get_owner, "\n";<br/>&#160;&#160;&#160;&#160;# <span class="EmpItalic">Perl gets the object's
data with the get_owner access method</span></p>
<hr/></div>
</div>
<p class="fig-caption"><strong>图 14.4</strong> 一个简单的面向对象模块。</p>
<p class="indent">请注意：还记得我们在<a href="ch13.html#ch13">第 13 章
模块、封包和发布！</a>部分提醒大家的么？这里的类定义也许多在结尾部分返回真值，也就是用
<em>1;</em> 作为结尾。</p>
<p class="indent"><a id="page_465"/>模块的用户代码需要使用 <em>use Module</em>
语句来载入模块，这个在<a href="ch13.html#ch13">第 13
章</a>中也有提到。</p>
<p class="indent">这个模块可以有很多的实现方法，这里只是其中一种比较简单的。</p>
<div class="heading">
<h5 id="ch14lev3sec11"><a id="page_466"/>给方法传递参数</h5>
<p class="noindent">实例变量是用来初始化新创建的对象的。这样，每当创建对象的时候，就可以对它进行定制。另外，也可以通过构造函数的参数来对实例变量进行设置。这个变量叫做<strong>实例变量</strong>，这是因为它们的创建是在对象实例得到创建时。有时候我们使用匿名哈希，或者匿名数组来存放实例变量。下面的例子中的对象有的是房主和价格属性变量。</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa05"/>例 14.5</p>
<p class="codelink1"><a id="p14exa05" href="ch14_images.html#p14exa05a">Click here to view code
image</a></p>
<p class="pre1">(The Module: <span class="EmpItalic">House.pm</span>)<br/>1&#160;&#160;<span class="EmpStrong">package House;</span><br/>2&#160;&#160;<span class="EmpStrong">sub
new</span>{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Constructor&#160;&#160;method</span><br/>3&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $class =
shift;</span><br/>4&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my ($owner,
$price)</span> = @_;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Instance variables</span><br/>5&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
$ref={"Owner"=&gt;$owner,</span>&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Instance variables to</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"Price"=&gt;$price,</span>&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">initialize the object</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;};<br/>6&#160;&#160;&#160;&#160;&#160;bless($ref, $class);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return $ref;<br/>&#160;&#160;&#160;}<br/>7&#160;&#160;<span class="EmpStrong">sub display_object</span>
{&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">An instance
method</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $self =
shift;</span>&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">A
reference to the object is received</span><br/>8&#160;&#160;&#160;&#160;&#160;foreach $key (keys <span
class="EmpStrong">%$self</span>){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "$key:
$self-&gt;{$key}
\n";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;<br/><br/>-------------------------------------------------------------------<br/><br/>(The Script)<br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">User of the class; another
program</span><br/>9&#160;&#160;<span class="EmpStrong">use House</span>;<br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">my $house1 = new House("Tom
Savage", 250000);</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">Invoking constructor--two
ways.</span><br/>10 <span class="EmpStrong">my $house1 = House-&gt;new("Tom Savage",
250000);</span><br/>11 <span class="EmpStrong">my $house2 = House-&gt;new("Devin Quigley",
55000);</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">Two objects have been
created</span><br/>12 <span class="EmpStrong">$house1-&gt;display_object();</span><br/>13 <span class="EmpStrong">$house2-&gt;display_object();</span><br/>14 print "$house1, $house2\n";<br/><br/>(Output)<br/>12 <span class="EmpItalic">Owner: Tom Savage</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Price: 250000</span><br/>13 <span class="EmpItalic">Owner: Devin Quigley</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Price: 55000</span><br/>14 <span class="EmpItalic">House=HASH(0x9d450), House=HASH(0xa454c)</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里声明的是 <em>House</em>
这个包。（目前，代码中尚未包含任何关于如何使用这个类的信息。关于类的调用方法的文档叫做公共接口。参考<a
href="ch14.html#ch14lev1sec5">14.5
节“古老文档，给模块建档”</a>来了解如何用  Perl
的风格来给模块书写档案。）</p>
<p class="sb-indenthangingN"><strong>2.</strong> 类方法 <em>new</em> 被定义成构造器。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 类方法的第一个参数是类名（或包名）。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 使用 @_
数组的其余参数来构造所谓“实例变量”。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 给引用 <em>$ref</em>
赋值一个匿名哈希的地址。其中的键名是固定的，而键值则来自实例变量。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 引用 <em>$ref</em>
指向的内存被“祝福”成了一个类的对象。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 引用 <em>$ref</em>
会被返回，作为方法调用的结果。下面的
<em>display_object</em>
子程序是一个实例方法。也在类中定义。</p>
<p class="sb-indenthangingNP">实例方法的第一个参数是对象引用。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 这里的 <em>foreach</em> 循环是要对 <em>keys</em>
函数返回的所有哈希（通过 <em>$self</em>
找到的）键进行处理，而实际完成的工作就是打印键值对。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 这里 <em>House.pm</em>
被类的用户代码载入名空间。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 这里调用 <em>new</em>
方法的时候带上了三个参数：<em>House</em>、<em>Tom Savage</em>
和
<em>250000</em>。第一个参数是类名（没有显式发送，而是由
Perl
自动发送的）。剩下的两个参数才是用户显式发送的。这里对参数次序的要求就是：第一个发送的必须是
<em>Owner</em> 值，第二个是 <em>Price</em>
的值。这里没有输入错误的检查代码，因为这个例子只是要展示如何向构造器发送参数。最后，构造器返回的对象引用被赋值到
<em>$house1</em> 变量中。</p>
<p class="sb-indenthangingN1"><strong>11.</strong> 这里再次调用 <em>new</em>
方法来创建对象，参数是不同的：<em>Devin Quigley</em> 和
<em>55000</em>。这个对象被赋值到 <em>$house2</em>
中。你可以如此这样，反复调用 <em>new</em>
方法来创建多个对象。如同第十四行所示，每个对象会拥有不同的地址。而且，因为构造器中的“祝福”，Perl
知道这些对象都是属于 <em>House</em> 类的。</p>
<p class="sb-indenthangingN1"><strong>12.</strong> 这里调用实例方法来打印 <em>$house1</em>
对象的数据。</p>
<p class="sb-indenthangingN1"><strong>13.</strong> 这里再次调用同一个方法，不过打印的是
<em>$house2</em> 对象的数据。</p>
<p class="sb-indenthangingN1"><strong>14.</strong>
这里打印了两个对象的地址。这里能看到，两个地址都打上了
<em>House</em> 类的标签。</p>
<hr/></div>
<div class="heading">
<h5 id="ch14lev3sec12">向实例方法发送参数</h5>
<p class="noindent">实例方法的第一个参数总是对象引用。在被调用的代码中，这个值通常是从
<em>@_</em> 数组中 shift 出来，然后存在一个名叫 <em>$self</em>
或者 <em>$this</em>
的变量中（变量名可以随意选择）。这样，剩下的参数处理起来就和正常的子程序没什么区别了。</p>
</div>
<p class="indent"><a
id="page_468"/>下面的例子展示了带有多个参数的实例方法的调用方法。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa06"/>例 14.6</p>
<p class="codelink1"><a id="p14exa06" href="ch14_images.html#p14exa06a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;#!/bin/perl<br/>&#160;&#160;&#160;# <span class="EmpItalic">Program to demonstrate passing
arguments to an instance method.</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">In this example, a pointer to an
array is passed.</span><br/>1&#160;&#160;package House;&#160;&#160;# <span
class="EmpItalic">Class</span><br/>&#160;&#160;&#160;use warnings;<br/>2&#160;&#160;sub new{&#160;&#160;&#160;# <span
class="EmpItalic">Constructor</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $ref={};&#160;&#160;<span
class="EmpItalic"># Define properties later</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;return bless ($ref, $class);<br/>&#160;&#160;&#160;}<br/><br/>3&#160;&#160;<span class="EmpStrong">sub set_props</span>{&#160;&#160;#
<span class="EmpItalic">Instance methods</span><br/>4&#160;&#160;&#160;&#160;&#160;my $object = shift;&#160;&#160;# <span
class="EmpItalic">Pointer to object</span><br/>5&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my
$val_ptr=shift;</span>&#160;&#160;&#160;# <span class="EmpItalic">Receive
another pointer</span><br/>6&#160;&#160;&#160;&#160;&#160;my <span
class="EmpStrong">($owner,$price,$style)=@{$val_ptr};</span>&#160;&#160;#
<span class="EmpItalic">Create a slice</span><br/>7&#160;&#160;&#160;&#160;&#160;$object-&gt;{"Owner"}=$owner;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$object-&gt;{"Price"}=$price;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$object-&gt;{"Style"}=$style<br/>&#160;&#160;&#160;}<br/>8&#160;&#160;sub get_owner{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $self-&gt;{"Owner"};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;sub get_price{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $self-&gt;{"Price"};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;sub get_address{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $self-&gt;{"Address"};<br/>&#160;&#160;&#160;}<br/><br/>9&#160;&#160;sub display_props{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>10&#160;&#160;&#160;&#160;print "Properties for the ",<span
class="EmpStrong">ref($self)</span>, " are:\n";<br/>11&#160;&#160;&#160;&#160;foreach $key (<span class="EmpStrong">keys
%{$self}</span>){&#160;&#160;# <span class="EmpItalic">Dereference hash
ref</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf
"%-10s%-10s\n",$key,$value;2<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;&#160;&#160;# <span class="EmpItalic">Don't forget
this!</span><br/>--------------------------------------------------------------------<br/><br/>(The Script)<br/>12 use House;<br/>&#160;&#160;&#160;use warnings;<br/>&#160;&#160;&#160;use strict;<br/><a id="page_469"/>13 my $h1=House-&gt;new();<br/>14 $h1-&gt;set_props([ "Unity Bank", "150000", "12 Main St."]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Pass reference</span><br/>&#160;&#160;&#160;$h1-&gt;display_props();<br/><br/>&#160;&#160;&#160;my $h2=House-&gt;new();<br/>15 $h2-&gt;set_props([ "Pierre Dupont", "150000","Pacific Ridge" ]);<br/>&#160;&#160;&#160;$h2-&gt;display_props();<br/><br/>(Output)<br/><span class="EmpItalic">Owner&#160;&#160;&#160;&#160;&#160;Unity Bank</span><br/><span class="EmpItalic">Address&#160;&#160;&#160;12 Main St.</span><br/><span class="EmpItalic">Price&#160;&#160;&#160;&#160;&#160;150000</span><br/><span class="EmpItalic">Owner&#160;&#160;&#160;&#160;&#160;Pierre
Dupont</span><br/><span class="EmpItalic">Address&#160;&#160;&#160;10 Pacific Ridge</span><br/><span class="EmpItalic">Price&#160;&#160;&#160;&#160;&#160;1500000</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 声明 <em>House</em> 类。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这个 <em>new</em>
方法是构造器。对象来自于一个空的匿名哈希。哈希的键值对，也就是对象的<strong>属性</strong>会稍后赋值。这个
<em>$ref</em> 引用指向的对象，被祝福成属于 <em>House</em>
类。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里定义的是实例方法 <em>set_props</em>。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 第一个参数是对 <em>House</em>
对象的引用。这个参数从 @_ 数组 shift 出来之后赋值给
<em>$object</em>。其实这个变量名可以是 <em>$this</em> 或者
<em>$self</em>，都可以。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 第二个参数也从 <em>@_</em> 中 shift
出来，这次是一个数组引用。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里把 <em>$val_ptr</em>
解引用成一个列表，从而获取传入的数据。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 现在把传入的数据赋值到对象里面。</p>
<p class="sb-indenthangingN"><strong>8.</strong>
这里定义的都是从对象中读取数据的实例方法。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 这里打印哈希中的所有属性的值。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 这里调用内建函数
<em>ref</em>，对于输入的对象引用来说，会返回对应的类名。</p>
<p class="sb-indenthangingN1"><strong>11.</strong>
因为对象实际上是一个哈希引用，所以我们可以用
<em>%$self</em>
来解引用，获得键值对。下面，模块的用户代码就把这个模块载入代码中。</p>
<p class="sb-indenthangingN1"><strong>13.</strong> 对于构造器 <em>new()</em>
的调用返回一个新的、祝福过的房子。</p>
<p class="sb-indenthangingN1"><strong>14.</strong> 这里通过 <em>set_props()</em>
实例方法来设置属性的值。第一个隐含的参数是对象引用（箭头操作符左边的东西）。第二个参数是一个匿名数组的引用（在方括号里面的东西），其中的元素会用来设置对象的属性。</p>
<p class="sb-indenthangingN1"><strong>15.</strong> 同样通过 <em>set_props()</em>
这个实例方法来为第二个对象属性赋值。</p>
<hr/></div>
<div class="heading">
<h5 id="ch14lev3sec13"><a id="page_470"/>命名参数和数据检查</h5>
<p class="noindent">目前所有的例子都是关于 <em>House</em>
对象的。下面的例子中，我们会创建一个 <em>Employee</em>
对象。它的构造器会使用参数来设置员工的属性。如果构造器规定了名字、地址和工资的输入顺序，那么参数的顺序出错就会带来没必须要的麻烦：地址成了名字、或者名字成了工资，等等。要避免这样的麻烦，其中一个方法就是用哈希来传递参数。这样的键值对形式就会比较容易一些（当然，拼写错误也会带来其他的问题）。下面的例子展示了如何使用命名参数。</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa07"/>例 14.7</p>
<p class="codelink1"><a id="p14exa07" href="ch14_images.html#p14exa07a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;# <span class="EmpItalic">User of Employee.pm--See Example
14.8 for module</span><br/>1&#160;&#160;<span class="EmpStrong">use Employee;</span><br/>2&#160;&#160;use warnings;<br/>&#160;&#160;&#160;use strict;<br/>3&#160;&#160;my($name, $extension, $address, $basepay, $employee); # <span
class="EmpItalic">Declare</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">my variables</span><br/>4&#160;&#160;print "Enter the employee's name. ";<br/>&#160;&#160;&#160;chomp($name=&lt;STDIN&gt;);<br/>&#160;&#160;&#160;print "Enter the employee's phone extension. ";<br/>&#160;&#160;&#160;chomp($extension=&lt;STDIN&gt;);<br/>&#160;&#160;&#160;print "Enter the employee's address. ";<br/>&#160;&#160;&#160;chomp($address=&lt;STDIN&gt;);<br/>&#160;&#160;&#160;print "Enter the employee's basepay. ";<br/>&#160;&#160;&#160;chomp($basepay=&lt;STDIN&gt;);<br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">Passing arguments as a
hash</span><br/>5&#160;&#160;<span class="EmpStrong">$employee = Employee-&gt;new(</span>
"_<span class="EmpStrong">Name</span>"<span
class="EmpStrong">=&gt;$name,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">Address</span>"<span
class="EmpStrong">=&gt;$address,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">Extension</span>"<span
class="EmpStrong">=&gt;$extension,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">PayCheck</span>"<span
class="EmpStrong">=&gt;$basepay,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">);</span><br/>&#160;&#160;&#160;print "\nThe statistics for $name are: \n";<br/><br/>6&#160;&#160;$employee-&gt;get_stats;<br/><br/>(Output)<br/><span class="EmpItalic">Enter the employee's name. Daniel Savage</span><br/><span class="EmpItalic">Enter the employee's phone extension. 2534</span><br/><span class="EmpItalic">Enter the employee's address. 999 Mission Ave,
Somewhere, CA</span><br/><span class="EmpItalic">Enter the employee's basepay. 2200</span><br/><br/><span class="EmpItalic">The statistics for Daniel Savage are:</span><br/><span class="EmpItalic">Address = 999 Mission Ave, Somewhere, CA</span><br/><span class="EmpItalic">PayCheck = 2200</span><br/><span class="EmpItalic">IdNum = Employee Id not provided!</span><br/><span class="EmpItalic">Extension = 2534</span><br/><span class="EmpItalic">Name = Daniel Savage</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_471"/>注释</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这个程序会用到 <em>Employee.pm</em> 模块。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 为了避免可能的错误，用到了
<em>warnings</em>。而 <em>strict</em>
的使用则是为了跟踪全局变量，以及未定义的变量的意外使用，还有裸字等等。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 创建了一系列的词法私有变量。</p>
<p class="sb-indenthangingN"><strong>4.</strong>
运行此程序的时候，用户会被提示输入一些信息，然后传递给
<em>Employee</em> 模块。</p>
<p class="sb-indenthangingN"><strong>5.</strong>
调用构造器的时候发送给它的参数是键值对。也就是说发送给
<em>Employee</em>
的构造器的是一个哈希。结果是返回了一个对象引用，并赋值到
<em>$employee</em>。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 调用实例方法 <em>get_stats</em>
来打印员工的属性。</p>
<hr/></div>
<p class="indent">下面的例子则显示了模块是如果处理命名参数的。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa08"/>例 14.8</p>
<p class="codelink1"><a id="p14exa08" href="ch14_images.html#p14exa08a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;# <span class="EmpItalic">Module Employee.pm--See Example
14.7 to use this module.</span><br/>1&#160;&#160;<span class="EmpStrong">package Employee;</span><br/>2&#160;&#160;use Carp;<br/>3&#160;&#160;<span class="EmpStrong">sub new</span> {<br/>4&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>5&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">my(%params)=@_;</span>&#160;&#160;&#160;# <span
class="EmpItalic">Receiving the hash that was passed</span><br/>6&#160;&#160;&#160;&#160;&#160;my $ref={<br/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">Name</span>"<span
class="EmpStrong">=&gt;$params{</span>"_<span
class="EmpStrong">Name</span>"<span class="EmpStrong">}</span> || croak("No
name assigned"),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">Extension</span>"<span
class="EmpStrong">=&gt;$params{</span>"_<span
class="EmpStrong">Extension</span>"<span class="EmpStrong">}</span>,<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">Address</span>"<span
class="EmpStrong">=&gt;$params{</span>"_<span
class="EmpStrong">Address</span>"<span class="EmpStrong">}</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_<span
class="EmpStrong">PayCheck</span>"<span
class="EmpStrong">=&gt;$params{</span>"_<span
class="EmpStrong">PayCheck</span>"} ||<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;croak("No pay
assigned"),<br/>9&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">((defined
$params{"_IdNum"})?("_IdNum"=&gt;$params{"_IdNum"}):</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">croak "Employee's id was not provided!\n"</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">);</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;};<br/>10 return bless($ref,$class);<br/>&#160;&#160;&#160;}<br/>11 <span class="EmpStrong">sub get_stats</span>{<br/>12&#160;&#160;&#160;&#160;my $self=shift;<br/>13&#160;&#160;&#160;&#160;foreach my $key <span class="EmpStrong">(keys
%params, %$self)</span>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print $key, " = ",
$self-&gt;{$key}, "\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_472"/>Explanation</p>
<p class="sb-indenthangingN"><strong>1.</strong> The class <em>Employee</em> is declared.</p>
<p class="sb-indenthangingN"><strong>2.</strong> 标准 Perl 库中输出的 <em>Carp</em>
模块可以辅助对错误信息进行打印。所以，这里我们没有用内建的
<em>die</em> 函数，而是使用 <em>Carp</em> 模块提供的
<em>croak</em>
方法来捕获错误并退出，同时打印错误的详细信息。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里定义了构造器方法 <em>new</em>。</p>
<p class="sb-indenthangingN"><strong>4.</strong>
构造器方法的第一个参数是类名。这里我们把它从
<em>@_</em> 数组 shift 出来，并赋值给 <em>$class</em>。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里把 <em>@_</em> 数组剩余的参数赋值给
<em>%params</em>
这个哈希。而它们是通过键值对的顺序发送给构造器的。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里把一个匿名哈希的引用赋值到
<em>$ref</em> 中去。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里的键 <em>Name</em>
被赋予一个值，而值的来源是 <em>%params</em>
哈希。所以，有必要进行错误检查。如果 <em>Name</em>
键没有对应的值，<em>croak</em>
函数就会被调用并退出，从而使用户知道因为 <em>Name</em>
键没有对应的值而导致程序退出。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 同样的方法从 <em>%params</em> 哈希中拷贝得
<em>Address</em> 属性的值。</p>
<p class="sb-indenthangingN"><strong>9.</strong>
这个例子展示了如何检查用户向模块输入的参数。这里的条件赋值语句可以这样读：如果
<em>%params</em> 中有个名为 <em>IdNum</em>
的键有定义的值，那么将这个值赋值给
<em>IdNum</em>；否则就提示用户忘记了输入这个参数。前面的例子中使用了
<em>croak</em>
函数，会因为参数为空导致程序退出。而这里因为采用了不同的检查方法，就可以让程序继续运行下去。</p>
<p class="sb-indenthangingN1"><strong>10.</strong>
在属性赋值之后，对象引用被祝福成类的成员，并返回给调用者。</p>
<p class="sb-indenthangingN1"><strong>11.</strong> 这里定义了实例方法 <em>get_stats</em>。</p>
<p class="sb-indenthangingN1"><strong>12.</strong> 第一个参数从 <em>@_</em> 数组中 shift
出来，并赋值给 <em>$self</em>。这是一个对象的引用。</p>
<p class="sb-indenthangingN1"><strong>13.</strong> 这里进入了 <em>foreach</em>
循环。调用了内置的 <em>keys</em>
函数来获取对象的所有键。下一行打印所有的键和对应的值。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec9">14.2.6 多态和运行时绑定</h4>
<p class="noindent"><em>韦氏字典</em>把多态定义为：</p>
</div>
<p class="blockquote">多态：<em>名词</em> 呈现多种形状的状态或条件。<sup><a
id="ch14fn5a" href="ch14.html#ch14fn5">5</a></sup></p>
<p class="footnote"><a id="ch14fn5" href="ch14.html#ch14fn5a">5</a>. <em>Webster&#8217;s
Encyclopedic Unabridged Dictionary of the English Language</em>, Random
House Value Publishing: Avenel, NJ, 1996, p. 1500.</p>
<p class="noindent">哦，这等于是说 1+1=2！下面的定义来自 Webopedia.com：</p>
<p class="blockquote">也就是说，呈现多种形式的能力。对于面向对象编程来说，多态意味着编程语言有能力对不同的对象（按照数据类型或类的不同而）执行不同的逻辑的能力。</p>
<p class="indent"><a
id="page_473">多态也可以换成其他的专业词汇来描述，而且不论哪种面向对象的术语都绕不开这个概念。中心思想就是同样的方法名可以对应不同的处理逻辑。换句话说，你可以给多个类定义同样名字的方法，而调用的时候不会搞混了。也就是说，只要对象引用正确的话，相应的类总是能找到正确的方法来调用。</p>
<p class="indent">现在让我们进入下一个例子。这次我们来看三个模块：<em>BasketballPlayer.pm</em>、<em>Director.pm</em>
和 <em>Rifleman.pm</em>。这些模块都有一个叫做 <em>shoot()</em>
的方法。而调用模块的代码会载入这三个模块。在它们的构造器得到调用的时候，会返回相应的祝福过的对象引用。当实例方法被调用的时候，因为
Perl 会发送对象引用作为方法的第一个参数，所以 Perl
明白对象属于哪个类，也知道要调用的方法是哪个（哪怕方法的名字完全一样）。Perl
能够查找到对象所属的类（也就是包）中正确的方法来调用，这个能力就是所谓的多态。</p>
<p class="indent">当你调用函数或者方法的时候，调用必须关联到（或者说绑定）函数或方法的定义代码。这会发生在编译时或者运行时。运行时绑定，它能允许程序推后方法的判定，直到程序运行起来以后。也就是说，一旦程序知道调用方法的对象是什么，它就能正确绑定。通过多态和运行时绑定，程序就可以在不使用
<em>if</em>
语句的情况下正确调用（所属类的）方法。这使得继承机制能够非常灵活的实施。</p>
<p class="indent">要想使用多态和运行时绑定的特性，就必须通过面向对象语法来调用，而不能使用
<em>::</em> 语法。假设你有两个类：<em>Director</em> 和
<em>Rifleman</em>。而这两个类都有一个实例方法叫做
<em>shoot</em>。只要你书写 <em>$object</em>-<em>&gt;shoot()</em>
这样的代码，Perl 就能了解到对象所属的类，因为
<em>shoot()</em>
的第一个参数永远都是对象引用（是在构造器中用“祝福”的方法打上编译时的类标签的）。这样就可以放心，<em>Director</em>
不会在开机时射出子弹，而 <em>Rifleman</em>
也不会用摄像机瞄准猎物。当然，你也可以增加更多的类，比如
<em>BasketballPlayer</em>，也带有一个 <em>shoot()</em>
方法。并且，这时候所有的机制仍然可以正常工作。倘若没有运行时绑定和多态，就只能（像下面的例子一样）通过许多条件语句来找到正确的方法调用了：</p>
<p class="codelink"><a id="p473pro01" href="ch14_images.html#p473pro01a">Click here to view code
image</a></p>
<p class="pre">if ( ref($object1) eq "Director") {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;Director::shoot($object1);<br/>elsif ( ref($object2) eq "Rifleman" ){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rifleman::shoot($object2);<br/>else{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;BasketballPlayer::shoot($object3);<br/>}</p>
<p class="noindent">只是，万一你调用 <em>shoot()</em>
的时候发送了错误的对象参数呢？使用面向对象语法的时候就不必担心这点，因为对象引用是自动发送的。所以，就是通过这种类似于潜意识的对象参数发送，以及在祝福时候进行类标记，Perl
就能够实现多态调用机制。如同下面的例子所示，我们用
<em>Director</em> 类来创建 <em>$object1</em>，用 <em>Rifleman</em>
类来创建 <em>$object2</em>，而 <em>$object3</em> 则是用
<em>BasketballPlayer</em> 类创建的。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa09"/>例 14.9</p>
<p class="codelink1"><a id="p14exa09" href="ch14_images.html#p14exa09a">Click here to view code
image</a></p>
<p class="pre1">$object1-&gt;shoot;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">evaluates to</span>&#160;&#160;Director::shoot($object1);<br/>$object2-&gt;shoot;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">evaluates to</span>&#160;&#160;Rifleman::shoot($object2);<br/>$object3-&gt;shoot;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">evaluates
to</span>&#160;&#160;BasketballPlayer::shoot($object3);</p>
<hr/></div>
<p class="indent">下面的例子就是用来说明多态的。下面的三个类，都有各自的构造器（并不是同样的方法名），而
<em>shoot()</em> 这个方法则是三个类共同拥有的。</p>
<p class="indent">用户代码会载入所有三个模块并且创建每个类的实例。每当
<em>shoot()</em> 方法被调用的时候，Perl
总会默默发送对象引用参数。因为 <em>shoot()</em>
会收到祝福过的对象引用，就不会弄错该调用的代码。Perl
能正确定位到所属类当中的方法代码，并运行。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa10"/>例 14.10</p>
<p class="codelink1"><a id="p14exa10" href="ch14_images.html#p14exa10a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;#----------File: BasketballPlayer.pm<br/>1&#160;&#160;<span class="EmpStrong">package
BasketballPlayer;</span>&#160;&#160;# <span class="EmpItalic">Class</span><br/>&#160;&#160;&#160;sub new{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($name, $team, $position)=@_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $player={<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Name"=&gt;$name,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Team"=&gt;$team,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Position"=&gt;$position,<br/>&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;&#160;&#160;return bless($player, $class);<br/>&#160;&#160;&#160;}<br/>2&#160;&#160;<span class="EmpStrong">sub shoot</span> {&#160;&#160;# <span
class="EmpItalic">Instance method for the basketball player</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "$self-&gt;{'Name'} was a
$self-&gt;{'Position'}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;and shot baskets
for the $self-&gt;{Team}.\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;<br/>&#160;&#160;&#160;#----------------File: Director.pm<br/>3&#160;&#160;<span class="EmpStrong">package Director;</span>&#160;&#160;#
<span class="EmpItalic">Class</span><br/>&#160;&#160;&#160;sub new{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $info_ptr=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $director={<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Name"=&gt;$info_ptr-&gt;{"Name"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Movie"=&gt;$info_ptr-&gt;{"Movie"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Type"=&gt;$info_ptr-&gt;{"Type"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;};&#160;&#160;&#160;&#160;&#160;&#160;return
bless($director, $class);<br/>&#160;&#160;&#160;}<br/><a id="page_475"/>4&#160;&#160;<span class="EmpStrong">sub
shoot</span>{&#160;&#160;# <span class="EmpItalic">Instance method for the
director</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "$self-&gt;{'Name'} is shooting
the movie $self-&gt;{'Movie'}.\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;<br/>&#160;&#160;&#160;#----------------File: Rifleman.pm<br/>5&#160;&#160;<span class="EmpStrong">package Rifleman;</span>&#160;&#160;#
<span class="EmpItalic">Class</span><br/>&#160;&#160;&#160;sub init{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($name, $shooting_range)=@_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $rifleman={<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Name"=&gt;$name,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Range"=&gt;$shooting_range,<br/>&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;&#160;&#160;return bless($rifleman, $class);<br/>&#160;&#160;&#160;}<br/>6&#160;&#160;<span class="EmpStrong">sub shoot</span>{&#160;&#160;# <span
class="EmpItalic">Instance method for the rifleman</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "$self-&gt;{'Name'} went to the
$self-&gt;{'Range'} range to shoot<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;target&#160;&#160;&#160;&#160;s.\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;<br/>&#160;&#160;&#160;-------------------File: user.plx-------------------------<br/>7&#160;&#160;<span class="EmpStrong">use BasketballPlayer;</span><br/>&#160;&#160;&#160;<span class="EmpStrong">use Director;</span><br/>&#160;&#160;&#160;<span class="EmpStrong">use Rifleman;</span><br/>&#160;&#160;&#160;use feature qw(say);<br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">Create instances of each
class</span><br/>8&#160;&#160;<span
class="EmpStrong">$ballplayer</span>=BasketballPlayer-&gt;new("Wilt
Chamberlain",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Boston
Globe Trotters",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"center");<br/>9&#160;&#160;<span
class="EmpStrong">$movie_director</span>=Director-&gt;new(
{"Name"=&gt;"Steve McQueen",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Movie"=&gt;"12
Years A Slave",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Type"=&gt;"Historical
Drama"}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>10 <span class="EmpStrong">$gunman</span>=Rifleman-&gt;init("Lucas McCain",
"North Fork Range");<br/>11 say "The basketball player is a ", <span class="EmpStrong">ref
$ballplayer</span>;<br/>12 say "The director is a ", <span class="EmpStrong">ref
$movie_director</span>;<br/>13 say "The rifleman is a ", <span class="EmpStrong">ref $gunman</span>;<br/>14 <span class="EmpStrong">$ballplayer-&gt;shoot();&#160;&#160;#</span>
<span class="EmpItalic">polymorphism</span><br/>15 <span class="EmpStrong">$movie_director-&gt;shoot();</span><br/>16 <span class="EmpStrong">$gunman-&gt;shoot();</span><br/><br/>(Output)<br/>11 <span class="EmpItalic">The basketball player is a
BasketballPlayer</span><br/>12 <span class="EmpItalic">The director is a Director</span><br/>13 <span class="EmpItalic">The rifleman is a Rifleman</span><br/>14 <span class="EmpItalic">Wilt Chamberlain was a center and shot baskets
for the Boston Globe</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Trotters.</span><br/>15 <span class="EmpItalic">Steve McQueen is shooting the movie 12 Years A
Slave.</span><br/>16 <span class="EmpItalic">Lucas McCain went to the North Fork Range range
to shoot targets.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_476"/>代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这是 <em>BasketballPlayer</em>
类，带有构造器和实例变量。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这是 <em>BasketballPlayer</em> 类的 <em>shoot()</em>
实例方法。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 现在进入 <em>Director</em> 类，也带有名为
<em>new()</em> 的构造器和实例变量。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这是 <em>Director</em> 类的 <em>shoot()</em>
实例方法。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 现在进入 <em>Rifleman</em> 类，带有名为
<em>init()</em> 的构造器和实例变量。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这是 <em>Rifleman</em> 类的 <em>shoot()</em>
实例方法。</p>
<p class="sb-indenthangingN"><strong>7.</strong>
用户程序首先载入三个类：<em>BasketballPlayer</em>、<em>Director</em>
和 <em>Rifleman</em>。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 调用 <em>BasketballPlayer</em> 的构造器来获得
<em>BasketballPlayer</em> 类新实例的引用。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 调用 <em>Director</em> 的构造器来获得
<em>Director</em> 类新实例的引用。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 调用 <em>Rifleman</em> 的构造器来获得
<em>Rifleman</em> 类新实例的引用。</p>
<p class="sb-indenthangingN1"><strong>11.</strong> Perl 内置的 <em>ref</em>
函数，调用参数是对象引用，返回的结果是类名（而不是对象变量类型）。对于未被祝福过的引用，返回的结果就是类似于
<em>HASH</em>
这样的字符串。这个例子是让你看到对象引用对应的类标签。</p>
<p class="sb-indenthangingN4"><strong>14&#8211;16.</strong>
多态通过对三个不同类型对象调用各自的 <em>shoot()</em>
方法来显明。因为 Perl
会把对象引用作为第一个参数传递，因此这里不会弄错要调用的代码。祝福过的对象引用如下所示：</p>
<p class="sb-indenthangingNP"><em>BasketballPlayer=HASH(0x7ff98a004ff0),</em></p>
<p class="sb-indenthangingNP"><em>Director=HASH(0x7ff98a033128),</em></p>
<p class="sb-indenthangingNP"><em>Rifleman=HASH(0x7ff98a02d4d8)</em></p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec10">14.2.7 析构器和垃圾回收机制</h4>
<p class="noindent">Perl
时刻跟踪着对象的引用计数，这样可以在引用计数为零是自动销毁对象。如果引用超出了代码的语法范围，Perl
就会触发垃圾收集机制，对失去引用的对象进行销毁并释放内存。所以，你不必担心内存会意外的浪费掉。<sup><a
id="ch14fn6a"
href="ch14.html#ch14fn6">6</a></sup>不过，你还是可以定义
<em>DESTROY</em> 方法来将对象的销毁进行自定义的控制。</p>
</div>
<p class="footnote"><a id="ch14fn6"
href="ch14.html#ch14fn6a">6</a>.
如果你定义了一个自引用的数据结构，那么就得自己负责数据对象的销毁。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="page_477"/><a id="ch14exa11"/>例 14.11</p>
<p class="codelink1"><a id="p14exa11" href="ch14_images.html#p14exa11a">Click here to view code
image</a></p>
<p class="pre1">(The Class)<br/>1&#160;&#160;package Employee;<br/>&#160;&#160;&#160;sub new{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $name = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $ref={"Name"=&gt;$name};<br/>&#160;&#160;&#160;&#160;&#160;&#160;bless($ref, $class);<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $ref;<br/>&#160;&#160;&#160;}<br/><br/>2&#160;&#160;<span class="EmpStrong">sub DESTROY{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $self =
shift;</span><br/>3&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">print "Employee
$self-&gt;{Name} is being destroyed.\n";</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><br/>&#160;&#160;&#160;1;<br/>&#160;&#160;&#160;---------------------------------------------------------------<br/><br/>(The Script)<br/>&#160;&#160;&#160;# <span class="EmpItalic">User of the class</span><br/>4&#160;&#160;<span class="EmpStrong">use Employee;</span><br/>5&#160;&#160;my $emp1 = Employee-&gt;new("1: Daniel");<br/>6&#160;&#160;<span class="EmpStrong">{</span> my $emp2 =
Employee-&gt;new("2: Tom");&#160;&#160;# <span class="EmpItalic">Lexical
scoping</span><br/>7&#160;&#160;&#160;&#160;print "I'm being destroyed.\n";<br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>8&#160;&#160;my $emp3 = Employee-&gt;new("3: Jenny");&#160;&#160;# <span
class="EmpItalic">Create the object</span><br/><br/>(Output)<br/>7&#160;&#160;<span class="EmpItalic">I'm being destroyed.</span><br/>6&#160;&#160;<span class="EmpItalic">Employee 2: Tom is being
destroyed.</span><br/>5&#160;&#160;<span class="EmpItalic">Employee 1: Daniel is being
destroyed.</span><br/>8&#160;&#160;<span class="EmpItalic">Employee 3: Jenny is being
destroyed.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> <em>Employee</em>
类在此得到声明，也同时定义了构造器方法。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 当 <em>Employee</em>
对象不再有存在的必要时，<em>DESTROY</em>
方法被调用，并打印这行信息。第六行的对象是定义在一个块中的。所以，当这块代码执行完毕之后，它就没有存在的必要了。而其他对象要等到整个程序退出时才消亡。</p>
<p class="sb-indenthangingN"><strong>3.</strong>
每当某个对象失去存在的意义时，这一行就被打印出来。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里载入 <em>Employee</em> 模块。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里通过构造器创建了 <em>Employee</em>
类的一个对象引用
<em>$emp1</em>，这个员工的名字是参数中的 <em>Daniel</em>。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里又在块里面创建了一个 <em>Employee</em>
对象。这个对象被赋予了一个 <em>Tom</em>
的名字。因为这个对象是用 <em>my</em>
创建的，所以只能存活在语法范围内。因此，一旦块执行完毕，这个对象就已经没必要存在了，因此会调用它的
<em>DESTROY</em> 方法，然后清理为它分配的内存。</p>
<p class="sb-indenthangingN"><a id="page_478"/><strong>7.</strong> 这一行打印的顺序在名为
<em>Tom</em> 的对象消亡之前。然后 <em>Employee</em>
对象被赋予了键值，然后就是 <em>DESTROY</em> 调用的时机。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 最后又是一个对象（名为
Jenny）被创建，也是这个程序退出之前最后销毁的对象。</p>
<hr/></div>
<div class="heading">
<h3 id="ch14lev1sec3">14.3 匿名子程序、闭包和私有数据</h3>
<p class="noindent">目前我们所有的面向对象代码中都有一个问题，那就是用户可以通过引用来随意操纵数据修改。哪怕我们告诉他们必须通过模块方法来访问对象，仍然没有什么机制能阻止他们来直接访问对象内部的数据。这是因为
Perl
并没有什么特殊的机制来保护类中的数据私有性。不过，对于那些认为无法实现私有数据就不能算面向对象语言的人来说，Perl其实是有许多种方法来做到这点的。其中一种就是使用闭包。</p>
</div>
<div class="heading">
<h4 id="ch14lev2sec11">14.3.1 什么是闭包？</h4>
<p class="noindent">Larry Wall 把闭包说成是一个有态度的匿名函数<sup><a
id="ch14fn7a" href="ch14.html#ch14fn7">7</a></sup> 。Barrie Slaymaker
则把闭包说成是“内衣外穿的对象”。因为对象其实是带有子程序的数据，而闭包则是带有数据的子程序。</p>
</div>
<p class="footnote"><a id="ch14fn7" href="ch14.html#ch14fn7a">7</a>. Perl
编程，第三版，第 262 页；O’Reilly 出版社，Sebastopol
加州，2000 年由 Larry Wall、Tom Christianson 和  Jon Orwant 合著。</p>
<p class="indent">闭包就是一个子程序，它总能保持对 <em>my</em>
变量的访问，哪怕调用的位置已经越过了变量定义所在的块范围也是如此。这个子程序似乎“贴伏”着这些词法变量，在每次调用时都能重用同一组变量。而这些词法变量也总是活跃，直到所有的引用都不再活跃为止。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa12"/>例 14.12</p>
<p class="codelink1"><a id="p14exa12" href="ch14_images.html#p14exa12a">Click here to view code
image</a></p>
<p class="pre1">(The Script)<br/>1&#160;&#160;my $name="Tommy";<br/><br/>2&#160;&#160;{&#160;&#160;my $name = "Grandfather";&#160;&#160;# <span
class="EmpItalic">Lexical variables</span><br/>3&#160;&#160;&#160;&#160;&#160;my $age = 86;<br/>4&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">$ref = sub{ return
"$name is $age.\n"; }</span>&#160;&#160;# <span class="EmpItalic">Anonymous
subroutine</span><br/>&#160;&#160;&#160;}<br/>5&#160;&#160;print "$name is back\n";<br/>6&#160;&#160;<span class="EmpStrong">print $ref-&gt;();</span>&#160;&#160;#
<span class="EmpItalic">Call to subroutine outside the block</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Could also call subroutine with this syntax:
&#38;{$ref};</span><br/><a id="page_479"/>(Output)<br/>5&#160;&#160;<span class="EmpItalic">Tommy is back.</span><br/>6&#160;&#160;<span class="EmpItalic">Grandfather is 86.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里给词法变量 <em>$name</em> 赋值
<em>Tommy</em>。这个变量的生存周期从这里延伸到程序的末尾。</p>
<p class="sb-indenthangingN"><strong>2.</strong>
程序再次进入一个块中。这里给一个新的词法变量
<em>$name</em> 赋值
<em>Grandfather</em>。这个变量直到块的结尾都是有效的。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里定义了另一个词法变量
<em>$age</em>，它也是从此直到快结尾有效。</p>
<p class="sb-indenthangingN"><strong>4.</strong>
在同一个块内又定义了一个匿名子程序，它引用了同一个块内的两个词法变量（也就是
<em>my</em> 变量：<em>$name</em> 和
<em>$age</em>）。然后把这个子程序的引用赋值给
<em>$ref</em>。这个子程序，不论在哪里调用，总是可以访问这两个变量。这个子程序就被称为闭包，因为不论怎么调用，它必然能够访问所在块内的变量。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 执行到这里，<em>$name</em> 的值又变成了
<em>Tommy</em>。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 匿名子程序通过 <em>$ref</em>
引用得到调用。词法变量看似已经超出了生存周期，但是却仍然存在。这是因为引用的存在导致变量不能被释放。只要引用尚存，Perl
就永远不能释放这些变量。</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa13"/>例 14.13</p>
<p class="codelink1"><a id="p14exa13" href="ch14_images.html#p14exa13a">Click here to view code
image</a></p>
<p class="pre1">(The Script)<br/>&#160;&#160;&#160;# <span class="EmpItalic">Closure</span><br/>1&#160;&#160;sub paint {<br/>2&#160;&#160;&#160;&#160;&#160;my $color = shift;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">@_ array is shifted</span><br/>3&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $ref = sub</span>
{&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">Pointer
to an anonymous subroutine</span><br/>4&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;my $object=shift;<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "Paint the $object
$color.\n"; # <span class="EmpItalic">$color still in scope</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;};<br/>6&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return
$ref;</span>&#160;&#160;&#160;&#160;# <span class="EmpItalic">Returns a
pointer (closure)</span><br/>&#160;&#160;&#160;}<br/><br/>7&#160;&#160;<span class="EmpStrong">my $p1</span>=paint("red"); # <span
class="EmpItalic">$p1 is a pointer to anonymous subroutine</span><br/>&#160;&#160;&#160;<span class="EmpStrong">my $p2</span>=paint("blue");<br/>8&#160;&#160;<span class="EmpStrong">$p1-&gt;("flower");</span>&#160;&#160;#
<span class="EmpItalic">Call to anonymous subroutine</span><br/>9&#160;&#160;<span class="EmpStrong">$p2-&gt;("sky");</span><br/>10 use Data::Dumper;<br/>&#160;&#160;&#160;<span class="EmpStrong">$Data::Dumper::Deparse=1;</span><br/><br/>11 print Dumper $p1, $p2;<br/><a id="page_480"/>(Output)<br/>5&#160;&#160;<span class="EmpItalic">Paint the flower red.</span><br/>5&#160;&#160;<span class="EmpItalic">Paint the sky blue.</span><br/>&#160;&#160;&#160;&#160;<span class="EmpItalic">&lt; Data::Dumper
Output&gt;</span><br/>10 <span class="EmpItalic">$VAR1 = sub {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">my $object =
shift();</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">print "Paint the
$object $color.\n";</span><br/>&#160;&#160;&#160;<span class="EmpItalic">};</span><br/>&#160;&#160;&#160;<span class="EmpItalic">$VAR2 = sub {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">my $object =
shift();</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">print "Paint the
$object $color.\n";</span><br/>&#160;&#160;&#160;<span class="EmpItalic">};</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里定义了 <em>paint()</em> 子程序。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这里从 <em>@_</em>
数组中取出值并赋予词法变量 <em>$color</em>。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里把一个匿名子程序的引用赋予
<em>$ref</em>。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这个匿名子程序从 <em>@_</em>
数组中提取一个参数出来。这里提取的值放在
<em>$object</em> 中，第一次提取出来的值是
<em>flower</em>，而第二次提取出来的是 <em>sky</em>。</p>
<p class="sb-indenthangingN"><strong>5.</strong>
这里是闭包真正开始工作的部分。因为之前的词法变量
<em>$color</em> 仍然在作用范围内，而且它会一直存在，哪怕
<em>paint()</em>
子程序调用并退出了也是一样。原因就是匿名子程序仍然需要它的存在。所以，无论何时，<em>$color</em>
都可以使用。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里的 <em>paint()</em>
子程序返回了一个对匿名子程序的引用。如果打印出来的话，引用的内容看上去是这样的：<em>(CODE(0x100804ee8))</em>。引用导致了闭包的存在，也保存了词法变量
<em>$color</em>。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里两次调用 <em>paint()</em>
子程序，并且每次参数都不同。每当 <em>paint()</em>
被调用时候，Perl 都会创建一个新的词法标量
<em>$color</em>。并且每次的值都不同。然后这个变量因为返回的引用而被闭包保护起来。所以，<em>$p1</em>
对应的闭包变量 <em>$color</em> 的值是 <em>red</em>，而
<em>$p2</em> 对应的闭包变量 <em>$color</em> 的值则是
<em>blue</em>。你可以通过在调用 <em>paint()</em> 时打印
<em>\$color</em> 来确认每个变量的地址是不同的。</p>
<p class="pre1">&#160;&#160;&#160;&#160;&#160;&#160;SCALAR(0x7f947382db80)<br/>&#160;&#160;&#160;&#160;&#160;&#160;SCALAR(0x7f947382d4c0)</p>
<p class="sb-indenthangingN"><strong>8, 9.</strong> <em>$p1</em> 和 <em>$p2</em>
其实都是指向第三行定义的匿名子程序的引用。只是因为闭包的存在，导致它们在访问
<em>paint()</em> 定义的 <em>$color</em>
变量的时候访问的是不同的版本。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 我们可以使用 <em>Data::Dumper</em>
来打印出代码引用的内容，但是如果我们不把
<em>$Data::Dumper::Deparse</em>
变量设置为一，就不能打印出匿名子程序的内容，而只能打印出
<em>DUMMY</em>。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec12"><a id="page_481"/>14.3.2 闭包和对象</h4>
<p class="noindent">闭包的作用就是让对象能够隐藏数据，从而避免用户直接存取对象的敏感数据。具体来说，就是在构造器中定义对象的数据，然后用一个匿名子程序来形成闭包。在进行祝福的时候，不是对数据（比如哈希的引用）进行
bless，而是对匿名子程序引用来祝福。于是，构造器返回的是子程序引用，而且这也成了唯一的一个访问私有数据的方法。这个受祝福的匿名子程序之所以能访问对象的数据，是因为他们在定义的时候在同一个词法有效范围中。因为通过子程序来封装数据，所以可以被看成是闭包。从此，只要匿名子程序的引用仍然存在，就可以存取对象的数据。</p>
</div>
<p class="indent"><a href="ch14.html#ch14exa14">例 14.14</a>
展示了如何使用闭包来为对象封装数据的，具体是以下的步骤：</p>
<p class="indenthangingN"><strong>1.</strong> 首先为 <em>Student</em>
类定义构造器方法。构造器将会定义一个空的匿名哈希，用来给每一个新的
<em>Student</em>
对象设置属性。另外，还有一个全局类变量用于记录学生的数量，以及一个匿名子程序用于封装数据，也用于存取对象数据。所以，最后受到祝福并返回的是一个匿名子程序。</p>
<p class="indenthangingN"><strong>2.</strong>
然后定义实例方法来读写数据。记住，这些方法不能直接从参数中获取对象引用了。所以要读写数据现在得通过匿名子程序的引用，而且调用时候得提供合适的参数。</p>
<p class="indenthangingN"><strong>3.</strong> 这里要定义一个析构器来显示将被销毁的
<em>Student</em> 对象。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa14"/>例 14.14</p>
<p class="codelink1"><a id="p14exa14" href="ch14_images.html#p14exa14a">Click here to view code
image</a></p>
<p class="pre1"># <span class="EmpItalic">File is House.pm</span><br/><br/>&#160;&#160;&#160;package House;<br/><br/>1&#160;&#160;my @props=qw(Owner Color Price);&#160;&#160;# <span
class="EmpItalic">Define property keys</span><br/><br/>2&#160;&#160;sub new{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($class)=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my @values=@_;&#160;&#160;# <span
class="EmpItalic">Values for properties</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my %data;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Will store properties</span><br/>3&#160;&#160;&#160;&#160;&#160;@data{@props}=@values;&#160;&#160;# <span
class="EmpItalic">Create the hash with keys and values</span><br/><br/>4&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $access_ptr =
sub</span>{&#160;&#160;# <span class="EmpItalic">Anonymous subroutine</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "Caller is
",(caller)[0],"\n";<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;my($access_type, $key,
$value) = @_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Determines if setting or getting data</span><br/>6&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;die "Direct access not
allowed" if caller() ne "House";<br/><a id="page_482"/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if
($access_type eq "set" &#38;&#38; $key eq "Price"){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;die
"Can't change Price\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ($access_type eq "set"){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$data{$key}=$value;&#160;&#160;#
<span class="EmpItalic">Closure, %data still available here</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>9&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ($access_type eq "get"){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return
$data{$key};<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;};<br/>10&#160;&#160;&#160;&#160;<span class="EmpStrong">return bless( $access_ptr,
$class)</span>;&#160;&#160;<span class="EmpItalic"># Bless anonymous
sub</span><br/>&#160;&#160;&#160;}&#160;&#160;# <span class="EmpItalic">End new</span><br/><br/>11 sub set {<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($self, $key, $value)= @_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;("set", $key, $value);<br/>&#160;&#160;&#160;}<br/>12 sub get {<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($self, $key)= @_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;("get",$key);<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;1;</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> <em>House</em> 类的所有对象都有
<em>Owner</em>、<em>Color</em> 和 <em>Price</em>
属性，它们是存储在 <em>@props</em> 数组里面的。</p>
<p class="sb-indenthangingN"><strong>2.</strong>
构造器用来创建并祝福对象。首先是通过哈希来设置属性，然后是通过用户代码来设置具体的值。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 用键值对的方式来给 <em>%data</em>
赋值，这里用到了哈希切片的语法。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这个 <em>$access_ref</em>
变量得到的赋值是一个匿名子程序，于是成为一个闭包。这个子程序引用被祝福成一个类的实例，也可以用来读写
<em>House</em>
对象的数据。用户代码必须通过这个函数引用来存取封装的数据。闭包使得
<em>%data</em>
中的属性可以存取，哪怕这个数据看似已经超出了定义范围。</p>
<p class="sb-indenthangingN"><strong>5.</strong>
这个子程序带有三个参数：存取类型（要么是
<em>set</em>，要么是
<em>get</em>）、一个对象的属性，以及对应的值。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这里 Perl 内置的函数 <em>caller()</em>
返回的是被调用的函数所在的包名。如果这个包与
<em>House</em>
不一致的话，就会打印错误信息并退出。这点我们后面会更加明白。目前来说，这意味着你不能在用户代码中直接存取对象的数据，而必须通过类定义的方法来完成。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 如果调用的参数中存取类型是
<em>set</em>，而对象的属性是
<em>Price</em>，那么就打印错误信息，拒绝设置价格属性的值，并且退出。</p>
<p class="sb-indenthangingN"><a id="page_483"/><strong>8.</strong> 如果存取类型是
<em>set</em>，那么就设置对象的值。</p>
<p class="sb-indenthangingN"><strong>9.</strong> 如果存取类型是
<em>get</em>，那么读取属性对应的值。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 这里通过 bless
来将匿名子程序的引用祝福，并返回调用者。而在之前的例子中，祝福并返回的都是
<em>HASH</em>。</p>
<p class="sb-indenthangingN1"><strong>11.</strong> 这里定义的是 <em>set</em>
方法，用户调用它的时候其实不是直接完成数据的修改，而是通过间接呼叫对应的子程序来完成的。因为第一个参数就指向了匿名子程序，而不是匿名哈希、数组或者标量的引用。第二个参数则是对象的属性，最后一个参数才是对应的值。因此
<em>$self</em>
其实是在第十行祝福过的匿名子程序，访问对象的数据靠得也是它。</p>
<p class="sb-indenthangingN1"><strong>12.</strong> 这里的 <em>get</em> 方法的工作机制与
<em>set</em> 类似，因为也是通过调用 <em>$self</em>
指向的匿名子程序来读取数据的。</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa15"/>例 14.15</p>
<p class="codelink1"><a id="p14exa15" href="ch14_images.html#p14exa15a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;# <span class="EmpItalic">User of the House Module</span><br/>1&#160;&#160;use House;&#160;&#160;# <span class="EmpItalic">Load the House
module</span><br/><br/>2&#160;&#160;my $obj1 = House-&gt;new("John","red","10000");<br/>&#160;&#160;&#160;my $obj2 = House-&gt;new("Alice","green","20000");<br/><br/>3&#160;&#160;print "The owner of the first house is ",
$obj1-&gt;get("Owner"),"\n";<br/>&#160;&#160;&#160;print "The owner of the second house is ",
$obj2-&gt;get("Owner"),"\n";<br/><br/>4&#160;&#160;$obj1-&gt;set("Owner"=&gt;"Mary");<br/>&#160;&#160;&#160;$obj1-&gt;set("Style"=&gt;"ranch");<br/>&#160;&#160;&#160;print "After reset for Alice:\n";<br/>5&#160;&#160;print "Alice sold her house to ", $obj1-&gt;get("Owner"),"\n";<br/>6&#160;&#160;#$obj1-&gt;set("Price"=&gt;"50");&#160;&#160;&#160;# <span
class="EmpItalic">Can't change price</span><br/>7&#160;&#160;#$ obj1-&gt;("set","Owner"=&gt;"Bank");&#160;&#160;# <span
class="EmpItalic">Direct access not allowed</span><br/><br/>(Ouput)<br/>3&#160;&#160;<span class="EmpItalic">The owner of the first house is
John</span><br/>&#160;&#160;&#160;<span class="EmpItalic">The owner of the second house is
Alice</span><br/>5&#160;&#160;<span class="EmpItalic">After reset for Alice:</span><br/>6&#160;&#160;<span class="EmpItalic">Alice sold her house to Mary</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 载入 <em>House</em> 模块。</p>
<p class="sb-indenthangingN"><strong>2.</strong>
创建两个房屋对象，通过构造器设置相应的参数属性。（这里所有的房屋对象其实都是祝福过的匿名子程序引用。）</p>
<p class="sb-indenthangingN"><strong>3.</strong> 通过 <em>get()</em>
方法来打印两个房屋的拥有者。这里的第一个参数是房屋对象的引用，而第二个参数则是具体的属性
<em>Owner</em>。返回的是对应的键值。（请参考
<em>House.pm</em> 第九行的定义。）</p>
<p class="sb-indenthangingN"><a id="page_484"/><strong>4.</strong> 这里调用 <a
id="page_484"/><strong>4.</strong> 中定义的 <em>set()</em>
方法，用哈希格式来发送键和对应的值。（请参考
<em>House.pm</em> 第十一行的定义。）</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这一行通过
<em>$obj1</em>-<em>&gt;get(&#8220;Owner&#8221;)</em>
打印出来的信息说明房屋的拥有者已经改变了。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 用户不能将 <em>Price</em> 设为 $50.00。请参考
<em>House.pm</em>
模块中第七行的代码。如果这么调用的话，程序会崩溃。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里显示用户如何企图（绕过
<em>House.pm</em> 定义的 <em>set()</em> 方法）通过 <em>$obj1</em>
引用来直接修改数据。如果这么做的话，<em>caller()</em>
函数（<em>House.pm</em> 第六行）会返回
&#8220;main&#8221;，于是会打印错误信息并退出。如果用户通过
<em>$obj1</em>-<em>&gt;set(&#8217;Owner&#8217;=&gt;&#8217;Bank&#8217;)</em>
这样的方式来调用 <em>set()</em> 方法的话，就等于是从
<em>House.pm</em> 模块的 <em>set()</em>
方法中发起对匿名子程序的调用。所以 <em>set()</em>
函数返回的就是
<em>House</em>。也就是说，这里的底线是：调用者必须是
<em>House</em>，否则退出。</p>
<hr/></div>
<div class="heading">
<h3 id="ch14lev1sec4">14.4 继承</h3>
<p class="noindent"><strong>继承</strong>的含义是从已有的某个类中继承方法定义，并形成一个新类。新类可以对已有类的代码进行增加或者修订，从而实现类的定制，而不必完全重头开始发明一切。这里的原则就是，从已有类可以延伸出许多的子类，而且所有子类都有共同的根基，但又可以发展出各自的细分特色来。这一类的思维或组织结构其实并不陌生，你应该在生物学的课程上看到过对植物和动物的分类方法：门纲目科属种等等。另外，面向程序的编程中也有类似的概念，就是通过组合代码中的可复用程序来完成指定的任务。</p>
</div>
<p class="indent">在面向对象编程中，一旦类书写出来，也通过了调试，就可以把它部署在一个类库中供其他程序员调用。程序员可以对现存类增加功能，而不必重写整个类。这个实现的机制就是继承，也就是从现存类衍生新类。正是因为这个类库继承机制的存在，面向对象语言才得到广泛的接受。现在我们来看看
Perl 是怎样实现继承的。</p>
<div class="heading">
<h4 id="ch14lev2sec13">14.4.1 <em>@ISA</em> 数组和的方法调用</h4>
<p class="noindent">列在 <em>@ISA</em>
数组中的是当期类的父类，或者说是基类。这就是 Perl
实现继承的方法。如果 Perl
在调用某个方法，而且在当前的包（也就是类）中找不到，那么就会从
<em>@ISA</em>
数组中的其他包查找。如果仍然找不到的话，就会搜索
<em>AUTOLOAD</em>
函数，并进行调用。如果最后连这个也找不到的话，就搜索一个特殊的名为
<em>UNIVERSAL</em> 的预定义包。其实这个 <em>UNIVERSAL</em>
类是所有类的父类，也就是所有对象类的最高层次祖先。</p>
</div>
<p class="indent">注意，在常见的子程序调用过程中不会搜索 <em>@ISA</em>
数组，只有方法调用的语法才会触发这个搜索过程。</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa16"/>例 14.16</p>
<p class="codelink1"><a id="p14exa16" href="ch14_images.html#p14exa16a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;#!/bin/perl<br/>&#160;&#160;&#160;# <span class="EmpItalic">Example of attempting
inheritance without updating</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">the @ISA array</span><br/>1&#160;&#160;{ <span class="EmpStrong">package Grandpa;</span><br/>2&#160;&#160;&#160;&#160;&#160;$name = "Gramps"; # <span
class="EmpItalic">Global package variable for Grandpa</span><br/>3&#160;&#160;&#160;&#160;&#160;sub greetme {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">print "Hi $Child::name I'm your $name from package
Grandpa.\n";</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>4&#160;&#160;{ <span class="EmpStrong">package Parent;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">This package
is empty</span><br/>&#160;&#160;&#160;}<br/>5&#160;&#160;{ <span class="EmpStrong">package Child;</span><br/>6&#160;&#160;&#160;&#160;&#160;$name = "Baby";<br/>7&#160;&#160;&#160;&#160;&#160;print "Hi I'm $name in the Child Package
here.\n";<br/>8&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">Parent-&gt;greetme();</span>&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Use method invocation syntax</span><br/>&#160;&#160;&#160;}<br/><br/>(Output)<br/>7&#160;&#160;<span class="EmpItalic">Hi I'm Baby in the Child Package
here.</span><br/>8&#160;&#160;<span class="EmpItalic">Can't locate object method "greetme"
via package "Parent" at</span><br/>&#160;&#160;&#160;<span class="EmpItalic">inher2 line 23.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里声明了 <em>Grandpa</em> 包。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这里在 <em>Grandpa</em> 包中将全局标量
<em>$name</em> 设置为 <em>Gramps</em>。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里定义了 <em>greetme</em>
子程序，在调用时会执行其中的 <em>print</em> 语句。而
<em>$Child::name</em> 则值得是 <em>Child</em>
包中定义的全局标量 <em>$name</em>。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里定义的是 <em>Parent</em>
包，是一个空包。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里定义的是 <em>Child</em>
包。这个包将会尝试调用另一个包中的方法。尽管这里的对象和方法无人使用，但是这个例子的目标是展示如何从另一个类中继承一个方法过来。</p>
<p class="sb-indenthangingN"><strong>8.</strong> Perl 无法从 <em>Parent</em> 包中找到
<em>greetme</em> 的定义，只能打印错误信息。</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_486"/><a id="ch14exa17"/>例 14.17</p>
<p class="codelink1"><a id="p14exa17" href="ch14_images.html#p14exa17a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;#!/bin/perl<br/>&#160;&#160;&#160;# <span class="EmpItalic">Example of attempting
inheritance by updating the @ISA array</span><br/>1&#160;&#160;{ <span class="EmpStrong">package Grandpa;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$name = "Gramps";<br/>2&#160;&#160;&#160;&#160;&#160;sub greetme {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">print "Hi $Child::name I'm your $name from package
Grandpa.\n";</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/><br/>3&#160;&#160;{ <span class="EmpStrong">package Parent;</span><br/>4&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">@ISA=qw(Grandpa);</span>&#160;&#160;# <span
class="EmpItalic">Grandpa is a package in the @ISA array.</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">This package
is empty.</span><br/>&#160;&#160;&#160;}<br/><br/>5&#160;&#160;{ <span class="EmpStrong">package Child;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$name = "Baby";<br/>6&#160;&#160;&#160;&#160;&#160;print "Hi I'm $name in the Child Package
here.\n";<br/>7&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">Parent-&gt;greetme();</span>&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Parent::greetme() will not fail</span><br/>&#160;&#160;&#160;}<br/><br/>(Output)<br/>6&#160;&#160;<span class="EmpItalic">Hi I'm Baby in the Child Package
here.</span><br/>7&#160;&#160;<span class="EmpItalic">Hi Baby I'm your Gramps from package
Grandpa.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里声明了 <em>Grandpa</em> 包。</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这里定义了 <em>greetme</em> 子程序，其中的
<em>print</em>
语句在调用时会得到执行机会。<em>$Child::name</em> 指向
<em>Child</em> 包中定义的标量 <em>$name</em>。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里声明了 <em>Parent</em> 包。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里在 <em>@ISA</em> 数组中赋值 <em>Grandpa</em>
包的名字。所以，如果 Perl 无法在 <em>Child</em>
包中找到某个方法的定义，就会试着找 <em>@ISA</em>
数组中列出的 <em>Grandpa</em>
包里面有没有定义。在常规的子程序调用中并没有查询
<em>@ISA</em>
数组的步骤，因为这并不是方法调用。尽管这里的子程序从技术上来说不怎么像是一个方法，通过对
<em>@ISA</em> 数组的搜索，它还是会调用 <em>greetme</em>
这个类方法。</p>
<p class="sb-indenthangingN"><strong>5.</strong> 这里声明的是 <em>Child</em> 包。</p>
<p class="sb-indenthangingN"><strong>6.</strong> 这一行将会在 <em>Child</em>
包中得到打印机会。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里在 <em>Parent</em> 包中调用类方法
<em>greetme</em>。通过 <em>@ISA</em> 数组来触发 Perl 对
<em>Grandpa</em> 包进行搜索，从而解决 <em>Parent</em>
包中不能找到的方法带来的问题。</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec14">14.4.2 <em>$AUTOLOAD</em>、<em>sub AUTOLOAD</em> 和 <em>UNIVERSAL</em></h4>
<p class="noindent">如果在当前包以及 <em>@ISA</em>
数组中的其他包里面都找不到某个方法的定义，那么就会试着调用
<em>AUTOLOAD</em> 函数。在调用它的时候，<em>$AUTOLOAD</em>
变量会被赋予正在调用的子程序的名字。而被掉子程序的参数也会进入
<em>AUTOLOAD</em> 子程序的 <em>@_</em> 数组。如果你对
<em>$AUTOLOAD</em>
变量进行赋值的话，那个在无法匹配的方法调用发生的时候就会调用这个变量中的名字对应的方法。而且如果通过
<em>AUTOLOAD</em> 子程序和 <em>$AUTOLOAD</em>
变量进行匹配，那么无论是方法调用语法还是普通语法都会生效。如果以上一切都不能匹配的话，Perl
就会尝试在 <em>UNIVERSAL</em> 包中定位方法。<em>UNIVERSAL</em>
类最起码定义了三个方法，是所有类都必须继承的。他们是
<em>isa()</em>、<em>can()</em> 和 <em>VERSION()</em>（请参考<a
href="ch14.html#ch14tab02">表 14.2</a>）。另外，可以通过输入
<em>perldoc UNIVERSAL</em> 命令来查询最新的文档。</p>
</div>
<div class="tab-heading">
<div class="image"><a id="ch14tab02"/><img src="graphics/14tab02.jpg" alt="Image"/></div>
<p class="tab-caption"><strong>表 14.2</strong><em>isa()</em>、<em>can()</em> 和
<em>VERSION()</em> 方法</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa18"/>例 14.18</p>
<p class="codelink1"><a id="p14exa18" href="ch14_images.html#p14exa18a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;{ <span class="EmpStrong">package Grandpa;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$name = "Gramps";<br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sub greetme
{</span><br/>2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">print "Hi $Child::name I'm your $name from package
Grandpa.\n";</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;}<br/><br/>3&#160;&#160;{ <span class="EmpStrong">package Parent;</span><br/>4&#160;&#160;&#160;&#160;&#160;sub AUTOLOAD{<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "<span
class="EmpStrong">$_[0]</span>: $_[1] and $_[2]\n";<br/>6&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "You know us after
all!\n";<br/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "The unheard of
subroutine is called <span class="EmpStrong">$AUTOLOAD</span>.\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>8&#160;&#160;{ <span class="EmpStrong">package Child;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$name = "Baby";<br/>9&#160;&#160;&#160;&#160;&#160;print "Hi I'm $name in the Child Package
here.\n";<br/>10&#160;&#160;&#160;&#160;<span class="EmpStrong">Parent-&gt;unknown("Mom",
"Dad");</span>&#160;&#160;&#160;# <span class="EmpItalic">Undefined
subroutine</span><br/>&#160;&#160;&#160;}<br/><br/>(Output)<br/>2&#160;&#160;<span class="EmpItalic">Hi Baby I'm your Gramps from package
Grandpa.</span><br/>9&#160;&#160;<span class="EmpItalic">Hi I'm Baby in the Child Package
here.</span><br/>5&#160;&#160;<span class="EmpItalic">Parent: Mom and Dad</span><br/>6&#160;&#160;<span class="EmpItalic">You know us after all!</span><br/>7&#160;&#160;<span class="EmpItalic">The unheard of subroutine is called
Parent::unknown.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_488"/>Explanation</p>
<p class="sb-indenthangingN"><strong>1.</strong> The package <em>Grandpa i</em>s declared. It contains
one subroutine.</p>
<p class="sb-indenthangingN"><strong>2.</strong> 这一行从 <em>Grandpa</em> 包中打印出来。</p>
<p class="sb-indenthangingN"><strong>3.</strong> 这里定义了 <em>Parent</em> 包。</p>
<p class="sb-indenthangingN"><strong>4.</strong> 这里因为存在 <em>AUTOLOAD</em>
子程序。在第十行又有一个未定义的子程序调用（这个调用有两个参数
<em>Mom</em> 和 <em>Dad</em>）。所以，Perl 意识到 <em>Child</em>
包中找不到子程序定义，于是就去查看 <em>@ISA</em>
数组，因为仍然找不到，就会去查找 <em>AUTOLOAD</em>
子程序。</p>
<p class="sb-indenthangingNP">这里定义的是 <em>AUTOLOAD</em> 子程序。</p>
<p class="sb-indenthangingN"><strong>5.</strong>
因为这个函数是用类方法的方式来调用的，所以 <em>@_</em>
数组中的第一个参数是类的名字。其余的参数就是之前提到的
<em>Mom</em> 和 <em>Dad</em>。</p>
<p class="sb-indenthangingN"><strong>6.</strong>
打印这一行是为了显明我们执行到了这里。</p>
<p class="sb-indenthangingN"><strong>7.</strong> 这里的 <em>$AUTOLOAD</em>
变量包含了类名和未定义的子程序名。</p>
<p class="sb-indenthangingN"><strong>8.</strong> 这里定义的是 <em>Child</em> 包。</p>
<p class="sb-indenthangingN"><strong>9.</strong>
打印这一行是为了显明我们执行到了这里。</p>
<p class="sb-indenthangingN1"><strong>10.</strong> 这里 <em>Child</em> 包想要调用 <em>Parent</em>
包中的一个方法。而 <em>Parent</em> 包并未定义这个名为
<em>unknown</em> 的子程序。不过，它确实定义了一个
<em>AUTOLOAD</em>
子程序，所以这里它会得到执行，因为没有其他的子程序可以找到。</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa19"/>例 14.19</p>
<p class="codelink1"><a id="p14exa19" href="ch14_images.html#p14exa19a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;{ <span class="EmpStrong">package Grandpa;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$name = "Gramps";<br/>2&#160;&#160;&#160;&#160;&#160;sub greetme {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "Hi $Child::name
I'm your $name from package Grandpa.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>3&#160;&#160;{ <span class="EmpStrong">package Parent;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;# <span class="EmpItalic">This package
is empty</span><br/>&#160;&#160;&#160;}<br/>4&#160;&#160;{ <span class="EmpStrong">package Child;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$name = "Baby";<br/>5&#160;&#160;&#160;&#160;&#160;print "Hi I'm $name in the Child Package
here.\n";<br/>6&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">Parent-&gt;greetme();</span><br/>&#160;&#160;&#160;}<br/><br/>7&#160;&#160;<span class="EmpStrong">package UNIVERSAL;</span><br/>8&#160;&#160;<span class="EmpStrong">sub AUTOLOAD {</span><br/>9&#160;&#160;&#160;&#160;&#160;print "The UNIVERSAL lookup package.\n";<br/>10&#160;&#160;&#160;&#160;<span
class="EmpStrong">Grandpa-&gt;greetme();</span><br/>&#160;&#160;&#160;}<br/><br/>(Output)<br/>2&#160;&#160;<span class="EmpItalic">Hi I'm Baby in the Child Package
here.</span><br/>9&#160;&#160;<span class="EmpItalic">The UNIVERSAL lookup package.</span><br/>5&#160;&#160;<span class="EmpItalic">Hi Baby I'm your Gramps from package
Grandpa.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_489"/>Explanation</p>
<p class="sb-indenthangingN"><strong>1.</strong> 这里声明了 <em>Grandpa</em> 包。</p>
<p class="sb-indenthangingN"><strong>2.</strong> The subroutine <em>greetme</em> is defined in this
package.</p>
<p class="sb-indenthangingN"><strong>3.</strong> The package <em>Parent</em> is declared. It is empty.</p>
<p class="sb-indenthangingN"><strong>4.</strong> The package <em>Child</em> is declared.</p>
<p class="sb-indenthangingN"><strong>5.</strong> This line is printed to show the flow of execution in
the program.</p>
<p class="sb-indenthangingN"><strong>6.</strong> The <em>greetme</em> subroutine is called as one of the
<em>Parent</em> package methods. Since the method could not be found in its
own class or in the <em>@ISA</em> array, and an <em>AUTOLOAD</em> function
is not supplied in the <em>Parent</em> package, Perl looks for package
<em>UNIVERSAL</em> as a last resort.</p>
<p class="sb-indenthangingN"><strong>7.</strong> This is the built-in base class called
<em>UNIVERSAL</em> All modules inherit from <em>UNIVERSAL</em> which is
implicitly on the end of the <em>@ISA</em> array.</p>
<p class="sb-indenthangingN"><strong>8.</strong> The <em>AUTOLOAD</em> function will automatically be
called from the <em>UNIVERSAL</em> class.</p>
<p class="sb-indenthangingN2"><strong>9, 10.</strong> Within the <em>AUTOLOAD</em> function, the
<em>greetme()</em> function in the <em>Grandpa</em> package will be invoked.</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec15">14.4.3 Derived Classes</h4>
<p class="noindent">As already discussed, <strong>inheritance</strong> is when one class can
inherit methods from an existing class. The existing class is called the
<strong>base</strong>, <strong>parent</strong>, or
<strong>superclass</strong>, and the new class that inherits from it is
called the <strong>derived</strong>, <strong>child</strong>, or
<strong>subclass.</strong> The base class has capabilities that all its
derived classes inherit, and the derived class can then go beyond those
capabilities.</p>
</div>
<p class="indent">If a derived class inherits from one base class, it is called <strong>single
inheritance</strong>. For example, single inheritance in real life might be
that a child inherits his ability to draw from his father. If a derived or
subclass inherits from more than one base class, this is called
<strong>multiple inheritance</strong>. To continue the analogy, the child
inherits his ability to draw from his father and his ability to sing from
his mother. In Perl, the derived class inherits methods from its base class
and can add and modify these methods when necessary.</p>
<p class="indent">The classes are inherited by putting them in the <em>@ISA</em> array. In <a
href="ch13.html#ch13">Chapter 13</a>, &#8220;<a
href="ch13.html#ch13">Modularize It, Package It, and Send It to the
Library!</a>&#8221; we looked at modules from the Perl standard library and
modules you could create yourself. In order to include a module or pragma
into your program, the <em>use</em> function was called with the module name
(minus the.<em>pm</em> extension). The module had the capability of
exporting symbols to other packages that might need to use the module. A
special module called <em>Exporter.pm</em> handled the details for exporting
and importing symbols between modules and the symbols were listed in the
<em>@EXPORT</em> and <em>@EXPORT_OK</em> arrays. The <em>Exporter.pm</em>
module, you may recall, was listed in the <em>@ISA</em> array in order to
inherit methods necessary for it to do its job. But if a module functions as
a class, then its methods can be called without using
<em>Exporter</em>. Note in the following examples, the class methods and the
instance methods are not exported.</p>
<p class="indent">The following examples demonstrate inheritance. The user program need not
make any reference to the base class, <em>Employee.</em> The
<em>Salesman</em> class and the <em>Teacher</em> class are derived from
<em>Employee</em>. The <em>Salesman</em> and <em>Teacher</em> class
&#8220;use&#8221; the <em>Employee</em> class. <a
href="ch14.html#ch14fig05">Figure 14.5</a> shows this inheritance hierarchy
graphically.</p>
<div class="fig-heading">
<div class="image"><a id="page_490"/><a id="ch14fig05"/><img src="graphics/14fig05.jpg" alt="Image"/></div>
<p class="fig-caption"><strong>Figure 14.5</strong> Inheritance hierarchy&#8212;deriving classes
from a base class.</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa20"/>EXAMPLE 14.20</p>
<p class="codelink1"><a id="p14exa20" href="ch14_images.html#p14exa20a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;# <span class="EmpItalic">Module Employee.pm</span><br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">The Base Class</span><br/>1&#160;&#160;<span class="EmpStrong">package Employee;</span><br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>&#160;&#160;&#160;# <span class="EmpItalic">Constructor method</span><br/>2&#160;&#160;<span class="EmpStrong">sub init</span> {<br/>3&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>4&#160;&#160;&#160;&#160;&#160;my %info = @_;<br/>5&#160;&#160;&#160;&#160;&#160;my $self = {_Name=&gt;$info{"_Name"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_StartDate=&gt;$info{"_StartDate"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_BasePay=&gt;$info{"_BasePay"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>6&#160;&#160;&#160;&#160;&#160;return bless($self, $class);<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;# <span class="EmpItalic">Some instance methods</span><br/>&#160;&#160;&#160;sub get_name{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $self-&gt;{_Name};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;sub get_startdate{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $self-&gt;{_StartDate};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;sub get_basepay{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $self-&gt;{_BasePay};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_491"/>Explanation</p>
<p class="sb-indenthangingN"><strong>1.</strong> <em>Employee</em> is the base class in a file called
<em>Employee.pm</em>.</p>
<p class="sb-indenthangingN"><strong>2.</strong> The <em>init</em> method is a constructor. It sets
properties for all employees.</p>
<p class="sb-indenthangingN"><strong>3.</strong> The first argument is the class name from which the
method was called.</p>
<p class="sb-indenthangingN"><strong>4.</strong> The information being passed in from the caller of this
function is a hash of key/value pairs.</p>
<p class="sb-indenthangingN"><strong>5.</strong> The values in the <em>%info</em> hash are assigned as
the employee&#8217;s properties.</p>
<p class="sb-indenthangingN"><strong>6.</strong> The new employee referent is blessed into the class that
called this subroutine (its name was passed in as the first argument).</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa21"/>EXAMPLE 14.21</p>
<p class="codelink1"><a id="p14exa21" href="ch14_images.html#p14exa21a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;package Salesman;<br/>&#160;&#160;&#160;use lib("/usr/local/bin/baseclass");&#160;&#160;# <span
class="EmpItalic">Update @INC</span><br/>&#160;&#160;&#160;use v5.10.0;<br/>&#160;&#160;&#160;use feature qw(state say);<br/>2&#160;&#160;use base qw(Employee);&#160;&#160;# <span
class="EmpItalic">Updates @ISA</span><br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>3&#160;&#160;sub count_salesman{&#160;&#160;&#160;# <span
class="EmpItalic">Class method</span><br/>4&#160;&#160;&#160;&#160;&#160;state $counter=0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$counter++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $counter;<br/>&#160;&#160;&#160;}<br/>5&#160;&#160;sub new&#160;&#160;{&#160;&#160;# <span
class="EmpItalic">Constructor for Salesman</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($class)= shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my %data=@_;<br/>6&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $emp =
$class-&gt;init("_Name"=&gt;$data{_Name},</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_StartDate"=&gt;$data{_StartDate},</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_BasePay"=&gt;$data{_BasePay},</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>7&#160;&#160;&#160;&#160;&#160;$emp-&gt;{"_AnnualSales"}=$data{"_AnnualSales"};<br/>&#160;&#160;&#160;&#160;&#160;&#160;$emp-&gt;{"_Commission"}=$data{"_Commission"};<br/>8&#160;&#160;&#160;&#160;&#160;say "This is $emp-&gt;{_Name}, salesman #",
count_salesman();<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $emp;<br/>&#160;&#160;&#160;}<br/>9&#160;&#160;sub calculate_pay{<br/>10&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $rate = $self-&gt;{"_Commission"};<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $sales = $self-&gt;{"_AnnualSales"};<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $base = $self-&gt;{"_BasePay"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $pay = $sales * $rate + $base;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $pay;<br/>&#160;&#160;&#160;}<br/>11 sub DESTROY{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "$self-&gt;{_Name} is leaving the
firm.\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_492"/>Explanation</p>
<p class="sb-indenthangingN"><strong>1.</strong> The <em>Salesman</em> class is declared in
<em>Salesman.pm</em>.</p>
<p class="sb-indenthangingN"><strong>2.</strong> The <em>base</em> module updates the <em>@ISA</em> array
and loads the <em>Employee.pm</em> module. Another way to update
<em>@ISA</em> is to say:</p>
<p class="pre2">push(@ISA,"Employee");<br/>use Employee;</p>
<p class="sb-indenthangingNP">If using version 5.16 and above, you can say:</p>
<p class="pre2">use parent Employee;</p>
<p class="sb-indenthangingN4"><strong>3, 4.</strong> The counter subroutine will keep track of the number
of salesmen created. It uses the <em>state</em> feature to allow the
<em>$counter</em> variable to retain its value from one call to the next;
meaning, it does not reset the variable to zero each time the function is
called. This is a class function as it is specific to the class as a whole
and does not take a reference to an object as its first argument.</p>
<p class="sb-indenthangingN"><strong>5.</strong> The constructor method for the <em>Salesman</em> class
is defined.</p>
<p class="sb-indenthangingN"><strong>6.</strong> Here we see inheritance being used when calling the
<em>init</em> method which is defined in the <em>Employee</em> class (see
<em>Employee.pm</em>), not in the current <em>Salesman</em> class. When
<em>init</em> is called, Perl will look in the current <em>Salesman</em>
class first, and since it is not defined there, will then look in the
<em>@ISA</em> array to see if it is listed there. It is. Note that the class
name being sent to to the <em>Employee</em>&#8217;s <em>init()</em> function
is <em>Salesman</em> (meaning, in the <em>Employee</em> class the blessing
will bless the object into the <em>Salesman</em> class, not the
<em>Employee</em> class). The remaining arguments are the properties for any
<em>Employee</em>. A blessed reference to a new <em>Salesaman</em> object is
returned.</p>
<p class="sb-indenthangingN"><strong>7.</strong> Now the blessed salesman will get additional properties
that further define all salesmen.</p>
<p class="sb-indenthangingN"><strong>8.</strong> Each time a new <em>Salesman</em> object is created, the
<em>count_salesman</em> function is called. It is a class function and does
not require a reference to the object.</p>
<p class="sb-indenthangingN"><strong>9.</strong> An access method, <em>calculate_pay()</em>, is defined
for the <em>Salesman</em>.</p>
<p class="sb-indenthangingN1"><strong>10.</strong> The first argument is a reference to the object
implicitly sent by Perl when the function is called.</p>
<p class="sb-indenthangingN1"><strong>11.</strong> The <em>DESTROY</em> method is called each time an
object goes out of scope, usually when the program ends.</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa22"/>EXAMPLE 14.22</p>
<p class="codelink1"><a id="p14exa22" href="ch14_images.html#p14exa22a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;<span class="EmpStrong">package Teacher</span>;<br/>&#160;&#160;&#160;use v5.10.0;<br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>&#160;&#160;&#160;use feature qw(state say);<br/>2&#160;&#160;<span class="EmpStrong">our @ISA=qw(Employee)</span>;<br/>&#160;&#160;&#160;<span class="EmpStrong">use Employee</span>;<br/><br/>&#160;&#160;&#160;my $tracker;<br/><a id="page_493"/>3&#160;&#160;sub count_teacher{&#160;&#160;&#160;# <span
class="EmpItalic">Class method</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;state $counter=0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$counter++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $counter;<br/>&#160;&#160;&#160;}<br/>4&#160;&#160;sub new&#160;&#160;{&#160;&#160;# <span
class="EmpItalic">Constructor for Teacher</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($class)= shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my %data=@_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $emp =
$class-&gt;init("_Name"=&gt;$data{_Name},<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_StartDate"=&gt;$data{_StartDate},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"_BasePay"=&gt;$data{_BasePay},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;$tracker=count_teacher();<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $emp;<br/>&#160;&#160;&#160;}<br/>6&#160;&#160;<span class="EmpStrong">sub set_courses</span>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $cptr=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;{"_Courses"}=$cptr;<br/>&#160;&#160;&#160;}<br/>7&#160;&#160;sub get_courses{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self=shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return "@{$self-&gt;{'_Courses'}}";<br/>&#160;&#160;&#160;}<br/><br/>8&#160;&#160;<span class="EmpStrong">END</span>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "$tracker teachers were
created.\n";<br/>&#160;&#160;&#160;}</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> The <em>Teacher</em> class is defined here.</p>
<p class="sb-indenthangingN"><strong>2.</strong> In this module, the <em>@ISA</em> is updated directly
rather than by using the <em>base.pm</em> or <em>parent.pm</em> pragmas. The
name of the base class is listed so that the subclass, <em>Teacher</em>, can
inherit from it. Not only does the <em>@ISA</em> array need to be updated,
but the <em>use</em> directive must name the base class and load it. This is
done automatically when you say <em>use parent</em> or <em>use base</em>.</p>
<p class="sb-indenthangingN"><strong>3.</strong> This class function will track the number of new
<em>Teacher</em> objects added to the class.</p>
<p class="sb-indenthangingN"><strong>4.</strong> The <em>new()</em> constructor method for the teacher
defines the properties for the teacher as a hash and returns a blessed
teacher reference.</p>
<p class="sb-indenthangingN"><strong>5.</strong> Like the <em>Salesman</em> class described previously,
the <em>Teacher</em> inherits from the <em>Employee</em> class and call its
<em>init()</em> method. The <em>init()</em> constructor in the
<em>Employee</em> class will then assign the basic properties for an
<em>Employee</em> and return a blessed <em>Teacher</em> object.</p>
<p class="sb-indenthangingN"><strong>6.</strong> The teacher object is sent to the <em>set_courses()</em>
method along with a reference to a list of courses. These courses will be
set as a new attribute to the object.</p>
<p class="sb-indenthangingN"><strong>7.</strong> The <em>get_courses()</em> method will retrieve and send
back the list of the teacher&#8217;s courses by derefencing the pointer,
<em>$self-&gt;{Courses}</em>.</p>
<p class="sb-indenthangingN"><a id="page_494"/><strong>8.</strong> When the program is is ready to exit,
the special <em>END</em> subroutine prints out the number of
<em>Teacher</em> objects that were created. This works better than using the
<em>DESTROY</em> method because the <em>DESTROY</em> method would print out
the message whenever a teacher object goes out of scope, so that if you had
created six teacher objects, the message would print six times.</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa23"/>EXAMPLE 14.23</p>
<p class="codelink1"><a id="p14exa23" href="ch14_images.html#p14exa23a">Click here to view code
image</a></p>
<p class="pre1">&#160;&#160;&#160;# <span class="EmpItalic">The Driver (user) Program</span><br/>1&#160;&#160;use Salesman;<br/>2&#160;&#160;use Teacher;<br/>&#160;&#160;&#160;use Data::Dumper;<br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>3&#160;&#160;<span class="EmpStrong">my
$salesguy1=Salesman-&gt;new("_Name"=&gt;"Nicky McDonald",</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_StartDate"=&gt;"12/12/2010",</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_BasePay"=&gt;25000,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_AnnualSales"=&gt;1200,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_Commission"=&gt;.05,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">);</span><br/>4&#160;&#160;my $pay=$salesguy1-&gt;calculate_pay();<br/>&#160;&#160;&#160;printf "$salesguy1-&gt;{_Name} made \$%.2f last
year.\n\n", $pay;<br/><br/>5&#160;&#160;<span class="EmpStrong">my
$salesguy2=Salesman-&gt;new("_Name"=&gt;"Rick Gonzales",</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_StartDate"=&gt;"12/12/2010",</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_BasePay"=&gt;80000,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_AnnualSales"=&gt;12200,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_Commission"=&gt;.08,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">);</span><br/>6&#160;&#160;$pay=$salesguy2-&gt;calculate_pay;<br/>&#160;&#160;&#160;printf "$salesguy2-&gt;{_Name} made \$%.2f last
year.\n\n", $pay;<br/><br/>7&#160;&#160;<span class="EmpStrong">my
$teacher=Teacher-&gt;new("_Name"=&gt;"Charles Lee",</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_StartDate"=&gt;"08/12/2013",</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">"_BasePay"=&gt;55000,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpStrong">);</span><br/><br/>8&#160;&#160;<span class="EmpStrong">$teacher-&gt;set_courses(["Basic Math",
"Algebra", "Calculus"]);</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">Pass ref to Array of
courses</span><br/>&#160;&#160;&#160;print
$teacher-&gt;get_name,"\n";&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Inheritance</span><br/>&#160;&#160;&#160;print $teacher-&gt;get_startdate,"\n"; # <span
class="EmpItalic">Inheritance</span><br/>&#160;&#160;&#160;print $teacher-&gt;get_basepay,"\n" ;&#160;&#160;# <span
class="EmpItalic">Inheritance</span><br/>&#160;&#160;&#160;print $teacher-&gt;get_courses,"\n";&#160;&#160;&#160;#
<span class="EmpItalic">Teacher's access method</span><br/><br/>&#160;&#160;&#160;$Data::Dumper::Varname="employee";&#160;&#160;# <span
class="EmpItalic">Give Dumper a user-defined</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">variable name</span><br/>9&#160;&#160;print Dumper($salesguy1, $teacher); # <span
class="EmpItalic">Dump out data for two objects</span><br/><a id="page_495"/><span class="EmpItalic">(Output)</span><br/>&#160;&#160;&#160;<span class="EmpItalic">This is Nicky McDonald, salesman
#1</span><br/><br/>&#160;&#160;&#160;<span class="EmpItalic">Nicky McDonald made $25060.00 last
year.</span><br/><br/>&#160;&#160;&#160;<span class="EmpItalic">This is Rick Gonzales, salesman
#2</span><br/><br/>&#160;&#160;&#160;<span class="EmpItalic">Rick Gonzales made $80976.00 last
year.</span><br/><br/>&#160;&#160;&#160;<span class="EmpItalic">Charles Lee</span><br/>&#160;&#160;&#160;<span class="EmpItalic">08/12/2013</span><br/>&#160;&#160;&#160;<span class="EmpItalic">55000</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Basic Math Algebra Calculus</span><br/>&#160;&#160;&#160;<span class="EmpItalic">$employee1 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_AnnualSales' =&gt; 1200,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_BasePay' =&gt; 25000,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_Commission' =&gt; '0.05',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_StartDate' =&gt; '12/12/2010',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_Name' =&gt; 'Nicky McDonald'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'Salesman' );</span><br/>&#160;&#160;&#160;<span class="EmpItalic">$employee2 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_BasePay' =&gt; 55000,</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_StartDate' =&gt; '08/12/2013',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_Courses' =&gt; [</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Basic Math',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Algebra',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'Calculus'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">],</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'_Name' =&gt; 'Charles Lee'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'Teacher' );</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Rick Gonzales is leaving the
firm.</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Nicky McDonald is leaving the
firm.</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">1 teachers were
created.</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> The <em>Salesman</em> class is loaded into memory.</p>
<p class="sb-indenthangingN"><strong>2.</strong> The <em>Teacher</em> class is also loaded into memory.</p>
<p class="sb-indenthangingN"><strong>3.</strong> A new <em>Salesman</em> object is created with a call to
the new constructor. The properties are sent as a hash. In this way the
properties can be sent in any order, because both key and value are sent.</p>
<p class="sb-indenthangingN"><strong>4.</strong> The <em>Salesman&#8217;s</em> instance/access method,
<em>calculate_pay</em>, is called and returns the object&#8217;s pay.</p>
<p class="sb-indenthangingN"><strong>5.</strong> Another <em>Salesman</em> object is created.</p>
<p class="sb-indenthangingN"><strong>6.</strong> Pay for the second <em>Salesman</em> object is
calculated and returned.</p>
<p class="sb-indenthangingN"><strong>7.</strong> A new <em>Teacher</em> object is created. Because the
classname for a <em>Teacher</em> class is the first argument, the
<em>new()</em> constructor for the <em>Teacher</em> is called (polymorphism
in action).</p>
<p class="sb-indenthangingN"><a id="page_496"/><strong>8.</strong> The teacher&#8217;s access method,
<em>set_courses</em>(), is called. Its arguments are the object reference,
implicitly sent by Perl, and a reference to an array of courses. These
courses will be added as another attribute for the <em>Teacher</em>. In the
next lines, the values are fetched using the base class methods (inherited)
and the <em>Teacher</em>&#8217;s method.</p>
<p class="sb-indenthangingN"><strong>9.</strong> The data for two employees, the first salesman and
teacher, are displayed by <em>Data::Dumper</em>. You can see that each
employee was blessed into his respective class.</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec16">14.4.4 Multiple Inheritance and Roles with Moose</h4>
<p class="noindent">When a class inherits methods from more than one base, or parent, class, it
is called <strong>multiple inheritance</strong>. In Perl, multiple
inheritance is accomplished by adding more than one class to the
<em>@ISA</em> array.</p>
</div>
<p class="codelink"><a id="p596pro01" href="ch14_images.html#p596pro01a">Click here to view code
image</a></p>
<p class="pre">package&#160;&#160;Child;<br/>our @ISA = qw (Mother Father Teacher);</p>
<p class="indent">The search is depth-first, meaning that Perl will search for classes in
<em>Mother</em> and the hierarchy of classes it descends from, then
<em>Father</em> and the hierarchy of classes it descends from, and finally
<em>Teacher</em> and all its ancestors. Just as in real life, the hierarchy
can get confusing when there are multiple parents on the family tree.</p>
<p class="indent">Roles are an alternative to multiple inheritance. Similar to <em>Java</em>
interfaces, or Smalltalk traits, a role defines a set of methods or
attributes for a class that must be implemented by the class and can be
shared by other classes. A role itself is not a class. From the Moose manual
on describing roles:</p>
<p class="blockquote">A role is <em>composed</em> into a class. In practical terms, this means
that all of the methods, method modifiers, and attributes defined in a role
are added directly to (we sometimes say &#8220;flattened into&#8221;) the
class that consumes the role. These attributes and methods then appear as if
they were defined in the class itself. A subclass of the consuming class
will inherit all of these methods and attributes.</p>
<p class="indent">For example, if a <em>Guard</em> class and a <em>Researcher</em> class are
extended from the <em>Employee</em> class we created earlier, and these two
classes require a method to get a security clearance, you could use multiple
inheritance and inherit from both the <em>Employee</em> and a
<em>Clearance</em> class. But inheritance is an &#8220;is a&#8221;
relationship where the derived class is a specialization of the parent
class. You can say a <em>Guard</em> &#8220;is a&#8221; <em>Employee</em>,
but he is not a <em>Clearance</em>. It&#8217;s more that a <em>Guard</em>
requires a clearance. Not every employee needs a clearance, but some do. Our
<em>Salesman</em> didn&#8217;t need one. Creating a role would better
satisfy this requirement for those classes that need it. A role allows one
class to consist of or consume a role to make it complete. For example, a
<em>Guard</em> and a <em>Salesman</em> inherit from the <em>Employee</em>
class all those basic requirements of an employee, but the <em>Guard</em>
class isn&#8217;t complete until it gets a <em>Clearance</em> while the
<em>Salesman</em> doesn&#8217;t need one. We can create a role that does the
job. Roles are a &#8220;does a&#8221; relationship, rather than an &#8220;is
a&#8221; relationship.</p>
<p class="indent"><a id="page_497"/>Since Perl does not implement a built-in way to create
roles, there are a number of modules in the Perl library that support
them. The most popular is the Moose module, which is an extension of the
Perl 5 object system. Try <em>perldoc Moose</em> for complete
documentation. Examples of using Moose are found in <a
href="app03.html#app03">Appendix C</a>, &#8220;<a
href="app03.html#app03">Introduction to Moose (A Postmodern Object System
for Perl 5)</a>.&#8221; There is also a subset of Moose called Moo that may
be better for optimized rapid startup. (See <em><a
href="http://perlmaven.com/videos/oop-with-moo">http://perlmaven.com/videos/oop-with-moo</a>.</em>)
Another watered-down version of Moose is the <em>Role::Tiny</em> module
described in its documentation &#8220;like a nouvelle cuisine portion size
slice of Moose.&#8221;</p>
<p class="indent">In the following example, we demonstrate how to create and use a role with
<em>Moose::Role</em>. In this example, we define a package called
<em>Radius</em>. The class is a <em>Shape::Circle</em>. The <em>Circle</em>
class will have a <em>color</em> property and a <em>calculate_area</em>
method. In order to get the area of a circle, it must have a radius. If we
provide a <em>setRadius</em> method in the <em>Circle</em>, and then if we
want to create a sphere or a cone object, we would still be required to set
the radius for those objects. If we put it in an inheritance tree, we could
say a <em>Circle</em> is a <em>Shape</em>, and a <em>Rectangle</em> is a
<em>Shape</em>, but only the <em>Circle</em> requires a radius. So with role
composition, any object that requires a radius can share the <em>Radius</em>
role to define the <em>setRadius</em> and <em>getRadius</em> methods or
simply ensure a <em>setRadius</em> method is implemented in the module. If
it is not, Perl will throw an exception. Using the <em>Moose::Role</em>
module, we create a role like an ordinary module in a <em>.pm</em> file with
a package declaration and then assign the attributes and methods that the
using module will &#8220;consume.&#8221; Moose roles are not classes and
cannot be instantiated. They are simply roles.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa24"/>EXAMPLE 14.24</p>
<p class="codelink1"><a id="p14exa24" href="ch14_images.html#p14exa24a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;package Radius;<br/><br/>2&#160;&#160;<span class="EmpStrong">use
Moose::Role</span>;&#160;&#160;&#160;# <span class="EmpItalic">Automatically
turns on strict and warnings</span><br/><br/>3&#160;&#160;has 'radius' =&gt; (&#160;&#160;# <span
class="EmpItalic">Attributes and accessors</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;is =&gt; 'rw',<br/>&#160;&#160;&#160;&#160;&#160;&#160;isa =&gt; 'Int',<br/>&#160;&#160;&#160;&#160;&#160;&#160;required =&gt; 1,<br/>&#160;&#160;&#160;)<br/>&#160;&#160;&#160;1;<br/><br/>4&#160;&#160;package Shape::Circle;<br/>&#160;&#160;&#160;use Math::Trig;<br/>5&#160;&#160;<span class="EmpStrong">use Moose;</span><br/>&#160;&#160;&#160;<span class="EmpStrong">with 'Radius'</span>;&#160;&#160;#
<span class="EmpItalic">Radius is a Role</span><br/><br/>6&#160;&#160;has 'color'=&gt;(&#160;&#160;# <span
class="EmpItalic">Define</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;is =&gt; 'rw',<br/>&#160;&#160;&#160;&#160;&#160;&#160;isa =&gt; 'Str',<br/>&#160;&#160;&#160;&#160;&#160;&#160;default =&gt; 'blue'<br/>&#160;&#160;&#160;);<br/><a id="page_498"/>7&#160;&#160;sub calculate_area{&#160;&#160;# <span
class="EmpItalic">Define method for Circle uses radius</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $area=$self-&gt;{'radius'} ** 2 * pi;<br/>&#160;&#160;&#160;&#160;&#160;&#160;return $area;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;package main;<br/>&#160;&#160;&#160;use Data::Dumper;<br/><br/>8&#160;&#160;<span class="EmpStrong">my $c1=Shape::Circle-&gt;new('radius'
=&gt; 6);</span>&#160;&#160;# <span class="EmpItalic">Required
argument</span><br/>9&#160;&#160;print Dumper $c1;&#160;&#160;# <span class="EmpItalic">See the
new Circle object</span><br/>10 <span
class="EmpStrong">$c1-&gt;radius(3);</span>&#160;&#160;&#160;&#160;# <span
class="EmpItalic">radius is a setter</span><br/>11 print "The radius is ", <span
class="EmpStrong">$c1-&gt;radius;</span>&#160;&#160;# <span
class="EmpItalic">radius is a getter</span><br/>12 printf "The area is %.2f\n ",&#160;&#160;<span
class="EmpStrong">$c1-&gt;calculate_area;</span><br/>13 print Dumper $c1;<br/><br/>(Output)<br/>9&#160;&#160;$<span class="EmpItalic">VAR1 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'color' =&gt; 'blue',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'radius' =&gt; 6</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'Shape::Circle' );</span><br/>11 <span class="EmpItalic">The radius is 3</span><br/>12 The area is 28.27<br/>13 <span class="EmpItalic">$VAR1 = bless( {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'color' =&gt; 'blue',</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">'radius' =&gt; 3</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span
class="EmpItalic">}, 'Shape::Circle' );</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> <em>Radius.pm</em> serves as a Moose role. It can be
used, or &#8220;consumed,&#8221; by any class that requires a radius.</p>
<p class="sb-indenthangingN"><strong>2.</strong> <em>Moose::Role</em> is an extension of the Moose
module. (You may have to download Moose if you are using a version of Perl
prior to 5.16.)</p>
<p class="sb-indenthangingN"><strong>3.</strong> The <em>Role</em> has an attribute called
<em>&#39;radius&#39;</em> that takes an integer for its value, is readable
and writeable (<em>rw</em>), and requires that a value for the radius be
provided as an argument to the constructor of the &#8220;consuming&#8221;
class. When a class &#8220;consumes&#8221; a role, it means that all the
methods and attributes defined here in this role, are added directly to that
class as though the class itself defined them. Moose automatically creates a
constructor and setter and getter accessor methods (called
<em>&#39;radius&#39;</em>) for the consuming class.</p>
<p class="sb-indenthangingN"><strong>4.</strong> The <em>Shape::Circle</em> class is declared.</p>
<p class="sb-indenthangingN"><strong>5.</strong> The <em>Shape::Circle</em> class will
&#8220;consume&#8221; the <em>Radius</em> role. The <em>with</em> function
is used to import or compose the role into the current class. Now this class
will have the radius attribute that was defined in the <em>Radius</em> role.</p>
<p class="sb-indenthangingN"><strong>6.</strong> The <em>Circle</em> defines a <em>color</em>
attribute. The <em>color</em> is a read/write (<em>rw</em>), a string
(<em>Str</em>) with a default value of <em>&#39;blue&#39;</em>.</p>
<p class="sb-indenthangingN"><a id="page_499"/><strong>7.</strong> The <em>calculate_area</em> method
uses the <em>radius</em> attribute (consumed from the role) and the
<em>pi</em> function from <em>Math::Trig</em> to calculate the area of a
circle.</p>
<p class="sb-indenthangingN"><strong>8.</strong> Moose provides a <em>new</em> constructor that creates a
blessed object. The user calls <em>new</em> with the value for the radius as
its argument. This was required by the role when defining the
<em>&#39;radius&#39;</em> attribute on line 3: <em>required=&gt;1</em>;.</p>
<p class="sb-indenthangingN"><strong>9.</strong> The the <em>new</em> object and its attibutes are
displayed by <em>Dumper</em>.</p>
<p class="sb-indenthangingN1"><strong>10.</strong> The radius value is reset to 3. Moose automatically
created a setter called <em>&#39;radius&#39;</em> when the role was defined.</p>
<p class="sb-indenthangingN1"><strong>11.</strong> Moose provided a getter method called
<em>&#39;radius&#39;</em>. This time we use it to get the value of the
radius.</p>
<p class="sb-indenthangingN1"><strong>12.</strong> The <em>calculate_area</em> method is called and
returns the area of the circle, <em>$c1;.</em></p>
<p class="sb-indenthangingN1"><strong>13.</strong> <em>Dumper</em> displays the <em>Shape::Circle</em>
object.</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec17">14.4.5 Overriding a Parent Method and the <em>SUPER</em> Pseudo Class</h4>
<p class="noindent">There are times when two classes may have a method with the same name. If a
derived class has a method with the same name as the base class, its method
will take precedence over the base method. To override the method in the
derived class so you can access the method in the base class, the name of
the method must be fully qualified with the class name and two colons. The
pseudo class called <em>SUPER</em> can also be used by a subclass to call a
method in the parent class; for example,
<em>$self</em>-<em>&gt;SUPER::setName</em> would call the method
<em>setName</em> in the parent class of the current module, and override the
<em>setName</em> method in the current class. This allows the subclass to
wrap or specialize an existing method with its parent method or completely
override its own method with the parent&#8217;s method. (You can also
download the <em>SUPER</em> module from cpan to control dispatching methods
to a superclass.)<sup><a id="ch14fn8a" href="ch14.html#ch14fn8">8</a></sup></p>
</div>
<p class="footnote"><a id="ch14fn8" href="ch14.html#ch14fn8a">8</a>. <em>SUPER</em> isn&#8217;t
a method. It&#8217;s a virtual package, documented in <em>perlobj</em> under
the &#8220;Method Invocation&#8221; section. It bases itself on the current
package, not the package of the object you call it with.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa25"/>EXAMPLE 14.25</p>
<p class="codelink1"><a id="p14exa25" href="ch14_images.html#p14exa25a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;<span class="EmpStrong">package Employee;</span>&#160;&#160;#
<span class="EmpItalic">Base class</span><br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>&#160;&#160;&#160;sub new
{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Employee's constructor is defined</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my %params = @_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = { Name=&gt;$params{"Name"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Salary=&gt;$params{"Salary"},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;&#160;&#160;bless ($self, $class);<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/><a id="page_500"/>2&#160;&#160;<span class="EmpStrong">sub display</span>
{&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Instance method</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;foreach my $key ( @_){<br/>3&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print "$key:
$self-&gt;{$key}\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>4&#160;&#160;&#160;&#160;&#160;print "The class using this display method is
", ref($self),"\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;<br/>&#160;&#160;&#160;---------------------------------------------------------------------<br/>5&#160;&#160;<span class="EmpStrong">package Salesman;</span>&#160;&#160;#
<span class="EmpItalic">Derived class</span><br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>6&#160;&#160;use base qw(<span class="EmpStrong">Employee);</span><br/>7&#160;&#160;<span class="EmpStrong">sub new</span>
{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# <span
class="EmpItalic">Constructor in derived Salesman class</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;my $class = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my (%params) = @_;<br/>8&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">my $self =
$class-&gt;SUPER::new(%params);</span>&#160;&#160;# <span
class="EmpItalic">Call constructor</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">in base class</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;{Commission} =
$params{Commission};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;sub set_salary {<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$self-&gt;{Salary}=$self-&gt;{Salary} +
$self-&gt;{Commission};<br/>&#160;&#160;&#160;}<br/>9&#160;&#160;<span class="EmpStrong">sub display</span>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;my $self = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my @args = @_;<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "Stats for the Salesman\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "-" x 25, "\n";<br/>10&#160;&#160;&#160;&#160;<span
class="EmpStrong">$self-&gt;SUPER::display(@args);</span>&#160;&#160;# <span
class="EmpItalic">SUPER references the parent class</span><br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;1;<br/>&#160;&#160;&#160;&#160;-----------------------------------------<br/>&#160;&#160;&#160;# <span class="EmpItalic">User or Driver Program</span><br/>11 use Salesman;<br/>&#160;&#160;&#160;use strict;<br/>&#160;&#160;&#160;use warnings;<br/>12 my $emp = new Salesman ( "Name", "Tom Savage",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Salary",
50000,&#160;&#160;&#160;# <span class="EmpItalic">Call to constructor</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Commission",
1500,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;$emp-&gt;set_Salary;&#160;&#160;# <span
class="EmpItalic">Call to the access method</span><br/>13 <span class="EmpStrong">$emp-&gt;display( "Name" , "Salary",
"Commission");</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Call Salesman's display method</span><br/><br/>(Output)<br/>9&#160;&#160;<span class="EmpItalic">Stats for the Salesman</span><br/>&#160;&#160;&#160;<span class="EmpItalic">-------------------------</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Name: Tom Savage</span><br/>&#160;&#160;&#160;<span class="EmpItalic">Salary: 51500</span><br/>&#160;&#160;&#160;<span class="EmpItalic">The class using this display
method is Salesman</span></p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_501"/>Explanation</p>
<p class="sb-indenthangingN"><strong>1.</strong> The class <em>Employee</em> is declared. It contains a
constructor method called <em>new</em> and an instance method called
<em>display.</em></p>
<p class="sb-indenthangingN"><strong>2.</strong> The <em>display</em> access method is defined for the
<em>Employee</em> class.</p>
<p class="sb-indenthangingN"><strong>3.</strong> The attributes for the employee are displayed.</p>
<p class="sb-indenthangingN"><strong>4.</strong> The <em>ref</em> function returns the name of the class
of a blessed object.</p>
<p class="sb-indenthangingN"><strong>5.</strong> The <em>Salesman</em> class is declared.</p>
<p class="sb-indenthangingN"><strong>6.</strong> It will inherit from the <em>Employee</em> base
class. It is a derived class.</p>
<p class="sb-indenthangingN"><strong>7.</strong> This is the <em>Saleman</em>&#8217;s constructor.</p>
<p class="sb-indenthangingN"><strong>8.</strong> The <em>SUPER</em> pseudo class is used to call
<em>new</em> in the <em>Employee</em> class. It sends <em>Salesman</em> to
the <em>Employee</em> class where it will be assigned initial properties and
blessed and returned as a new <em>Salesman</em>.</p>
<p class="sb-indenthangingN"><strong>9.</strong> This is the <em>display</em> method for the
<em>Salesman</em> class.</p>
<p class="sb-indenthangingN1"><strong>10.</strong> By qualifying the name of the method to be of class
<em>SUPER</em>, this <em>display</em> method will invoke the
<em>display</em> method in the parent class, <em>Employee</em>.</p>
<p class="sb-indenthangingN1"><strong>11.</strong> This is the driver program. It uses the
<em>Salesman</em> module.</p>
<p class="sb-indenthangingN1"><strong>12.</strong> A new <em>Salesman</em> object is created, using the
pseudo <em>SUPER</em> class.</p>
<p class="sb-indenthangingN1"><strong>13.</strong> The <em>display</em> method is called. Since there is a
<em>display</em> subroutine in the <em>Salesman</em> class, it is the one
that will be called.</p>
<hr/></div>
<div class="heading">
<h3 id="ch14lev1sec5">14.5 Plain Old Documentation&#8212;Documenting a Module</h3>
<p class="noindent">One of the most important phases in creating a useful class is providing the
user with good documentation describing how a module should be used. This is
called the <strong>public user interface</strong>. Whether a module is an
object-oriented class or a procedural module, there must be some published
user interface&#8212;the written documentation&#8212;available describing
how the programmer (client) should use a class (for example, what arguments
will be passed to a method). The publicly defined interface should not
change, even if something in the class is changed.</p>
</div>
<p class="indent">Perl 5 introduced <em>pod</em> commands as a way to document modules. This
is done by interspersing the program with <em>pod</em> (Plain Old
Documentation) instructions, similar to embedding HTML or <em>nroff</em>
instructions within the text of a file. Then the program is run through a
Perl filtering program, which translates the commands into manual pages in a
number of different formats. Wikipedia has excellent documentation on how to
use <em>pod.</em><sup><a id="ch14fn9a" href="ch14.html#ch14fn9">9</a></sup></p>
<p class="footnote"><a id="ch14fn9" href="ch14.html#ch14fn9a">9</a>. See <em><a
href="http://en.wikipedia.org/wiki/Plain_Old_Documentation#Example">http://en.wikipedia.org/wiki/Plain_Old_Documentation#Example</a>.</em></p>
<div class="fig-heading">
<div class="image"><a id="page_502"/><a id="ch14fig06"/><img src="graphics/14fig06.jpg" alt="Image"/></div>
<p class="fig-caption"><strong>Figure 14.6</strong> The example <em>pod</em> at Wikipedia.org.</p>
</div>
<div class="heading">
<h4 id="ch14lev2sec18">14.5.1 <em>pod</em> Files</h4>
<p class="noindent">If you look in the standard Perl library, you will find that the modules
contain documentation explaining what the module is supposed to do and how
to use it. (At the command line, type <em>perldoc perlpod</em>.) The
documentation is either embedded within the program or placed at the end of
the program right after the special literal <em>_ _END_ _</em>. This
documentation is called <em>pod</em>, short for Plain Old Documentation. A
<em>pod</em> file is just an ASCII, utf-8, Unicode text file embedded with
special commands that can be translated by one of Perl&#8217;s special
interpreters, <em>pod2html</em>, <em>pod2latex</em>, <em>pod2text,</em> or
<em>pod2man</em>. The purpose is to create formatted <a
id="page_503"/>documents that can be represented in a number of ways. The
UNIX <em>man</em> pages are an example of documentation that has been
formatted with <em>nroff</em> instructions. It is now easy to embed a set of
<em>pod</em> formatting instructions in your scripts to provide
documentation in any of the four formats: text, HTML, LaTeX, or
<em>nroff</em>.</p>
</div>
<p class="indent">The first line of the <em>pod</em> documentation starts with an equal sign
(<em>=</em>). Each <em>pod</em> instruction starting with an equal sign is a
formatting instruction for the <em>pod</em> translator. <strong>Each
formatting instruction must be terminated with a blank line.</strong></p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa26"/>EXAMPLE 14.26</p>
<p class="codelink1"><a id="p14exa26" href="ch14_images.html#p14exa26a">Click here to view code
image</a></p>
<p class="pre1">(The standard Perl library, under the subdirectory Math.)<br/><br/>=<span class="EmpStrong">head1</span> NAME<br/><br/>Math::BigFloat - Arbitrary length float math package<br/><br/>=<span class="EmpStrong">head1</span> SYNOPSIS<br/><br/>&#160;&#160;use Math::BigFloat;<br/>&#160;&#160;$f = Math::BigFloat-&gt;new($string);<br/><br/>&#160;&#160;$f-&gt;fadd(NSTR) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;addition<br/>&#160;&#160;$f-&gt;fsub(NSTR) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;subtraction<br/>&#160;&#160;$f-&gt;fmul(NSTR) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;multiplication<br/>&#160;&#160;$f-&gt;fdiv(NSTR[,SCALE]) returns
NSTR&#160;&#160;&#160;&#160;&#160;division to SCALE places<br/>&#160;&#160;$f-&gt;fneg() return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;negation<br/>&#160;&#160;$f-&gt;fabs() return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;absolute
value<br/>&#160;&#160;$f-&gt;fcmp(NSTR) return
CODE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;compare
undef,&lt;0,=0,&gt;0<br/>&#160;&#160;$f-&gt;fround(SCALE) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;round
to SCALE digits<br/>&#160;&#160;$f-&gt;ffround(SCALE) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;round at
SCALEth place<br/>&#160;&#160;$f-&gt;fnorm() return
(NSTR)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;normalize<br/>&#160;&#160;$f-&gt;fsqrt([SCALE]) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sqrt to
SCALE places<br/><br/>(Here is the documentation found at the end of the <span
class="EmpItalic">BigFloat.pm</span> module in <span
class="EmpStrong">=head1</span> DESCRIPTION<br/><br/>All basic math operations are overloaded if you declare your big<br/>floats as<br/><br/>&#160;&#160;&#160;$float = new Math::BigFloat
"2.123123123123123123123123123123123";<br/><br/>=over 2<br/><br/><span class="EmpStrong">=item</span> number format<br/><br/>canonical strings have the form /[+-]\d+E[+-]\d+/ . Input values can<br/>have inbedded whitespace.<br/><br/><a id="page_504"/><span class="EmpStrong">=item</span> Error returns 'NaN'<br/><br/>An input parameter was "Not a Number" or divide by zero or sqrt of<br/>negative number.<br/><br/><span class="EmpStrong">=item</span> Division is computed to<br/><br/>C&lt;max($div_scale,length(dividend)+length(divisor))&gt; digits by default.<br/>Also used for default sqrt scale.<br/><br/>=back<br/><br/><span class="EmpStrong">=head1</span> BUGS<br/><br/>The current version of this module is a preliminary version of the<br/>real thing that is currently (as of perl5.002) under development.<br/><br/><span class="EmpStrong">=head1</span> AUTHOR<br/><br/>Mark Biggar<br/><br/>=cut</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sidebarpara">The preceding text is a <em>pod</em> file. It consists of lines starting
with an equal sign and a <em>pod</em> command, then a blank line, and
text. Perl provides a special translator program that reads the <em>pod</em>
file and translates it into a readable file in plain text, HTML format,
<em>nroff</em> text, or LaTeX. The next section describes how to use the
<em>pod</em> filter programs to make the translation for you.</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec19">14.5.2 <em>pod</em> Commands</h4>
<p class="noindent">It&#8217;s easy to embed <em>pod</em> instructions in a text file. Commands
are placed at the beginning of a line, starting with <em>=pod</em> (or any
other <em>pod</em> command) and ending with <em>=cut</em>. Everything after
the first <em>=pod</em> instruction to the <em>=cut</em> instruction will be
ignored by the compiler, just as comments are ignored. The nice thing about
using the commands is that they allow you to create bold, italic, or plain
text, to indent, to create headings, and more. <a
href="ch14.html#ch14tab03">Table 14.3</a> contains a list of instructions.</p>
</div>
<div class="tab-heading">
<div class="image"><a id="ch14tab03"/><img src="graphics/14tab03.jpg" alt="Image"/></div>
<p class="tab-caption"><strong>Table 14.3</strong> <em>pod</em> Commands</p>
</div>
<div class="heading">
<h5 id="ch14lev3sec14">Checking Your pod Commands</h5>
<p class="noindent">To check that you have correct <em>pod</em> instructions in your file, you
can use Perl&#8217;s <em>podchecker</em> command. First, to find the path to
your modue, type at your prompt:</p>
</div>
<p class="pre"><span class="EmpStrong">perldoc -l</span> Module.pm</p>
<p class="noindent"><a id="page_505"/>and then,</p>
<p class="pre"><span class="EmpStrong">podchecker</span> path/Module.pm</p>
<p class="noindent">and hope that it displays the following:</p>
<p class="pre">path/Module.pm <span class="EmpStrong">pod syntax OK.</span></p>
<div class="heading">
<h4 id="ch14lev2sec20"><a id="page_506"/>14.5.3 How to Use the <em>pod</em> Interpreters</h4>
<p class="noindent">The <em>pod</em> interpreters come with the Perl distribution and are
located in the <em>bin</em> directory under the main Perl directory; for
example, in <em>/usr/bin/perl5/bin.</em></p>
</div>
<p class="indent">The four interpreters are</p>
<p class="indenthangingB">&#8226; <em>pod2html</em> (translate to HTML)</p>
<p class="indenthangingB">&#8226; <em>pod2text</em> (translate to plain text)</p>
<p class="indenthangingB">&#8226; <em>pod2man</em> (translate to <em>nroff</em>, like UNIX
<em>man</em> pages)</p>
<p class="indenthangingB">&#8226; <em>pod2latex</em> (translate to LaTeX)</p>
<p class="indent">The easiest way to use the interpreters is to copy the one you want into
your own directory. For example:</p>
<p class="codelink"><a id="p506pro01" href="ch14_images.html#p506pro01a">Click here to view code
image</a></p>
<p class="pre">$ cp /usr/bin/perl5/bin/pod2text</p>
<p class="noindent">You may also copy the library routine into your directory:</p>
<p class="codelink"><a id="p506pro02" href="ch14_images.html#p506pro02a">Click here to view code
image</a></p>
<p class="pre">$ cp /usr/bin/perl5/lib/BigFloat.pm</p>
<p class="indent">Now when you list the contents of the directory, you should have both the
<em>pod</em> interpreter and the library module.</p>
<p class="pre">$ ls<br/>BigFloat.pm<br/>pod2text</p>
<div class="heading">
<h4 id="ch14lev2sec21">14.5.4 Translating <em>pod</em> Documentation into Text</h4>
<p class="noindent">The easiest way to translate the <em>pod</em> commands to text for your
terminal screen is to use the <em>perldoc</em> command that comes with the
Perl distribution. It may not be in your search path, but it is usually
found in the <em>bin</em> directory under <em>perl</em>. The following
command would display all the documentation for the <em>BigFloat.pm</em>
module:</p>
</div>
<p class="pre">perldoc Math::BigFloat</p>
<p class="indent">Another way to translate <em>pod</em> directives to text is to let the
<em>pod</em> interpreter filter through the module and create an output file
to save the translated text. If you don&#8217;t redirect the output to a
file, it will simply go to the screen.</p>
<p class="codelink"><a id="p506pro03" href="ch14_images.html#p506pro03a">Click here to view code
image</a></p>
<p class="pre">$ pod2text BigFloat.pm &gt; BigFloat.Text<br/>$ cat BigFloat.Text&#160;&#160;(The output file after pod commands have been<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;translated
into text.)<br/><br/>NAME<br/>&#160;&#160;&#160;&#160;Math::BigFloat - Arbitrary length float math package<br/><br/>SYNOPSIS<br/>&#160;&#160;&#160;&#160;&#160;&#160;use Math::BigFloat;<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f = Math::BigFloat-&gt;new($string);<br/><br/><a id="page_507"/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fadd(NSTR)
return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;addition<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fsub(NSTR) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;subtraction<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fmul(NSTR) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;multiplication<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fdiv(NSTR[,SCALE])&#160;&#160;&#160;returns
NSTR&#160;&#160;&#160;division to SCALE places<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fneg() return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;negation<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fabs() return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;absolute
value<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fcmp(NSTR) return
CODE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;compare
undef,&lt;0,=0,&gt;0<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fround(SCALE) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;round
to SCALE digits<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;ffround(SCALE) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;round at
SCALEth place<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fnorm() return
(NSTR)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;normalize<br/>&#160;&#160;&#160;&#160;&#160;&#160;$f-&gt;fsqrt([SCALE]) return
NSTR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sqrt to
SCALE places<br/><br/>DESCRIPTION<br/>&#160;&#160;&#160;&#160;All basic math operations are overloaded if you
declare your big<br/>&#160;&#160;&#160;&#160;floats as<br/><br/>$float=newMath::BigFloat"2.123123123123123123123123123123123";<br/><br/>&#160;&#160;&#160;&#160;&#160;number format<br/>&#160;&#160;&#160;&#160;&#160;canonical strings have the form
/[+-]\d+E[+-]\d+/ . Input<br/>&#160;&#160;&#160;&#160;&#160;values can have inbedded whitespace.<br/><br/>&#160;Error returns 'NaN'<br/>&#160;&#160;&#160;&#160;&#160;&#160;An input parameter was "Not a Number" or
divide by zero or<br/>&#160;&#160;&#160;&#160;&#160;&#160;sqrt of negative number.<br/><br/>&#160;Division is computed to<br/>&#160;&#160;&#160;&#160;&#160;&#160;`max($div_scale,length(dividend)+length(divisor))'
digits by<br/>&#160;&#160;&#160;&#160;&#160;&#160;default. Also used for default sqrt
scale.<br/><br/>BUGS<br/>&#160;&#160;&#160;&#160;The current version of this module is a preliminary
version of<br/>&#160;&#160;&#160;&#160;the real thing that is currently (as of perl5.002)
under<br/>&#160;&#160;&#160;&#160;development.<br/><br/>AUTHOR<br/>&#160;&#160;&#160;&#160;Mark Biggar</p>
<div class="heading">
<h4 id="ch14lev2sec22">14.5.5 Translating <em>pod</em> Documentation into HTML</h4>
<p class="noindent">To create an HTML document, use the <em>pod2html</em> command:</p>
</div>
<p class="codelink"><a id="p507pro01" href="ch14_images.html#p507pro01a">Click here to view code
image</a></p>
<p class="pre">$ pod2html BigFloat.pm BigFloat.pm.html</p>
<p class="indent">The <em>pod2html</em> translator will create a file called
<em>BigFloat.pm.html.</em> Now open your browser window click on File &gt;
Open or &lt;CTRL&gt;+O and get <em>BigFloat.pm.html</em> as file protocol in
the URL location box; for example, &lt;<em>file:///yourdirectory
path/BigFloat.pm.html</em>&gt;.<sup><a id="ch14fn10a"
href="ch14.html#ch14fn10">10</a></sup></p>
<p class="footnote"><a id="ch14fn10" href="ch14.html#ch14fn10a">10</a>. If you receive some
obscure diagnostic messages, it may be that the documentation for the
<em>.pm</em> file contains links to some other page that cannot be resolved
by the <em>pod</em> filter.</p>
<div class="fig-heading">
<div class="image"><a id="page_508"/><a id="ch14fig07"/><img src="graphics/14fig07.jpg" alt="Image"/></div>
<p class="fig-caption"><strong>Figure 14.7</strong> Plain Old Documentation Viewed in a Browser.</p>
</div>
<div class="heading">
<h3 id="ch14lev1sec6">14.6 Using Objects from the Perl Library</h3>
<p class="noindent">In <a href="ch13.html#ch13">Chapter 13</a>, &#8220;<a
href="ch13.html#ch13">Modularize It, Package It, and Send It to the
Library!</a>&#8221; we first looked into the standard Perl library that was
provided with this distribution, Perl 5.16. In that library were a number of
Perl modules and subdirectories or folders containing additional modules and
subdirectories. The examples covered in <a href="ch13.html#ch13">Chapter
13</a> dealt with modules that did not require knowledge about Perl&#8217;s
use of objects. Those files utilized standard subroutines, not methods. Now
that you know how objects and methods are used in Perl, the following
examples will demonstrate how to use those modules that require the OOP
methodology.</p>
</div>
<div class="heading">
<h4 id="ch14lev2sec23"><a id="page_509"/>14.6.1 An Object-Oriented Module from the Standard Perl
Library</h4>
<p class="noindent">The following module, <em>BigFloat</em>, is an object-oriented module that
allows the use of floating-point numbers of arbitrary length. Number strings
have the form <em>/[+-]\d*\.?\d*E[+-]\d+/</em>. When NaN is returned, it
means that a non-number was entered as input, that perhaps you tried to
divide by zero, or that you tried to take the square root of a negative
number. <em>BigFloat</em> uses the <em>overload</em> module, which allows
you to define Perl&#8217;s built-in operators to methods that will cause the
operators to behave in a new way. The operator is the key and the method
assigned is the value as you can see in the following example. (See
<em>overload.pm</em> in the standard Perl library.)</p>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa27"/>EXAMPLE 14.27</p>
<p class="codelink1"><a id="p14exa27" href="ch14_images.html#p14exa27a">Click here to view code
image</a></p>
<p class="pre1">(The File: <span class="EmpItalic">BigFloat.pm</span>)<br/><br/>1&#160;&#160;package Math::BigFloat;<br/>2&#160;&#160;use Math::BigInt;<br/><br/>&#160;&#160;&#160;use Exporter;&#160;&#160;# <span class="EmpItalic">Just
for use to be happy</span><br/>&#160;&#160;&#160;@ISA = (Exporter);<br/>3&#160;&#160;<span class="EmpStrong">use overload</span><br/>4&#160;&#160;'+'&#160;&#160;&#160;&#160;=&gt;&#160;&#160;sub {new
Math::BigFloat &#38;fadd},<br/>&#160;&#160;&#160;'-'&#160;&#160;&#160;&#160;=&gt;&#160;&#160;sub {new
Math::BigFloat<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$_[2]?
fsub($_[1],${$_[0]}) : fsub(${$_[0]},$_[1])},<br/>&#160;&#160;&#160;'&lt;=&gt;'&#160;&#160;=&gt;&#160;&#160;sub {new
Math::BigFloat<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$_[2]?
fcmp($_[1],${$_[0]}) : fcmp(${$_[0]},$_[1])},<br/>&#160;&#160;&#160;'cmp'&#160;&#160;=&gt;&#160;&#160;sub {new Math::BigFloat<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$_[2]?
($_[1] cmp ${$_[0]}) : (${$_[0]} cmp $_[1])},<br/>&#160;&#160;&#160;'*'&#160;&#160;&#160;&#160;=&gt;&#160;&#160;sub {new
Math::BigFloat &#38;fmul},<br/>&#160;&#160;&#160;'/'&#160;&#160;&#160;&#160;=&gt;&#160;&#160;sub {new
Math::BigFloat<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$_[2]?
scalar fdiv($_[1],${$_[0]}) :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;scalar
fdiv(${$_[0]},$_[1])},<br/>&#160;&#160;&#160;'neg'&#160;&#160;=&gt;&#160;&#160;sub {new Math::BigFloat
&#38;fneg},<br/>&#160;&#160;&#160;'abs'&#160;&#160;=&gt;&#160;&#160;sub {new Math::BigFloat
&#38;fabs},<br/>&#160;&#160;&#160;qw(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;""&#160;&#160;&#160;stringify<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0+&#160;&#160;&#160;numify)&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Order of arguments unsignificant</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;;<br/><br/>5&#160;&#160;<span class="EmpStrong">sub new</span> {<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($class) = shift;<br/>&#160;&#160;&#160;&#160;&#160;&#160;my ($foo) = fnorm(shift);<br/>6&#160;&#160;&#160;&#160;&#160;panic("Not a number initialized to
Math::BigFloat")<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if
$foo eq "NaN";<br/>7&#160;&#160;&#160;&#160;&#160;bless \$foo, $class;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">&lt; Methods continue
here. Module was too long to put here&gt;</span><br/><a id="page_510"/>&#160;&#160;&#160;# <span
class="EmpItalic">Addition</span><br/>8&#160;&#160;<span class="EmpStrong">sub fadd</span> { #(fnum_str, fnum_str)
return fnum_str<br/>&#160;&#160;&#160;&#160;&#160;&#160;local($x,$y) =
(fnorm($_[$[]),fnorm($_[$[+1]));<br/>&#160;&#160;&#160;&#160;&#160;&#160;if ($x eq 'NaN' || $y eq 'NaN') {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NaN';<br/>&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;local($xm,$xe) =
split('E',$x);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;local($ym,$ye) =
split('E',$y);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;($xm,$x e,$ym,$ye) =
($ym,$ye,$xm,$xe) if ($xe &lt; $ye);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#38;norm(Math::BigInt::badd($ym,$xm.('0'
x ($xe-$ye))),$ye);<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;<span class="EmpItalic">&lt; Methods continue
here&gt;</span><br/><br/>&#160;&#160;&#160;# <span class="EmpItalic">divisionbb</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">args are dividend, divisor,
scale (optional)</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">result has at most max(scale,
length(dividend),</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">length(divisor)) digits</span><br/>9&#160;&#160;<span class="EmpStrong">sub
fdiv</span>&#160;&#160;&#160;&#160;#<span class="EmpItalic">(fnum_str,
fnum_str[,scale]) return fnum_str</span><br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;local($x,$y,$scale) = (fnorm($_[$[]),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fnorm($_[$[+1]),$_[$[+2]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;if ($x eq 'NaN' || $y eq 'NaN' || $y eq
'+0E+0') {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'NaN';<br/>&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;local($xm,$xe) =
split('E',$x);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;local($ym,$ye) =
split('E',$y);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$scale = $div_scale if
(!$scale);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$scale = length($xm)-1
if (length($xm)-1 &gt; $scale);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$scale = length($ym)-1
if (length($ym)-1 &gt; $scale);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$scale = $scale +
length($ym) - length($xm);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#38;norm(&#38;round(Math::BigInt::bdiv($xm.('0'
x $scale),$ym),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$ym),$xe-$ye-$scale);<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title">代码解读</p>
<p class="sb-indenthangingN"><strong>1.</strong> The <em>BigFloat</em> class is declared. The file,
<em>BigFloat.pm</em> resides in the <em>Math</em> subdirectory of the
standard Perl library.</p>
<p class="sb-indenthangingN"><strong>2.</strong> The <em>BigFloat</em> class also needs to use the
<em>BigInt</em> module.</p>
<p class="sb-indenthangingN"><strong>3.</strong> With the <em>overload</em> pragma you can change the
meaning of the built-in Perl operators. For example, when in
<em>BigFloat,</em> the <em>+</em> operator is a key and its value an
anonymous subroutine that creates an object and calls the <em>fadd</em>
subroutine.</p>
<p class="sb-indenthangingN"><strong>4.</strong> The <em>+</em> operator is overloaded. See previous
explanation.</p>
<p class="sb-indenthangingN"><strong>5.</strong> This is <em>BigFloat</em>&#8217;s constructor method for
creating an object.</p>
<p class="sb-indenthangingN"><a id="page_511"/><strong>6.</strong> If the value is not a number, this
panic message is printed.</p>
<p class="sb-indenthangingN"><strong>7.</strong> The object is blessed into the class.</p>
<p class="sb-indenthangingN"><strong>8.</strong> This is the subroutine that performs addition on the
object.</p>
<p class="sb-indenthangingN"><strong>9.</strong> This is the subroutine that performs division on the
object.</p>
<hr/></div>
<div class="heading">
<h4 id="ch14lev2sec24">14.6.2 Using a Module with Objects from the Standard Perl Library</h4>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14exa28"/>EXAMPLE 14.28</p>
<p class="codelink1"><a id="p14exa28" href="ch14_images.html#p14exa28a">Click here to view code
image</a></p>
<p class="pre1">1&#160;&#160;use warnings;<br/>2&#160;&#160;<span class="EmpStrong">use Math::BigFloat;</span>&#160;&#160;#
<span class="EmpItalic">BigFloat.pm is in the Math directory</span><br/><br/>3&#160;&#160;my $number = "000.95671234e-21";<br/>4&#160;&#160;my <span class="EmpStrong">$mathref =
Math::BigFloat-&gt;new("$number");</span>&#160;&#160;# <span
class="EmpItalic">Create the object</span><br/><br/>5&#160;&#160;print "\$mathref is in class ", <span
class="EmpStrong">ref($mathref)</span>, "\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#
<span class="EmpItalic">Where is the object</span><br/><br/>6&#160;&#160;print <span class="EmpStrong">$mathref-&gt;fnorm()</span>,
"\n";&#160;&#160;# <span class="EmpItalic">Use methods from the class</span><br/><br/>7&#160;&#160;print "The sum of $mathref + 500 is: ", <span
class="EmpStrong">$mathref-&gt;fadd("500"),</span> "\n";<br/>8&#160;&#160;print "Division using <span class="EmpStrong">overloaded
operator: ", $mathref / 200.5,</span> "\n";<br/>9&#160;&#160;print "Division using fdiv method:", <span
class="EmpStrong">$mathref-&gt;fdiv("200.5"),</span> "\n";<br/><br/>10 print "Enter a number ";<br/>&#160;&#160;&#160;chomp($numstr = &lt;STDIN&gt;);<br/><br/>11 if ( <span class="EmpStrong">$mathref-&gt;fadd($numstr) eq "NaN"</span>
){<br/>&#160;&#160;&#160;&#160;&#160;&#160;print "You didn't enter a number.\n"};<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;# <span class="EmpItalic">Return value of NaN means the
string is not a number,</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">or you divided by zero, or you
took the square root</span><br/>&#160;&#160;&#160;# <span class="EmpItalic">of a negative number.</span><br/><br/>(Output)<br/>5&#160;&#160;<span class="EmpItalic">$mathref is in class
Math::BigFloat</span><br/>6&#160;&#160;<span class="EmpItalic">+95671234E-29</span><br/>7&#160;&#160;<span class="EmpItalic">The sum of
.00000000000000000000095671234 + 500 is:</span><br/>&#160;&#160;&#160;<span
class="EmpItalic">+50000000000000000000000095671234E-29</span><br/>8&#160;&#160;<span class="EmpItalic">Division using overloaded
operator:</span><br/>&#160;&#160;&#160;<span
class="EmpItalic">.000000000000000000000004771632618453865336658354114713216957606</span><br/>9&#160;&#160;<span class="EmpItalic">Division using fdiv method:</span><br/>&#160;&#160;&#160;<span
class="EmpItalic">+4771632618453865336658354114713216957606E-63</span><br/>10 <span class="EmpItalic">Enter a number hello</span><br/>11 <span class="EmpItalic">You didn't enter a number.</span></p>
<hr/></div>
</div>
<div class="sidebar"><hr/>
<p class="title"><a id="page_512"/>Explanation</p>
<p class="sb-indenthangingN"><strong>1.</strong> Turn on <em>warnings</em>.</p>
<p class="sb-indenthangingN"><strong>2.</strong> The <em>use</em> function loads the module
<em>BigFloat.pm</em> into the program. Since this module is in a
subdirectory of the library called <em>Math</em>, that subdirectory is
included by prepending its name to the module with two colons.</p>
<p class="sb-indenthangingN"><strong>3.</strong> A large number (<em>e</em> notation) is assigned to
<em>$number</em>.</p>
<p class="sb-indenthangingN"><strong>4.</strong> Now the methods from the module are utilized. The
<em>BigFloat</em> constructor is called. A reference to the object is
returned and assigned to <em>$mathref</em>.</p>
<p class="sb-indenthangingN"><strong>5.</strong> The <em>ref</em> function returns the name of the class.</p>
<p class="sb-indenthangingN"><strong>6.</strong> The <em>fnorm</em> method returns the
&#8220;normal&#8221; value of <em>$number</em> in signed scientific
notation. Leading zeros are stripped off.</p>
<p class="sb-indenthangingN"><strong>7.</strong> The <em>fadd</em> method adds <em>500</em> to the
number.</p>
<p class="sb-indenthangingN"><strong>8.</strong> In this example, an overloaded operator is used. The
<em>/</em> operator is assigned a class method, <em>fdiv</em>, to perform
the division. See code from <em>BigFloat.pm</em> shown in <a
href="ch14.html#ch14exa26">Example 14.26</a>.</p>
<p class="sb-indenthangingN"><strong>9.</strong> This time the <em>fdiv</em> method is called directly
without using overloading to perform the division. The output is slightly
different.</p>
<p class="sb-indenthangingN1"><strong>10.</strong> The user is asked to enter a number.</p>
<p class="sb-indenthangingN1"><strong>11.</strong> If <em>NaN</em> (not a number) is returned from the
<em>fadd</em> method, the message is printed. This is a way you could check
that user input is a valid numeric value.</p>
<hr/></div>
<div class="heading">
<h3 id="ch14lev1sec7">14.7 What You Should Know</h3>
<p class="indenthangingN"><strong>1.</strong> What does OOP mean?</p>
</div>
<p class="indenthangingN"><strong>2.</strong> What is the difference between a package and a class?</p>
<p class="indenthangingN"><strong>3.</strong> What is a method?</p>
<p class="indenthangingN"><strong>4.</strong> What is the first parameter received by a class method?</p>
<p class="indenthangingN"><strong>5.</strong> What function creates an object?</p>
<p class="indenthangingN"><strong>6.</strong> What are properties?</p>
<p class="indenthangingN"><strong>7.</strong> What is an instance method?</p>
<p class="indenthangingN"><strong>8.</strong> Does Perl have a <em>private</em> keyword?</p>
<p class="indenthangingN"><strong>9.</strong> How do you name a class? Where do you put a class?</p>
<p class="indenthangingN1"><strong>10.</strong> What is meant by class method invocation?</p>
<p class="indenthangingN1"><strong>11.</strong> What is polymorphism?</p>
<p class="indenthangingN1"><a id="page_513"/><strong>12.</strong> What is the <em>@ISA</em> array used
for?</p>
<p class="indenthangingN1"><strong>13.</strong> What is a derived class?</p>
<p class="indenthangingN1"><strong>14.</strong> What is the <em>SUPER</em> class?</p>
<p class="indenthangingN1"><strong>15.</strong> What is a closure?</p>
<p class="indenthangingN1"><strong>16.</strong> What is a role?</p>
<p class="indenthangingN1"><strong>17.</strong> What is Moose?</p>
<p class="indenthangingN1"><strong>18.</strong> How do you document a class?</p>
<p class="indenthangingN1"><strong>19.</strong> What is a <em>pod</em> filter?</p>
<p class="indenthangingN1"><strong>20.</strong> How is a <em>pod</em> directive used?</p>
<div class="heading">
<h3 id="ch14lev1sec8">14.8 What&#8217;s Next?</h3>
<p class="noindent"><a href="ch15.html#ch15">Chapter 15</a>, &#8220;<a
href="ch15.html#ch15">Perl Connects with MySQL</a>,&#8221; focuses on using
Perl with the MySQL relational database management system, a very popular
open-source, fully functional, relational database. You will learn how to
issue commands at the MySQL client and then use the DBI module to issue the
same commands from a Perl script.</p>
</div>
<div class="heading">
<h3 id="ch14lev1sec9">Exercise 14: What&#8217;s the Object of This Lesson?</h3>
<p class="indent"><strong>Part 1&#8212;Intro to Objects</strong></p>
</div>
<p class="indenthangingN"><strong>1.</strong> Write a module called <em>Rightnow.pm</em> that contains
three methods:</p>
<p class="indenthangingNA"><strong>a.</strong> A constructor called <em>new</em>.</p>
<p class="indenthangingNA"><strong>b.</strong> A method called <em>set_time</em> to set the time. Use
the <em>localtime</em> function.</p>
<p class="indenthangingNA"><strong>c.</strong> A method called <em>print_time</em> to print the
time. This method will take an argument to determine whether the time is
printed in military or standard time; for example,
<em>print_time(&#8220;Military&#8221;);</em></p>
<p class="indenthangingNA"><strong>d.</strong> In another Perl script, use the <em>Rightnow</em> module
to create a <em>Rightnow</em> object, and call the <em>print_time</em>
method to produce output as follows:</p>
<p class="pre2">Time now: 2:48:20 PM<br/>Time now: 14:48:20</p>
<p class="indent"><a id="page_514"/><strong>Part 2&#8212;More Objects</strong></p>
<p class="indenthangingN"><strong>1.</strong> In a class called <em>Student</em>, create an
object. The attributes for the <em>Student</em> object will be sent as
arguments to the constructor method. The <em>Student</em> object will have
three attributes: the <em>name</em> of the student, the student&#8217;s
<em>major</em>, and a list of <em>courses</em> he is taking. Create an
instance method called <em>show_student</em> that will display a
<em>Student</em> object. The user of the module will create two
<em>Student</em> objects and display each.</p>
<p class="indenthangingN"><strong>2.</strong> Add three new attributes to the <em>Student</em> object;
for example, the student&#8217;s address, his ID number, his start date, his
tuition, like so:</p>
<p class="indenthangingNP">Address: 140 Kennedy Drive,</p>
<p class="indenthangingNP">Luxembourg City, Luxembourg</p>
<p class="indenthangingNP">ID: 123A</p>
<p class="indenthangingNP">StartDate: 01/10/07</p>
<p class="indenthangingNP">Tuition: 5400.55</p>
<p class="indenthangingNP">How will you manage this? If the user has so much information to pass to the
constructor, it may be a good time to create an access method called
<em>set_student</em>. Finally, create three new <em>Student</em> objects.</p>
<p class="indenthangingN"><strong>3.</strong> Create two new access methods that take arguments. One
is called <em>add_courses</em> and the other is called
<em>drop_courses</em>. The user interface will allow the user to add or drop
any number of courses by sending a list of parameters to the methods; for
example:</p>
<p class="indenthangingNP"><em>$obj&gt;add_courses([&#8220;C++&#8221;, &#8220;Java&#8221;]);</em></p>
<p class="indenthangingN"><strong>4.</strong> You will use a &#8220;class&#8221; function to keep
track of the number of new students. Each time you add a student, update the
counter. Before exiting the program, print the number of new students. Use
the <em>END</em> block.</p>
<p class="indenthangingN"><strong>5.</strong> From now on, send the data for each student to a
file. It should contain a line that looks like this:</p>
<p class="codelink"><a id="p514pro01" href="ch14_images.html#p514pro01a">Click here to view code
image</a></p>
<p class="pre2">John Doe:14 Main St:3456IX:Math:Trigonometry,Calculus,French:<br/>01/01/06:4500</p>
<p class="indenthangingN"><strong>6.</strong> Create another file that keeps track of the number of
students. Each time you start your script, read the number from the
file. When you add a new student, tell him <em>Welcome, John D</em>.</p>
<p class="indent"><a id="page_515"/><strong>Part 3&#8212;Create an Object-Oriented
Module</strong></p>
<p class="indenthangingN"><strong>1.</strong> Make <em>Checking.pm</em> object oriented. The object
will be &#8220;the balance&#8221; and the subroutines will be
&#8220;methods.&#8221; The constructor will contain at least two attributes:
the <em>balance</em> and the <em>account number</em>. The account number
will be passed to the constructor as an argument. The balance will be
retrieved from the register, initially set to 0. When you create the
register file, append the account number to the filename. Include the
account number, balance, and date in the register file. Use the
<em>Checking</em> module in the ATM user script you created earlier.</p>
<p class="indenthangingN"><strong>2.</strong> Can you make more than one instance of the
<em>Checking</em> object and keep track of the balance for each account?</p>
<p class="indent"><strong>Part 4&#8212;Using Inheritance</strong></p>
<p class="indenthangingN"><strong>1.</strong> Create a <em>Pet</em> class with a constructor and one
access method. The constructor provides attributes for a generic pet, such
as:</p>
<p class="indenthangingNP"><em>owner</em></p>
<p class="indenthangingNP"><em>name</em></p>
<p class="indenthangingNP"><em>gender</em></p>
<p class="indenthangingNA"><strong>a.</strong> The access method is called <em>eat()</em>. It takes one
argument: the type of food a specific pet eats. For example, the dog eats
Alpo. The dog will not have an <em>eat()</em> method and will inherit from
this class.</p>
<p class="indenthangingNA"><strong>b.</strong> Create two classes that will inherit from the
<em>Pet</em> class; for example, a <em>Dog</em> and a <em>Cat</em>
class. They will use the <em>Pet</em>&#8217;s constructor and add new
attributes of their own. They will have a <em>speak()</em> method, but not
an <em>eat()</em> method.</p>
<p class="indenthangingN"><strong>2.</strong> Now we will create a base class called <em>Bank.pm</em>
and two modules that use it: <em>Checking</em> and <em>Savings.</em></p>
<p class="indenthangingNA"><strong>a.</strong> The <em>Bank.pm</em> parent class may or may not have a
constructor but will contain the <em>deposit()</em>, <em>withdraw()</em>,
and <em>get_balance()</em> methods from the <em>Checking.pm</em> module.</p>
<p class="indenthangingNA"><strong>b.</strong> Remove <em>deposit()</em> and <em>withdraw()</em> from
<em>Checking.pm</em>. The program that uses <em>Checking.pm</em> will
inherit these methods from <em>Bank.pm</em> via <em>@ISA</em>.</p>
<p class="indenthangingNA"><strong>c.</strong> Create another module called <em>Savings.pm</em>.</p>
<p class="indenthangingNA"><strong>d.</strong> Both <em>Checking.pm</em> and <em>Savings.pm</em> will
use the <em>Bank</em> module and inherit its methods. Each will have its own
constructor and attributes. One attribute is the status of the account. It
can be &#8220;active&#8221; or &#8220;closed.&#8221; The <em>Savings</em>
account accrues compounded daily interest 1% and must start with a minimum
balance of $200. The <em>Checking</em> account has overdraft protection and
charges $35 for each bounced check. It will not allow an overdraft of over
$300. It can be opened with a starting balance of $25.</p>
<p class="indenthangingNA"><strong>e.</strong> The <em>Checking.pm</em> and <em>Savings.pm</em> modules
will each have its own account numbers and registers.</p>
<p class="indenthangingNA"><a id="page_516"/><strong>f.</strong> The ATM script will use both
modules. The user script will have a main menu allowing the user to select
either of the two accounts. After getting a new account object, the user can
select from the types of transactions (submenu in your original
<em>Checking.pm</em> module) for that account and continue transactions
until he is ready to quit. When he exits, his account register balance will
be updated and he will be asked if he wants to return to the main menu. If
he says &#8220;yes,&#8221; he will see the main menu again, and if he says
&#8220;no,&#8221; the program will exit, giving him his balance. You will
have to uniquely name the register for each account so you can differentiate
between savings and checking accounts.</p>
<p class="indenthangingNAP">Example: <em>perl user.pl</em> (where user input is in bold)</p>
<p class="indenthangingNAP">Welcome!</p>
<p class="indenthangingNAP">Select an account type:</p>
<p class="indenthangingNAPN">1) Checking</p>
<p class="indenthangingNAPN">2) Savings</p>
<p class="indenthangingNAP"><strong>1</strong></p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>1</strong></p>
<p class="indenthangingNAP">How much do you want to deposit? 5.00</p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>3</strong></p>
<p class="indenthangingNAP">Your balance is $30.00</p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>2</strong></p>
<p class="indenthangingNAP"><a id="page_517"/>How much do you want to withdraw? 5.00</p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>3</strong></p>
<p class="indenthangingNAP">Your balance is $25.00</p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>4</strong></p>
<p class="indenthangingNAP">Return to the main menu? <strong>Y</strong></p>
<p class="indenthangingNAP">Welcome!</p>
<p class="indenthangingNAP">Select an account type:</p>
<p class="indenthangingNAPN">1) Checking</p>
<p class="indenthangingNAPN">2) Savings</p>
<p class="indenthangingNAP"><strong>2</strong></p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>3</strong></p>
<p class="indenthangingNAP">Your balance is $100.00</p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>1</strong></p>
<p class="indenthangingNAP"><a id="page_518"/>How much do you want to deposit? <strong>25</strong></p>
<p class="indenthangingNAP">Select a function:</p>
<p class="indenthangingNAPN">1) deposit</p>
<p class="indenthangingNAPN">2) withdraw</p>
<p class="indenthangingNAPN">3) get balance</p>
<p class="indenthangingNAPN">4) exit</p>
<p class="indenthangingNAP"><strong>4</strong></p>
<p class="indenthangingNAP">Your balance is 125.00.</p>
<p class="indent"><strong>Part 5</strong></p>
<p class="indenthangingN"><strong>1.</strong> Go to the <em>pod</em> directory in the standard Perl
library. Look for <em>perlpod.html</em>. The file contains Larry
Wall&#8217;s user interface for using <em>pod</em> commands to document your
Perl programs.</p>
<p class="indenthangingN"><strong>2.</strong> Go to your browser and in the Location box, type:</p>
<p class="codelink"><a id="p518pro01" href="ch14_images.html#p518pro01a">Click here to view code
image</a></p>
<p class="pre2">file:/&lt;directory-to -your-library-file&gt;/Pod/pod.html</p>
<p class="indenthangingNP">Now you have the instructions for creating <em>pod</em> documentation.</p>
<p class="indenthangingN"><strong>3.</strong> Create a published interface for your
<em>Checking.pm</em> module. Embed <em>pod</em> commands in your
<em>Checking.pm</em> script explaining how the module should be used. Follow
the guidelines of the modules in the library; for example, there should be a
NAME, SYNOPSIS, DESCRIPTION, AUTHOR, and so forth. Run the <em>pod</em> file
through the <em>pod2html</em> filter and display the documentation in your
browser. Use the <em>perldoc</em> command to print your documentation on the
terminal screen.</p>
</body>
</html>
